#!/bin/ash
# Ash isn't supported properly in spellcheck static analyzer
# Using debian based version (kind of similar)
# shellcheck shell=dash

# --------------------------------------------
# Main justclash service part
# Directly using uci config calls every load
# Avoid adding simple commands for perfomance
# --------------------------------------------

# shellcheck disable=SC1091
[ -r /lib/functions.sh ] && . /lib/functions.sh
# shellcheck disable=SC1091
[ -r /lib/config/uci.sh ] && . /lib/config/uci.sh

# Variable for standalone or procd start
PROCD_MODE=0
# service pidfile path
PIDFILE="/var/run/justclash.pid"

# setup procd variable: $JUSTCLASH_ENV passed from init.d start
[ "$JUSTCLASH_ENV" = "procd" ] && PROCD_MODE=1 || PROCD_MODE=0

config_load justclash

CORE_LATEST_RELEASE_URL="https://api.github.com/repos/metacubex/mihomo/releases/latest"
CORE_LATEST_ALPHA_RELEASE_URL="https://api.github.com/repos/MetaCubeX/mihomo/releases/tags/Prerelease-Alpha"
CORE_RELEASE_URL_PARTIAL="https://github.com/metacubex/mihomo/releases/download"
CORE_ALPHA_RELEASE_URL_PARTIAL="https://github.com/metacubex/mihomo/releases/download/Prerelease-Alpha"
NO_DATA_STRING="N/A"


CORE_BIN_NAME="mihomo"
# Path to Mihomo core
CORE_PATH="/usr/bin/${CORE_BIN_NAME}"
# workdir path (in RAM)
CORE_WORKDIR_PATH="/tmp/justclash/"
OUTPUT_YAML_CONFIG_PATH="${CORE_WORKDIR_PATH}config.yaml"
TMP_YAML_CONFIG_PATH="${CORE_WORKDIR_PATH}config.build.yaml"
OVERRIDE_YAML_CONFIG_PATH="/var/override.${CORE_BIN_NAME}.yaml"
DEFAULT_CONFIG_PATH="/var/default.justclash.config"

NFT_TABLE_NAME="justclash_tproxy"

# List of NTP server IP addresses:
# 194.190.168.1   — ntp1.stratum2.ru (Russian NTP server)
# 195.208.185.17  — ntp2.stratum2.ru (Russian NTP server)
# 193.232.128.6   — ntp3.stratum2.ru (Russian NTP server)
# 216.239.35.0    — time.google.com (Google NTP)
NTP_IPS="194.190.168.1 195.208.185.17 193.232.128.6 216.239.35.0"
# String for nft tables
# Allow traffic on:
# LAN interfaces (lan*)
# bridge interface (br-lan)
ALLOWED_INTERFACES='{ lan*, br-lan }'
# List of conflicting packages:
# podkop (custom proxy)
# iptables-mod-extra (additional iptables modules)
# and https-dns-proxy (DNS over HTTPS proxy)
CONFLICTED_PACKAGES="podkop iptables-mod-extra https-dns-proxy"
CONFLICTED_PATTERNS_DHCP_CONFIG="doh_backup_noresolv doh_backup_server doh_server"
CONFLICTED_PATTERNS_FILEPATH="/etc/config/dhcp"

ucibool_to_yesno() {
    case "$1" in
        1) echo "Yes" ;;
        0) echo "No" ;;
        *) echo "$1" ;;
    esac
}

panic() {
    local message="$1"
    syslog 0 "$message"
    clog 0 "$message"
    stop
    exit 1
}

get_log_level_name() {
    case "$1" in
        0) echo "ERROR" ;;
        1) echo "WARNING" ;;
        2) echo "INFO" ;;
        3) echo "DEBUG" ;;
        *) echo "UNKNOWN" ;;
    esac
}

get_log_level_syslog() {
    case "$1" in
        0) echo "user.err" ;;
        1) echo "user.warning" ;;
        2) echo "user.info" ;;
        3) echo "user.debug" ;;
        *) echo "user.debug" ;;
    esac
}

syslog() {
    local level="$1"
    local message="$2"
    local level_syslog=""
    level_syslog=$(get_log_level_syslog "$level")

    logger -p "$level_syslog" -t "justclash" "$message"
}

clog() {
    local level="$1"
    local message="$2"
    local timestamp=""
    local level_str=""

    [ $PROCD_MODE -eq 1 ] && return

    timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    level_str=$(get_log_level_name "$level")

    printf "[%s] [%s] %s\n" "$timestamp" "$level_str" "$message"
}

log() {
    local level="$1"
    local message="$2"
    local emoji="${3:-}"

    syslog "$level" "$message"

    [ $PROCD_MODE -eq 1 ] && return

    if [ -n "$emoji" ]; then
        clog "$level" "$emoji ${message}"
    else
        clog "$level" "$message"
    fi
}

is_package_installed() {
    local found_pkgs=""
    local pkgcommand=""

    if command -v apk >/dev/null 2>&1; then
        pkgcommand="apk info"
    else
        pkgcommand="opkg list-installed"
    fi

    for pkg in "$@"; do
        if $pkgcommand | grep -qw "$pkg"; then
            found_pkgs="${found_pkgs:+$found_pkgs }$pkg"
        fi
    done

    if [ -n "$found_pkgs" ]; then
        echo "$found_pkgs"
        return 0
    else
        return 1
    fi
}

is_pattern_in_file() {
    if [ -z "$1" ]; then
        return 1
    fi

    local file="$1"

    if [ ! -r "$file" ]; then
        return 1
    fi
    local found_patterns=""
    for pattern in "$@"; do
        if grep -qE "$pattern" "$file"; then
            found_patterns="${found_patterns:+$found_patterns }$pattern"
        fi
    done
    if [ -n "$found_patterns" ]; then
        echo "$found_patterns"
        return 0
    else
        return 1
    fi
}

ntp_force_sync() {
    local forcefully_update_ntp_at_load
    config_get_bool forcefully_update_ntp_at_load settings forcefully_update_ntp_at_load
    if [ -z "$NTP_IPS" ]; then
        log 1 "No NTP servers configured" "⚠️"
        return 1
    fi

    if ! command -v /usr/sbin/ntpd >/dev/null; then
        log 1 "ntpd not found, time synchronization skipped" "⚠️"
        return 1
    fi

    if [ "$forcefully_update_ntp_at_load" -eq 1 ]; then
        NTP_ARGS=""
        for ip in $NTP_IPS; do
            NTP_ARGS="$NTP_ARGS -p $ip"
        done
        # shellcheck disable=SC2086
        /usr/sbin/ntpd -q $NTP_ARGS
    fi

    sleep 0.5
}

start() {

    if [ -f "$PIDFILE" ]; then
        log 2 "Detected PID file for service... Stopping instance" "⏳"
        stop_core
    fi

    log 2 "Initializing Justclash service..." "⏳"

    log 2 "Checking for conflicts" "🐞"
    check_for_conflicts

    log 2 "Synchronizing system time" "🕒"
    ntp_force_sync

    log 2 "Preparing Mihomo working directory" "📦"
    core_prepare_workdir

    log 2 "Generating yaml configuration..." "📄"
    core_generate_yaml

    log 2 "Configuring TPROXY routing and creating NFTables table" "🔑"
    nft_table_add

    log 2 "Modifying dnsmasq configuration" "🔑"
    dnsmasq_inject

    # Demonizing
    log 2 "Starting Mihomo core" "🚀"
    start_core
}

stop() {
    log 2 "Closing Justclash service..." "⏳"
    log 2 "Removing TPROXY routing and NFTables table" "🔑"
    nft_table_remove
    log 2 "Restoring default dnsmasq configuration" "🔑"
    dnsmasq_clean
    log 2 "Stopping core process" "🚀"
    stop_core
}

restart() {
    log 2 "Performing complete restart" "🔄"
    stop
    sleep 1
    start
}

info_device() {
    local res
    res=$(./justclash_info info_device)
    echo "$res"
}

info_openwrt() {
    local res
    res=$(./justclash_info info_openwrt)
    echo "$res"
}

info_mihomo() {
    local res
    res=$(./justclash_info info_mihomo)
    echo "$res"
}

info_package() {
    local res
    res=$(./justclash_info info_package)
    echo "$res"
}

info_luci() {
    local res
    res=$(./justclash_info info_luci)
    echo "$res"
}

info_conns_console() {
    local res
    res=$(./justclash_info info_conns_console)
    echo "$res"
}

systemlogs() {
    local res
    local lines=${1:-40}
    res=$(./justclash_info systemlogs "$lines")
    echo "$res"
}

diag_nft() {
    clog 2 "Checking for 'nft' command..."
    if ! command -v nft >/dev/null 2>&1; then
        clog 0 "The 'nft' command is not available. Please install nftables to continue."
        return 1
    fi

    clog 2 "Verifying existence of NFTables table '$NFT_TABLE_NAME'..."
    if ! nft list table inet "$NFT_TABLE_NAME" >/dev/null 2>&1; then
        clog 0 "Table '$NFT_TABLE_NAME' not found. Please create the required NFTables table."
        return 1
    fi

    clog 2 "Displaying current NFTables configuration:"
    nft list table inet "$NFT_TABLE_NAME"

    clog 2 "NFTables check completed successfully."

    return 0
}

# WARNING: TRY TO NOT USE FUNC MANUALLY - MUST CLEAR ROUTES AND DNSMASQ
start_core() {
    # TODO: Remove in future
    if [ -f "$PIDFILE" ]; then
        log 2 "Another process instance is already running. Can't run another instance."
        return 1
    fi

    log 2 "Daemonizing Mihomo core..."
    (
        echo $$ > "$PIDFILE"
        exec "$CORE_PATH" -d "$CORE_WORKDIR_PATH" 2>&1 | logger -t justclash
    ) &
}

# WARNING: TRY TO NOT USE FUNC MANUALLY - MUST CLEAR ROUTES AND DNSMASQ
stop_core() {
    local pid
    if [ -f "$PIDFILE" ]; then
        pid=$(cat "$PIDFILE")
        log 2 "Stopping core process (PID $pid)"

        kill -TERM "$pid" 2>/dev/null

        local count=0
        while kill -0 "$pid" 2>/dev/null && [ $count -lt 4 ]; do
            sleep 1
            count=$((count+1))
        done

        if kill -0 "$pid" 2>/dev/null; then
            log 1 "Force killing process $pid"
            kill -9 "$pid"
        fi

        rm -f "$PIDFILE"
        log 2 "Core process stopped" "✅"
    else
        log 1 "PID file not found, using fallback stop method"
        if ! killall "$(basename "$CORE_PATH")" >/dev/null 2>&1; then
            log 2 "Process not found: $(basename "$CORE_PATH")" "⚠️"
        fi
    fi
}

nft_table_add() {
    local tproxy_port
    local routing_mark
    local hex_mark
    local fake_ip_range
    config_get tproxy_port proxy tproxy_port
    config_get routing_mark proxy routing_mark
    config_get fake_ip_range proxy fake_ip_range "198.18.0.0/16"

    hex_mark=$(printf '0x%x' "$routing_mark")

    if [ -z "$tproxy_port" ] || [ -z "$routing_mark" ] || [ -z "$fake_ip_range" ] || [ -z "$hex_mark" ]; then
        panic "One or more required variables for NFT tables are not set in configuration"
    fi

    # Table cleanup
    nft delete table inet "$NFT_TABLE_NAME" 2>/dev/null || true
    nft add table inet "$NFT_TABLE_NAME"

    # IP routes
    nft add set inet "$NFT_TABLE_NAME" reserved_ips { type ipv4_addr\; flags interval\; elements = { \
        0.0.0.0/8, 10.0.0.0/8, 100.64.0.0/10, 127.0.0.0/8, \
        169.254.0.0/16, 172.16.0.0/12, 192.168.0.0/16, \
        224.0.0.0/4, 240.0.0.0/4 } \; }

    # Set for FAKE IP
    nft add set inet "$NFT_TABLE_NAME" fake_ips { type ipv4_addr\; flags interval\; elements = { $fake_ip_range } \; }

    # Chains
    nft add chain inet "$NFT_TABLE_NAME" mangle '{ type filter hook prerouting priority -150; policy accept; }'
    nft add chain inet "$NFT_TABLE_NAME" prerouting_tproxy '{ type filter hook prerouting priority -100; policy accept; }'
    nft add chain inet "$NFT_TABLE_NAME" output '{ type route hook output priority -150; policy accept; }'

    # ---- MANGLE CHAIN ----
    nft add rule inet "$NFT_TABLE_NAME" mangle iifname "$ALLOWED_INTERFACES" ip daddr @fake_ips meta l4proto { tcp, udp } meta mark set "$hex_mark"
    nft add rule inet "$NFT_TABLE_NAME" mangle ct status dnat return
    nft add rule inet "$NFT_TABLE_NAME" mangle meta mark "$hex_mark" return
    nft add rule inet "$NFT_TABLE_NAME" mangle iifname != "$ALLOWED_INTERFACES" return
    nft add rule inet "$NFT_TABLE_NAME" mangle ip daddr @reserved_ips return
    nft add rule inet "$NFT_TABLE_NAME" mangle meta l4proto { tcp, udp } meta mark set "$hex_mark"

    # ---- TPROXY CHAIN ----
    nft add rule inet "$NFT_TABLE_NAME" prerouting_tproxy meta mark "$hex_mark" meta l4proto { tcp, udp } tproxy to :"$tproxy_port"

    # ---- OUTPUT CHAIN ----
    nft add rule inet "$NFT_TABLE_NAME" output meta mark "$hex_mark" return
    nft add rule inet "$NFT_TABLE_NAME" output ct status dnat return
    nft add rule inet "$NFT_TABLE_NAME" output ip daddr @reserved_ips return
    nft add rule inet "$NFT_TABLE_NAME" output ip daddr @fake_ips meta l4proto { tcp, udp } meta mark set "$hex_mark"
    nft add rule inet "$NFT_TABLE_NAME" output meta l4proto { tcp, udp } meta mark set "$hex_mark"

    # Routing
    ip rule del fwmark "$hex_mark" table 100 2>/dev/null || true
    ip rule add fwmark "$hex_mark" table 100
    ip route replace local 0.0.0.0/0 dev lo table 100

    log 3 "TPROXY: port=$tproxy_port, fwmark=$hex_mark, table=100"
}


nft_table_remove() {
    ip rule del fwmark 0x1 table 100 2>/dev/null || true
    nft flush table inet "$NFT_TABLE_NAME" 2>/dev/null || true
    nft delete table inet "$NFT_TABLE_NAME" 2>/dev/null || true
    ip route flush table 100 2>/dev/null || true

    log 2 "TPROXY Clash rules and routing were removed."
}

# Thx Podkop, feels so annoyed already by shell scripting
save_dnsmasq_config() {
    local key="$1"
    local backup_key="$2"
    value=$(uci get "$key" 2>/dev/null)

    if [ -z "$value" ]; then
        uci set "$backup_key"="unset"
    else
        uci set "$backup_key"="$value"
    fi
}

dnsmasq_inject() {
    local dns_listen_port update_dns_server_at_load
    config_get dns_listen_port proxy dns_listen_port
    config_get_bool update_dns_server_at_load settings update_dns_server_at_load

    if [ "$update_dns_server_at_load" -eq 1 ]; then

        uci -q delete dhcp.@dnsmasq[0].justclash_server
        for server in $(uci get dhcp.@dnsmasq[0].server 2>/dev/null); do
            if [ "$server" = "127.0.0.1#${dns_listen_port}" ]; then
                log 1 "Dnsmasq save config error: server=127.0.0.1 is already configured. Skip editing DHCP"
                return 1
            else
                uci add_list dhcp.@dnsmasq[0].justclash_server="$server"
            fi
        done

        save_dnsmasq_config "dhcp.@dnsmasq[0].noresolv" "dhcp.@dnsmasq[0].justclash_noresolv"
        save_dnsmasq_config "dhcp.@dnsmasq[0].cachesize" "dhcp.@dnsmasq[0].justclash_cachesize"

        uci add_list dhcp.@dnsmasq[0].server="127.0.0.1#$dns_listen_port"
        uci set dhcp.@dnsmasq[0].cachesize="0"
        uci set dhcp.@dnsmasq[0].noresolv="1"

        uci commit dhcp
        log 2 "DNS settings have been changed"
        /etc/init.d/dnsmasq restart > /dev/null 2>&1
	    log 2 "dnsmasq restarted"
    else
        log 2 "DNS settings not changed — skipped due to configuration"
    fi

}

dnsmasq_clean() {
    local dns_listen_port
    config_get dns_listen_port proxy dns_listen_port
    local update_dns_server
    config_get_bool update_dns_server settings update_dns_server_at_load

    local bak_cachesize
    local bak_noresolv
    local server

    if [ "$update_dns_server" -eq 1 ]; then
        bak_cachesize=$(uci get dhcp.@dnsmasq[0].justclash_cachesize 2>/dev/null)
        if [ -z "$bak_cachesize" ]; then
            log "dnsmasq revert: cachesize is unset"
        else
            uci set dhcp.@dnsmasq[0].cachesize="$bak_cachesize"
        fi

        bak_noresolv=$(uci get dhcp.@dnsmasq[0].justclash_noresolv 2>/dev/null)
        if [ "$bak_noresolv" = "unset" ]; then
            log "dnsmasq revert: noresolv is unset"
            uci -q delete dhcp.@dnsmasq[0].noresolv
        else
            uci set dhcp.@dnsmasq[0].noresolv="$bak_noresolv"
        fi

        server=$(uci get dhcp.@dnsmasq[0].server 2>/dev/null)
        if [ "$server" = "127.0.0.1#${dns_listen_port}" ]; then
            uci -q delete dhcp.@dnsmasq[0].server 2>/dev/null
            for server in $(uci get dhcp.@dnsmasq[0].justclash_server 2>/dev/null); do
                uci add_list dhcp.@dnsmasq[0].server="$server"
            done
            uci delete dhcp.@dnsmasq[0].justclash_server 2>/dev/null
        fi

        uci commit dhcp
        log 2 "DNS settings have been restored"
        /etc/init.d/dnsmasq restart > /dev/null 2>&1
        log 2 "dnsmasq restarted"
    else
        log 2 "DNS settings not changed — skipped due to configuration"
    fi
 }

check_for_conflicts() {
    local installed_pkgs found_patterns pkg pattern

    # For $CONFLICTED_PACKAGES only. We don't need "" to make shell split string
    # shellcheck disable=SC2086
    installed_pkgs=$(is_package_installed $CONFLICTED_PACKAGES)
    if [ -n "$installed_pkgs" ]; then
        for pkg in $installed_pkgs; do
            log 1 "Conflicting package detected: $pkg"
        done
        panic "Conflicting packages detected, aborting."
    fi

    # For $CONFLICTED_PATTERNS_DHCP_CONFIG only. We don't need "" to make shell split string
    # shellcheck disable=SC2086
    found_patterns=$(is_pattern_in_file "$CONFLICTED_PATTERNS_FILEPATH" "$CONFLICTED_PATTERNS_DHCP_CONFIG")
    if [ -n "$found_patterns" ]; then
        for pattern in $found_patterns; do
            log 1 "Detected https-dns-proxy pattern '$pattern' in /etc/config/dhcp. Please review and edit the configuration file."
        done
        panic "Conflicting DHCP patterns detected, aborting."
    fi
}

# TODO: Finish dynamic prefix
generate_yaml_array() {
    local section_type="$1"
    local list_name="$2"
    local prefix="${4:-    - }"

    result=""

    _append_line() {
        # shellcheck disable=SC2317
        local val="$1"
        # shellcheck disable=SC2317
        result="${result}${prefix}${val}\n"
    }

    _collect_section() {
        # shellcheck disable=SC2317
        config_list_foreach "$1" "$list_name" _append_line
    }

    config_foreach _collect_section "$section_type"

    # shellcheck disable=SC3036
    echo -e "$result"
}

ucibool_to_yaml_bool () {
    local input="$1"
    [ "$input" -eq 1 ] && echo "true" || echo "false"
}

core_generate_yaml() {
    local log_level tproxy_port unified_delay routing_mark
    local tcp_concurrent external_controller_port global_client_fingerprint
    local keep_alive_idle keep_alive_interval profile_store_selected profile_store_fake_ip
    local core_ntp_enabled core_ntp_interval core_ntp_server core_ntp_port  core_ntp_write_system
    local dns_listen_port use_hosts use_system_hosts fake_ip_range

    local default_nameserver direct_nameserver proxy_server_nameserver nameserver ignore_fake_ip_domains ignore_to_sniff_domains

    # Support for manual config files
    # If detected - no settings from config file will be applied
    # DANGEROUS!
    if [ -f OVERRIDE_YAML_CONFIG_PATH ]; then
        log 1 "A dangerous state detected: override configuration file found at \"$OVERRIDE_YAML_CONFIG_PATH\". \
        This file will be used as the active configuration, but correct operation is not guaranteed. \
        This may lead to unexpected behavior, service instability, or security vulnerabilities. \
        Please verify the contents of the override configuration file and ensure it is intended for use before proceeding. \
        If this was not expected, investigate the origin of the override file and consider restoring the default configuration."
        cp "$OVERRIDE_YAML_CONFIG_PATH" "$TMP_YAML_CONFIG_PATH"
        return 0
    fi

    config_get log_level proxy log_level
    config_get tproxy_port proxy tproxy_port
    config_get_bool unified_delay proxy unified_delay
    unified_delay=$(ucibool_to_yaml_bool "$unified_delay")
    config_get routing_mark proxy routing_mark
    config_get_bool tcp_concurrent proxy tcp_concurrent
    tcp_concurrent=$(ucibool_to_yaml_bool "$tcp_concurrent")
    config_get external_controller_port proxy external_controller_port
    config_get global_client_fingerprint proxy global_client_fingerprint
    config_get keep_alive_idle proxy keep_alive_idle
    config_get keep_alive_interval proxy keep_alive_interval
    config_get_bool profile_store_selected proxy profile_store_selected
    profile_store_selected=$(ucibool_to_yaml_bool "$profile_store_selected")
    config_get_bool profile_store_fake_ip proxy profile_store_fake_ip
    profile_store_fake_ip=$(ucibool_to_yaml_bool "$profile_store_fake_ip")
    config_get_bool core_ntp_enabled proxy core_ntp_enabled
    core_ntp_enabled=$(ucibool_to_yaml_bool "$core_ntp_enabled")
    config_get core_ntp_server proxy core_ntp_server
    config_get core_ntp_port proxy core_ntp_port
    config_get core_ntp_interval proxy core_ntp_interval
    config_get_bool core_ntp_write_system proxy core_ntp_write_system
    core_ntp_write_system=$(ucibool_to_yaml_bool "$core_ntp_write_system")
    config_get dns_listen_port proxy dns_listen_port
    config_get_bool use_hosts proxy use_hosts
    use_hosts=$(ucibool_to_yaml_bool "$use_hosts")
    config_get_bool use_system_hosts proxy use_system_hosts
    use_system_hosts=$(ucibool_to_yaml_bool "$use_system_hosts")
    config_get fake_ip_range proxy fake_ip_range
    default_nameserver=$(generate_yaml_array proxy default_nameserver)
    direct_nameserver=$(generate_yaml_array proxy direct_nameserver)
    proxy_server_nameserver=$(generate_yaml_array proxy proxy_server_nameserver)
    nameserver=$(generate_yaml_array proxy nameserver)
    ignore_fake_ip_domains=$(generate_yaml_array proxy ignore_fake_ip_domains)
    ignore_to_sniff_domains=$(generate_yaml_array proxy ignore_to_sniff_domains)

    cat <<EOF > "$TMP_YAML_CONFIG_PATH"
mode: rule
ipv6: false
log-level: $log_level
tproxy-port: $tproxy_port
unified-delay: $unified_delay
tcp-concurrent: $tcp_concurrent
external-controller: 0.0.0.0:$external_controller_port
routing-mark: $routing_mark
global-client-fingerprint: $global_client_fingerprint
global-ua: Mozilla/5.0 (X11; Linux x86_64; rv:125.0) Gecko/20100101 Firefox/125.0

find-process-mode: off
geodata-mode: false

keep-alive-idle: $keep_alive_idle
keep-alive-interval: $keep_alive_interval

profile:
  store-selected: $profile_store_selected
  store-fake-ip: $profile_store_fake_ip
  tracing: false

ntp:
  enable: $core_ntp_enabled
  write-to-system: $core_ntp_write_system
  server: $core_ntp_server
  port: $core_ntp_port
  interval: $core_ntp_interval

dns:
  enable: true
  listen: 0.0.0.0:$dns_listen_port
  ipv6: false
  use-hosts: $use_hosts
  use-system-hosts: $use_system_hosts
  enhanced-mode: fake-ip
  fake-ip-range: $fake_ip_range
  default-nameserver:
$default_nameserver
  nameserver:
$nameserver
  proxy-server-nameserver:
$proxy_server_nameserver
  direct-nameserver:
$direct_nameserver
  respect-rules: true
  fake-ip-filter-mode: blacklist
  fake-ip-filter:
$ignore_fake_ip_domains

sniffer:
  enable: true
  parse-pure-ip: true
  sniff:
    HTTP:
      ports: [80, 8080-8880]
      override-destination: true
    TLS:
      ports: [443, 8443]
    QUIC:
      ports: [443, 8443]
  skip-domain:
$ignore_to_sniff_domains

EOF

    local rules proxies proxy_groups rule_providers
    config_get rules compiled rules
    config_get proxies compiled proxies
    config_get proxy_groups compiled proxy_groups
    config_get rule_providers compiled rule_providers

    cat <<EOF >> "$TMP_YAML_CONFIG_PATH"
proxies:
$proxies

proxy-groups:
$proxy_groups

rule-providers:
$rule_providers

rules:
$rules
EOF

    return 0;
}

core_prepare_workdir() {
    log 1 "Preparing workdir $CORE_WORKDIR_PATH"

    if [ -d "$CORE_WORKDIR_PATH" ]; then
        [ -f "$OUTPUT_YAML_CONFIG_PATH" ] && rm -f "$OUTPUT_YAML_CONFIG_PATH"
        [ -f "$TMP_YAML_CONFIG_PATH" ] && rm -f "$TMP_YAML_CONFIG_PATH"
    else
        mkdir -p "$CORE_WORKDIR_PATH"
    fi
}

# TODO: Remove impossible archs
detect_arch() {
    local arch_raw
    arch_raw=$(uname -m)

    case "$arch_raw" in
        x86_64) echo "amd64";;
        aarch64) echo "arm64" ;;
        armv5*) echo "armv5" ;;
        armv6*) echo "armv6" ;;
        armv7*) echo "armv7" ;;
        mips*) echo "mips" ;;
        i[3-6]86) echo "i386" ;;
        *) echo "amd64" ;;
    esac
}

get_latest_version() {
    if [ -z "$1" ]; then
        log 1 "Usage: get_latest_version <check_url>"
        return 1
    fi

    local check_url="$1"
    local latest_url latest_ver
    latest_url=$(curl -sL -o /dev/null -w '%{url_effective}' "$check_url") || {
        log 3 "Failed to get effective URL"
        return 1
    }
    latest_ver=$(curl -sL "$latest_url/version.txt" | tr -d '\r\n') || {
        log 3 "Failed to get version"
        return 1
    }
    echo "$latest_ver"
}

core_download() {
    local arch version file_name base_url param_version download_url
    param_version="$2"
    download_url="$1"

    if [ -z "$1" ] || [ -z "$2" ]; then
        log 1 "Usage: core_download <download_url> <version>"
        return 1
    fi

    arch=$(detect_arch)
    mkdir -p "$CORE_WORKDIR_PATH"

    file_name="mihomo-linux-${arch}-${param_version}.gz"
    base_url="${download_url}/${file_name}"

    log 2 "Downloading mihomo binary" "📥"
    curl -sL -o "${CORE_WORKDIR_PATH}/mihomo.gz" "$base_url" || {
        log 3 "Failed to download file." "❌"
        return 1
    }

    log 2 "Extracting to $CORE_PATH" "⬇️"
    gunzip -c "${CORE_WORKDIR_PATH}/mihomo.gz" > "$CORE_PATH" || {
        log 3 "Failed to extract file." "❌"
        return 1
    }

    log 2 "Mihomo installed at $CORE_PATH" "🚀"

    if ! chmod +x "$CORE_PATH"; then
        log 0 "Failed to set executable permissions: $CORE_PATH"
    fi

    log 2 "Cleaning up temporary files" "🧹"
    if ! rm -f "${CORE_WORKDIR_PATH}/mihomo.gz"; then
        log 1 "Failed to clean up temporary file: ${CORE_WORKDIR_PATH}/mihomo.gz"
    fi
}

core_remove() {
    if [ ! -x "$CORE_PATH" ]; then
        log 1 "Mihomo is not installed." "⚠️"
        return 1
    else
        if rm -f "$CORE_PATH"; then
            log 2 "Mihomo is removed." "✅"
            return 0
        else
            log 3 "Failed to remove Mihomo binary: $CORE_PATH" "❌"
            return 1
        fi
    fi
}

core_update() {
    local cur_ver latest_ver tmp mihomo_update_channel
    local check_url download_url
    config_get mihomo_update_channel settings mihomo_update_channel

    log 2 "Checking for Mihomo updates..." "🔄"

    if [ "$mihomo_update_channel" = "alpha" ]; then
        check_url=$CORE_LATEST_ALPHA_RELEASE_URL
    else
        check_url=$CORE_LATEST_RELEASE_URL
    fi

    cur_ver=$(info_mihomo)
    tmp=$(get_latest_version "$check_url")
    if [ $? -eq 1 ]; then
        log 3 "Update process can't be finished."
        return 1
    fi

    latest_ver=$(echo "$tmp" | sed -n 1p)

    if [ "$mihomo_update_channel" = "alpha" ]; then
        download_url=$CORE_ALPHA_RELEASE_URL_PARTIAL
    else
        download_url=$CORE_RELEASE_URL_PARTIAL/$latest_ver
    fi

    if [ -z "$latest_ver" ]; then
       log 3 "Error happened when trying to receive latest version data."
       log 3 "It may be due to a GitHub API rate limit or the release may not exist. Please check manually."
       log 3 "Failed to download core"
       return 1
    fi

    if [ "$cur_ver" = "$NO_DATA_STRING" ] || [ -z "$cur_ver" ]; then
        log 1 "Mihomo is not installed. Installing version $latest_ver." "⚠️"
        core_download "$download_url" "$latest_ver"
        if [ $? -eq 1 ]; then
            log 3 "Update process can't be finished."
            send_telegram "Mihomo core binary was missing. Install try for version $latest_ver failed."
            return 1
        fi
        send_telegram "Mihomo core binary was missing. Installed $latest_ver"
        return 0
    fi

    log 2 "Current Mihomo version: $cur_ver"
    log 2 "Latest Mihomo version: $latest_ver"

    if [ "$cur_ver" != "$latest_ver" ]; then
        log 2 "Removing current mihomo binary..." "⚠️"
        core_remove
        if [ $? -eq 1 ]; then
            log 3 "Update process can't be finished."
            return 1
        fi
        log 2 "Updating Mihomo to version $latest_ver" "⬆️"
        core_download "$download_url" "$latest_ver"
        if [ $? -eq 1 ]; then
            log 3 "Update process can't be finished."
            send_telegram "Mihomo core binary was updated. Install try for version: $cur_ver -> $latest_ver failed."
            return 1
        fi
        send_telegram "Mihomo core binary was updated. Version: $cur_ver -> $latest_ver"

    else
        send_telegram "Mihomo core binary is already up-to-date."
        log 2 "Mihomo is already up-to-date." "✅"
    fi

    return 0
}



send_telegram() {
    if [ -z "$1" ]; then
        log 1 "Usage: send_telegram <message>"
        return 1
    fi

    local message="$1"
    local token chat_id

    config_get token settings telegram_bot_token
    config_get chat_id settings telegram_chat_id

    if [ -z "$token" ] || [ -z "$chat_id" ]; then
        log 1 "Telegram: bot token or chat ID is not configured" "⚠️"
        return 1
    fi

    response=$(curl -s -w "\n%{http_code}" -X POST "https://api.telegram.org/bot${token}/sendMessage" \
        -d chat_id="$chat_id" \
        -d text="$message" \
        -d parse_mode="HTML" \
        -d disable_notification=true)

    local curl_exit=$?
    http_code=$(echo "$response" | tail -n1)

    if [ "$curl_exit" -ne 0 ]; then
        log 1 "Telegram: network error, curl exited with code $curl_exit" "❌"
        return 1
    fi

    if [ "$http_code" != "200" ]; then
        log 1 "Telegram: failed to send message (HTTP $http_code)" "❌"
        return 1
    fi

    return 0
}

cron_make_if_missing() {
    if [ ! -f "/etc/crontabs/root" ]; then
        touch "/etc/crontabs/root"
    fi
}

core_update_cron_check() {
    cron_make_if_missing
    if grep -q "/usr/bin/justclash core_update" /etc/crontabs/root; then
        return 0
    else
        return 1
    fi
}

core_update_cron_add() {
    cron_make_if_missing
    local mihomo_cron_update_string

    if [ -z "$mihomo_cron_update_string" ]; then
        log 1 "Cron schedule string is empty! Cron job not added." "❌"
        return 1
    fi

    if core_update_cron_check > /dev/null; then
        log 1 "Core autoupdate cron job already exists." "ℹ️"
        return 0
    fi

    config_get mihomo_cron_update_string settings mihomo_cron_update_string
    echo "$mihomo_cron_update_string /usr/bin/justclash core_update" >> /etc/crontabs/root
    if /etc/init.d/cron enabled; then
        /etc/init.d/cron restart
        log 2 "Cron job added and service restarted" "✅"
    else
        log 2 "Cron job added (service not enabled)" "ℹ️"
    fi
    log 2 "Core autoupdate cron job added." "✅"
}

core_update_cron_remove() {
    cron_make_if_missing
    if core_update_cron_check > /dev/null; then
        sed -i '\|/usr/bin/justclash core_update|d' /etc/crontabs/root
        if /etc/init.d/cron enabled; then
            /etc/init.d/cron restart
            log 2 "Cron job added and service restarted" "✅"
        else
            log 2 "Cron job added (service not enabled)" "ℹ️"
        fi
        log 2 "Core autoupdate cron job removed." "🗑️"
    else
        log 2 "Core autoupdate cron job not found." "ℹ️"
    fi
}

# -----
core_autorestart_cron_check() {
    cron_make_if_missing
    if grep -q "/usr/bin/justclash reload" /etc/crontabs/root; then
        return 0
    else
        return 1
    fi
}

core_autorestart_cron_add() {
    cron_make_if_missing
    local mihomo_cron_autorestart_string

     if [ -z "$mihomo_cron_autorestart_string" ]; then
        log 1 "Cron schedule string is empty! Cron job not added." "❌"
        return 1
    fi

    if core_autorestart_cron_check > /dev/null; then
        log 1 "Core autoupdate cron job already exists." "ℹ️"
        return 0
    fi

    config_get mihomo_cron_autorestart_string settings mihomo_cron_autorestart_string
    echo "$mihomo_cron_autorestart_string /usr/bin/justclash reload" >> /etc/crontabs/root
    if /etc/init.d/cron enabled; then
        /etc/init.d/cron restart
        log 2 "Cron job added and service restarted" "✅"
    else
        log 2 "Cron job added (service not enabled)" "ℹ️"
    fi
    log 2 "Core autoupdate cron job added." "✅"
}

core_autorestart_cron_remove() {
    cron_make_if_missing
    if core_autorestart_cron_check > /dev/null; then
        sed -i '\|/usr/bin/justclash reload|d' /etc/crontabs/root
        if /etc/init.d/cron enabled; then
            /etc/init.d/cron restart
            log 2 "Cron job added and service restarted" "✅"
        else
            log 2 "Cron job added (service not enabled)" "ℹ️"
        fi
        log 2 "Core autoupdate cron job removed." "🗑️"
    else
        log 2 "Core autoupdate cron job not found." "ℹ️"
    fi
}

diag_fake_ip_resolver() {
    local dns_listen_port
    config_get dns_listen_port proxy dns_listen_port

    clog 2 "Testing Fake IP DNS resolution..."
    if ! nslookup google.com 127.0.0.1:"$dns_listen_port" >/dev/null 2>&1; then
        clog 3 "FakeIP IPv4 DNS query failed" "❌"
    else
        clog 2 "FakeIP IPv4 DNS query successful" "✅"
    fi
}

diag_default_resolver() {
    clog 2 "Testing DNS resolution..."
    if ! nslookup google.com >/dev/null 2>&1; then
        clog 3 "IPv4 DNS query failed" "❌"
    else
        clog 2 "IPv4 DNS query successful" "✅"
    fi
}

config_show() {
    uci show justclash
}

config_reset() {
    if [ ! -f "/etc/config/default.justclash" ]; then
        сlog 2 "Default config file is missing. Can't use restore functionality"
        return 1;
    fi

    сlog 2 "Restoring justclash settings..."

    rm -f /etc/config/justclash.bak

    if ! mv /etc/config/justclash /etc/config/justclash.bak; then
        сlog 1 "Failed to backup config file"
        return 1
    fi

    if ! cp "$DEFAULT_CONFIG_PATH" /etc/config/justclash; then
        сlog 1 "Failed to restore default config"
        return 1
    fi

    сlog 2 "Default settings will be applied at next justclash restart..."
}

help() {
    cat << EOF
Usage: justclash <command> [args]

Service Management:
  start|run               Start the JustClash service.
  stop                    Stop the JustClash service.
  reload|restart          Restart the service.
  config_show             Show configuration in console
  config_reset            Reset configuration

Mihomo management Commands:
  core_update                     Check current version and update Mihomo if a newer version is available
  core_remove                     Remove the currently installed Mihomo binary

  core_update_cron_check          Check if a scheduled Mihomo core auto-update task exists
  core_update_cron_add            Add a scheduled task to periodically check and update Mihomo core
  core_update_cron_remove         Remove the scheduled Mihomo core auto-update task

  core_autorestart_cron_check     Check if a scheduled Mihomo auto-restart task exists
  core_autorestart_cron_add       Add a scheduled task to automatically restart Mihomo periodically
  core_autorestart_cron_remove    Remove the scheduled Mihomo auto-restart task

Information Commands:
  info_device             Show device model.
  info_openwrt            Show OpenWrt version.
  info_core               Show Mihomo core version.
  info_package            Show JustClash package version.
  info_luci               Show JustClash LuCI app version.
  info_conns_console      Show Mihomo connections.

Diagnostics:
  diag_nft                Run nftables diagnostic.
  diag_fake_ip_resolver   Run Fake IP DNS diagnostic.
  diag_default_resolver   Run Default DNS diagnostic.

Logs:
  logs|systemlogs [N]     Show last N lines of system logs (default 40).

Help:
  help|?|command          Show this help message.

EOF
}

case "$1" in
    start|run)
        start
        ;;
    stop)
        stop
        ;;
    reload|restart)
        restart
        ;;
    config_show)
        config_show
        ;;
    config_reset)
        config_reset
        ;;
    core_update)
        core_update
        ;;
    core_remove)
        core_remove
        ;;
    core_update_cron_check)
        core_update_cron_check
        ;;
    core_update_cron_add)
        core_update_cron_add
        ;;
    core_update_cron_remove)
        core_update_cron_remove
        ;;
    core_autorestart_cron_check)
        core_autorestart_cron_check
        ;;
    core_autorestart_cron_add)
        core_autorestart_cron_add
        ;;
    core_autorestart_cron_remove)
        core_autorestart_cron_remove
        ;;
    logs|systemlogs)
        case "$2" in
            *[!0-9]* | '')
                systemlogs
                ;;
            *)
                systemlogs "$2"
                ;;
        esac
        ;;
    info_device)
        info_device
        ;;
    info_openwrt)
        info_openwrt
        ;;
    info_core|info_mihomo)
        info_mihomo
        ;;
    info_package)
        info_package
        ;;
    info_luci)
        info_luci
        ;;
    info_conns_console)
        info_conns_console
        ;;
    diag_nft)
        diag_nft
        ;;
    diag_fake_ip_resolver|diag_fake_ip)
        diag_fake_ip_resolver
        ;;
    diag_default_resolver|diag_dns)
        diag_default_resolver
        ;;
    help|?|command)
        help
        ;;
    *)
        clog 2 "Unknown command: $1"
        clog 2 "Type 'justclash help' for a list of available commands."
        exit 1
        ;;
esac