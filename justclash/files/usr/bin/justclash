#!/bin/ash
# Ash isn't supported properly in spellcheck static analyzer
# Using debian based version (kind of similar)
# shellcheck shell=dash

# --------------------------------------------
# Main justclash service part
# Directly using uci config calls every load
# Avoid adding simple commands for perfomance
# --------------------------------------------

# shellcheck disable=SC1091
[ -r /lib/functions.sh ] && . /lib/functions.sh
# shellcheck disable=SC1091
[ -r /lib/config/uci.sh ] && . /lib/config/uci.sh

# Variable for standalone or procd start
PROCD_MODE=0

# setup procd variable: $JUSTCLASH_ENV passed from init.d start
[ "$JUSTCLASH_ENV" = "procd" ] && PROCD_MODE=1 || PROCD_MODE=0

config_load justclash

CORE_RELEASE_URL_PARTIAL="https://github.com/metacubex/mihomo/releases/latest/download"
CORE_RELEASE_URL_PARTIAL_NO_TAG="https://github.com/metacubex/mihomo/releases/download"
CORE_ALPHA_RELEASE_URL_PARTIAL="https://github.com/metacubex/mihomo/releases/download/Prerelease-Alpha"
NO_DATA_STRING="N/A"


CORE_BIN_NAME="mihomo"
# Path to Mihomo core
CORE_PATH="/usr/bin/${CORE_BIN_NAME}"
CORE_PATH_INFOBIN="/usr/bin/justclash_info"
INITD_PATH="/etc/init.d/justclash"
# workdir path (in RAM)
CORE_WORKDIR_PATH="/tmp/justclash/"
OUTPUT_YAML_CONFIG_PATH="${CORE_WORKDIR_PATH}config.yaml"
DEFAULT_CONFIG_PATH="/var/default.justclash.config"
CORE_RESTART_MAX_RETRIES=3

DIAG_RESOLVE_URL_YANDEX="ya.ru"
DIAG_IP_CHECK_PING_YANDEX="77.88.8.8"
DIAG_IP_CHECK_PING_GOOGLE="8.8.8.8"

NFT_TABLE_NAME="justclash_tproxy"
NFT_FWMARK_FINAL=1
NFT_FWMARK_PROXY=255

# List of NTP server IP addresses:
# 194.190.168.1   ‚Äî ntp1.stratum2.ru (Russian NTP server)
# 195.208.185.17  ‚Äî ntp2.stratum2.ru (Russian NTP server)
# 193.232.128.6   ‚Äî ntp3.stratum2.ru (Russian NTP server)
# 216.239.35.0    ‚Äî time.google.com (Google NTP)
NTP_IPS="194.190.168.1 195.208.185.17 193.232.128.6 216.239.35.0"
# String for nft tables
# Allow traffic on:
# LAN interfaces (lan*)
# bridge interface (br-lan)
#ALLOWED_INTERFACES='{ lan*, br-lan }'
# List of conflicting packages:
# podkop (custom proxy)
# and https-dns-proxy (DNS over HTTPS proxy)
CONFLICTED_PACKAGES="sing-box mihomo clash luci-app-ssclash podkop https-dns-proxy"
CONFLICTED_PATTERNS_DHCP_CONFIG="doh_backup_noresolv doh_backup_server doh_server"
CONFLICTED_PATTERNS_FILEPATH="/etc/config/dhcp"
RESOLVCONF_FILEPATH="/etc/resolv.conf"
ZAPRETINITD_FILEPATH="/etc/init.d/zapret"

ucibool_to_yesno() {
    case "$1" in
        1) echo "Yes" ;;
        0) echo "No" ;;
        *) echo "$1" ;;
    esac
}

panic() {
    local message="$1"
    syslog 0 "$message"
    clog 0 "$message"
    stop
    exit 1
}

get_log_level_name() {
    case "$1" in
        0) echo "ERROR" ;;
        1) echo "WARN" ;;
        2) echo "INFO" ;;
        3) echo "DEBUG" ;;
        *) echo "UNKN" ;;
    esac
}

get_log_level_syslog() {
    case "$1" in
        0) echo "user.err" ;;
        1) echo "user.warning" ;;
        2) echo "user.info" ;;
        3) echo "user.debug" ;;
        *) echo "user.debug" ;;
    esac
}

syslog() {
    local level="$1"
    local message="$2"
    local level_syslog=""
    level_syslog=$(get_log_level_syslog "$level")

    logger -p "$level_syslog" -t "justclash" "$message"
}

clog() {
    local level="$1"
    local message="$2"
    local timestamp=""
    local level_str=""

    [ "$PROCD_MODE" -eq 1 ] && return

    timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    level_str=$(get_log_level_name "$level")

    printf "[%s] [%s] %s\n" "$timestamp" "$level_str" "$message"
}

log() {
    local level="$1"
    local message="$2"
    local emoji="${3:-}"

    syslog "$level" "$message"

    [ "$PROCD_MODE" -eq 1 ] && return

    if [ -n "$emoji" ]; then
        clog "$level" "$emoji ${message}"
    else
        clog "$level" "$message"
    fi
}

is_package_installed() {
    local found_pkgs=""
    local pkgcommand=""

    if command -v apk >/dev/null 2>&1; then
        pkgcommand="apk info"
    else
        pkgcommand="opkg list-installed"
    fi

    for pkg in "$@"; do
        if $pkgcommand | grep -qw "$pkg"; then
            found_pkgs="${found_pkgs:+$found_pkgs }$pkg"
        fi
    done

    if [ -n "$found_pkgs" ]; then
        echo "$found_pkgs"
        return 0
    else
        return 1
    fi
}

is_pattern_in_file() {
    if [ -z "$1" ]; then
        log 1 "Usage: is_pattern_in_file <string>"
        return 1
    fi

    local file="$1"

    if [ ! -r "$file" ]; then
        return 1
    fi
    local found_patterns=""
    for pattern in "$@"; do
        if grep -qE "$pattern" "$file"; then
            found_patterns="${found_patterns:+$found_patterns }$pattern"
        fi
    done
    if [ -n "$found_patterns" ]; then
        echo "$found_patterns"
        return 0
    else
        return 1
    fi
}

ntp_force_sync() {
    local forcefully_update_ntp_at_load
    config_get_bool forcefully_update_ntp_at_load settings forcefully_update_ntp_at_load
    if [ -z "$NTP_IPS" ]; then
        log 0 "No NTP servers configured" "‚ö†Ô∏è"
        return 1
    fi

    if ! command -v /usr/sbin/ntpd >/dev/null; then
        log 0 "ntpd not found, time synchronization skipped" "‚ö†Ô∏è"
        return 1
    fi

    if [ "$forcefully_update_ntp_at_load" -eq 1 ]; then
        NTP_ARGS=""
        for ip in $NTP_IPS; do
            NTP_ARGS="$NTP_ARGS -p $ip"
        done
        # shellcheck disable=SC2086
        /usr/sbin/ntpd -q $NTP_ARGS
    fi

    sleep 2
}


compat_fixes() {
    if ! command -v lsmod >/dev/null 2>&1; then
        log 1 "lsmod is missing. Can't check for kernel modules" "‚ö†Ô∏è"
    else
        if lsmod | grep -q br_netfilter && [ "$(sysctl -n net.bridge.bridge-nf-call-iptables 2>/dev/null)" = "1" ]; then
            log 1 "br_netfilter is enabled. FriendlyWRT? Fixing module params..." "‚ö†Ô∏è"
            sysctl -w net.bridge.bridge-nf-call-iptables=0
            sysctl -w net.bridge.bridge-nf-call-ip6tables=0
            log 1 "Set net.bridge.bridge-nf-call-iptables=0" "‚ö†Ô∏è"
            log 1 "Set net.bridge.bridge-nf-call-ip6tables=0" "‚ö†Ô∏è"
        else
            log 2 "No compatibility fixes required."
        fi
    fi
}

core_validate_yaml() {
    local test_output app_exit_code grep_test_exit_code grep_error_exit_code
    test_output="$("$CORE_PATH" -t -f "$OUTPUT_YAML_CONFIG_PATH" 2>&1)"
    app_exit_code=$?
    echo "$test_output" | grep -qi "test failed"
    grep_test_exit_code=$?
    echo "$test_output" | grep -qi "error"
    grep_error_exit_code=$?
    if [ "$grep_test_exit_code" -eq 0 ] || [ "$app_exit_code" -ne 0 ] || [ "$grep_error_exit_code" -eq 0 ]; then
        log 0 "Yaml configuration incorrect!" "‚ùå"
        log 0 "$test_output" "‚ùå"
        log 0 "Mihomo config validation is failed." "‚ùå"
        return 1
    fi
    return 0
}

start() {
    log 2 "Initializing Justclash service..." "‚è≥"

    if [ ! -f "$CORE_PATH" ]; then
        log 0 "Mihomo core is not installed." "‚ùå"
        return 1
    fi

    log 2 "Checking for conflicts" "üêû"
    check_for_conflicts

    log 2 "Checking for non critical conflicts" "üêû"
    check_for_conflicts_warn

    log 2 "Fixing known compatibility problems" "üîë"
    compat_fixes

    log 2 "Synchronizing system time" "üïí"
    ntp_force_sync

    log 2 "Preparing Mihomo working directory" "üì¶"
    core_prepare_workdir

    log 2 "Generating yaml configuration..." "üì¶"
    core_generate_yaml

    log 2 "Validating yaml configuration..." "üì¶"
    core_validate_yaml
    if [ $? = 1 ]; then
        return 1
    fi

    log 2 "Configuring TPROXY routing and creating NFTables table" "üîë"
    nft_table_add

    log 2 "Modifying dnsmasq configuration" "üîë"
    dnsmasq_add

    log 2 "Starting Mihomo core" "üê±"
    start_core
}

stop() {
    log 2 "Closing Justclash service..." "‚è≥"
    log 2 "Removing TPROXY routing and NFTables table" "üîë"
    nft_table_remove

    log 2 "Restoring default dnsmasq configuration" "üîë"
    dnsmasq_remove

    log 2 "Stopping core process" "üê±"
    stop_core
}

restart() {
    log 2 "Performing complete restart" "üîÑ"
    stop
    sleep 1
    start
}

# WARNING: TRY TO NOT USE FUNC MANUALLY - MUST CLEAR ROUTES AND DNSMASQ
start_core() {
    local attempt=0
    log 2 "Start: configured retries: $CORE_RESTART_MAX_RETRIES" "üê±"

    if [ "$PROCD_MODE" -eq 1 ]; then
        local attempt=0

        while [ "$attempt" -lt "$CORE_RESTART_MAX_RETRIES" ]; do
            "$CORE_PATH" -d "$CORE_WORKDIR_PATH" 2>&1 | sed 's/time="[^"]*"/mihomo/' | logger -t justclash
            exit_code=$?
            log 1 "Restart: mihomo exited with code $exit_code" "‚ùå"

            if [ "$exit_code" -eq 0 ]; then
                break
            fi

            attempt=$((attempt + 1))
            log 0 "Restart:  mihomo crashed, attempt $attempt of $CORE_RESTART_MAX_RETRIES" "‚ùå"

            if [ "$attempt" -ge "$CORE_RESTART_MAX_RETRIES" ]; then
                log 0 "Restart:  Failed to restart mihomo after $CORE_RESTART_MAX_RETRIES attempts, exiting" "‚ùå"
                exit "$exit_code"
            fi

            sleep 5
        done
    else
        "$CORE_PATH" -d "$CORE_WORKDIR_PATH" 2>&1
        exit_code=$?
        log 1 "Manual start: mihomo exited with code $exit_code" "‚ùå"
        if [ "$exit_code" -ne 0 ]; then
            log 0 "Manual start: mihomo crashed, exiting" "‚ùå"
            exit "$exit_code"
        fi
    fi
}

# WARNING: TRY TO NOT USE FUNC MANUALLY - MUST CLEAR ROUTES AND DNSMASQ
stop_core() {
    if pgrep -f "$(basename "$0")" >/dev/null; then
        pids=$(pgrep -f "$(basename "$CORE_PATH")")
        if [ -n "$pids" ]; then
            # DO NOT APPLY "" - STRING MUST BE SPLITTED AUTOMATICALLY
            # shellcheck disable=SC2086
            kill $pids 2>/dev/null
        fi
        log 2 "Core process stopped" "üê±"
    else
       log 2 "JustClash isn't running" "üê±"
    fi
}

cleanup_fwmark() {
    while ip rule show | grep -q "fwmark 0x1 lookup 100"; do
        ip rule del fwmark 1 table 100 2>/dev/null || true
    done
}

nft_table_add_old() {
    local tproxy_port proxy_fwmark_hex fake_ip_range
    config_get tproxy_port proxy tproxy_port
    config_get fake_ip_range proxy fake_ip_range

    [ -z "$tproxy_port" ] && panic "tproxy_port not set"
    [ -z "$fake_ip_range" ] && panic "fake_ip_range not set"

    proxy_fwmark_hex=$(printf "0x%02X" "$NFT_FWMARK_PROXY")

    if nft list table ip "$NFT_TABLE_NAME" 2>/dev/null; then
        nft delete table ip "$NFT_TABLE_NAME"
    fi

    # –°–æ–∑–¥–∞—ë–º —Ç–∞–±–ª–∏—Ü—É, —Ü–µ–ø–æ—á–∫–∏ –∏ –Ω–∞–±–æ—Ä—ã
    nft add table ip "$NFT_TABLE_NAME"
    nft add chain ip "$NFT_TABLE_NAME" prerouting '{ type filter hook prerouting priority mangle; policy accept; }'
    #nft add chain ip "$NFT_TABLE_NAME" output '{ type route hook output priority mangle; policy accept; }'
    nft add set ip "$NFT_TABLE_NAME" fake_ips '{ type ipv4_addr; flags interval; }'
    nft add element ip "$NFT_TABLE_NAME" fake_ips { "$fake_ip_range" }

    local exclude_addrs="
        0.0.0.0/8
        10.0.0.0/8
        100.64.0.0/10
        127.0.0.0/8
        169.254.0.0/16
        172.16.0.0/12
        192.0.0.0/24
        192.0.2.0/24
        192.88.99.0/24
        192.168.0.0/16
        198.51.100.0/24
        203.0.113.0/24
        224.0.0.0/4
        240.0.0.0/4
    "

    nft add rule ip "$NFT_TABLE_NAME" prerouting mark "$proxy_fwmark_hex" return

    nft add rule ip "$NFT_TABLE_NAME" prerouting ip daddr @fake_ips ip protocol tcp meta mark set "$NFT_FWMARK_FINAL"
    nft add rule ip "$NFT_TABLE_NAME" prerouting ip daddr @fake_ips ip protocol udp meta mark set "$NFT_FWMARK_FINAL"

    for intf in wan ppp tun tap wg lxc veth vnet docker dummy; do
        nft add rule ip "$NFT_TABLE_NAME" prerouting iifname "${intf}*" return
    done

    for addr in $exclude_addrs; do
        nft add rule ip "$NFT_TABLE_NAME" prerouting ip daddr "$addr" return
    done

    nft add rule ip "$NFT_TABLE_NAME" prerouting ip protocol tcp meta mark set "$NFT_FWMARK_FINAL"
    nft add rule ip "$NFT_TABLE_NAME" prerouting ip protocol udp meta mark set "$NFT_FWMARK_FINAL"

    nft add rule ip "$NFT_TABLE_NAME" prerouting meta mark "$NFT_FWMARK_FINAL" ip protocol tcp tproxy to 127.0.0.1:"$tproxy_port"
    nft add rule ip "$NFT_TABLE_NAME" prerouting meta mark "$NFT_FWMARK_FINAL" ip protocol udp tproxy to 127.0.0.1:"$tproxy_port"

    #nft add rule ip "$NFT_TABLE_NAME" output mark "$proxy_fwmark_hex" return
    #nft add rule ip "$NFT_TABLE_NAME" output meta skuid 0 return

    #nft add rule ip "$NFT_TABLE_NAME" output ip daddr @fake_ips ip protocol tcp meta mark set "$NFT_FWMARK_FINAL"
    #nft add rule ip "$NFT_TABLE_NAME" output ip daddr @fake_ips ip protocol udp meta mark set "$NFT_FWMARK_FINAL"

    #for intf in wan ppp tun tap wg lxc veth vnet docker dummy; do
    #    nft add rule ip "$NFT_TABLE_NAME" output iifname "${intf}*" return
    #done

    #for addr in $exclude_addrs; do
    #    nft add rule ip "$NFT_TABLE_NAME" output ip daddr "$addr" return
    #done

    #nft add rule ip "$NFT_TABLE_NAME" output meta mark 0 ip protocol tcp meta mark set "$NFT_FWMARK_FINAL"
    #nft add rule ip "$NFT_TABLE_NAME" output meta mark 0 ip protocol udp meta mark set "$NFT_FWMARK_FINAL"

    cleanup_fwmark
    if ! ip rule list | grep -q "fwmark 0x1 lookup 100"; then
        ip rule add fwmark "$NFT_FWMARK_FINAL" table 100
    fi

    if ! ip route show table 100 | grep -q "local 0.0.0.0/0 dev lo"; then
        ip route add local 0.0.0.0/0 dev lo table 100
    fi

    log 1 "TPROXY: port=$tproxy_port, fwmark=1 table=100"
}

nft_table_add() {
    local update_nft_tables_at_load
    local tproxy_port proxy_fwmark_hex fake_ip_range input_interfaces_to_tproxy_redirect
    local block_quic_with_nft block_dot_with_nft dot_quic_with_nft
    config_get update_nft_tables_at_load settings update_nft_tables_at_load
    config_get tproxy_port proxy tproxy_port
    config_get fake_ip_range proxy fake_ip_range
    config_get input_interfaces_to_tproxy_redirect settings input_interfaces_to_tproxy_redirect "br-lan"
    config_get block_quic_with_nft settings block_quic_with_nft
    config_get block_dot_with_nft settings block_dot_with_nft
    config_get dot_quic_with_nft settings dot_quic_with_nft

    if [ "$update_nft_tables_at_load" = "0" ]; then
        return 0
    fi

    [ -z "$tproxy_port" ] && panic "tproxy_port not set"
    [ -z "$fake_ip_range" ] && panic "fake_ip_range not set"

    proxy_fwmark_hex=$(printf "0x%02X" "$NFT_FWMARK_PROXY")

    if nft list table ip "$NFT_TABLE_NAME" 2>/dev/null; then
        nft delete table ip "$NFT_TABLE_NAME"
    fi

    # –°–æ–∑–¥–∞—ë–º —Ç–∞–±–ª–∏—Ü—É, —Ü–µ–ø–æ—á–∫—É –∏ –Ω–∞–±–æ—Ä –∞–¥—Ä–µ—Å–æ–≤
    nft add table ip "$NFT_TABLE_NAME"
    nft add chain ip "$NFT_TABLE_NAME" prerouting '{ type filter hook prerouting priority mangle; policy accept; }'
    #nft add chain ip "$NFT_TABLE_NAME" output '{ type route hook output priority mangle; policy accept; }'

    nft add set ip "$NFT_TABLE_NAME" fake_ips '{ type ipv4_addr; flags interval; }'
    nft add element ip "$NFT_TABLE_NAME" fake_ips { "$fake_ip_range" }

    nft add set ip "$NFT_TABLE_NAME" private_ips '{ type ipv4_addr; flags interval; }'
    nft add element ip "$NFT_TABLE_NAME" private_ips { \
        0.0.0.0/8, 10.0.0.0/8, 100.64.0.0/10, 127.0.0.0/8, \
        169.254.0.0/16, 172.16.0.0/12, 192.0.0.0/24, 192.0.2.0/24, \
        192.88.99.0/24, 192.168.0.0/16, 198.51.100.0/24, 203.0.113.0/24, \
        224.0.0.0/4, 240.0.0.0/4 }

    #nft add set ip "$NFT_TABLE_NAME" private_ips_output '{ type ipv4_addr; flags interval; }'
    #nft add element ip "$NFT_TABLE_NAME" private_ips_output { \
    #    0.0.0.0/8, 10.0.0.0/8, 100.64.0.0/10, \
    #    169.254.0.0/16, 172.16.0.0/12, 192.0.0.0/24, 192.0.2.0/24, \
    #    192.88.99.0/24, 192.168.0.0/16, 198.51.100.0/24, 203.0.113.0/24, \
    #    224.0.0.0/4, 240.0.0.0/4 }

    nft add set ip "$NFT_TABLE_NAME" inbound_interfaces '{ type ifname; }'
    # shellcheck disable=SC2046
    # shellcheck disable=SC2086
    nft add element ip "$NFT_TABLE_NAME" inbound_interfaces { $(echo $input_interfaces_to_tproxy_redirect | sed 's/ /", "/g; s/^/"/; s/$/"/') }

    if [ "$block_quic_with_nft" = "1" ]; then
        nft add rule ip "$NFT_TABLE_NAME" prerouting iifname @inbound_interfaces ip protocol udp udp dport 443 drop
    fi
    if [ "$block_dot_with_nft" = "1" ]; then
        nft add rule ip "$NFT_TABLE_NAME" prerouting iifname @inbound_interfaces ip protocol tcp tcp dport 853 drop
    fi
    if [ "$dot_quic_with_nft" = "1" ]; then
        nft add rule ip "$NFT_TABLE_NAME" prerouting iifname @inbound_interfaces ip protocol udp udp dport 853 drop
    fi

    nft add rule ip "$NFT_TABLE_NAME" prerouting iifname @inbound_interfaces ip daddr @private_ips return

    # –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø–æ fwmark –¥–ª—è br-lan
    nft add rule ip "$NFT_TABLE_NAME" prerouting iifname @inbound_interfaces mark "$proxy_fwmark_hex" return

    # –ú–∞—Ä–∫–∏—Ä—É–µ–º fake IP –¥–ª—è br-lan
    nft add rule ip "$NFT_TABLE_NAME" prerouting iifname @inbound_interfaces ip daddr @fake_ips ip protocol tcp meta mark set "$NFT_FWMARK_FINAL"
    nft add rule ip "$NFT_TABLE_NAME" prerouting iifname @inbound_interfaces ip daddr @fake_ips ip protocol udp meta mark set "$NFT_FWMARK_FINAL"

    # –ú–∞—Ä–∫–∏—Ä—É–µ–º –æ—Å—Ç–∞–ª—å–Ω–æ–π —Ç—Ä–∞—Ñ–∏–∫ —Å br-lan
    nft add rule ip "$NFT_TABLE_NAME" prerouting iifname @inbound_interfaces ip protocol tcp meta mark set "$NFT_FWMARK_FINAL"
    nft add rule ip "$NFT_TABLE_NAME" prerouting iifname @inbound_interfaces ip protocol udp meta mark set "$NFT_FWMARK_FINAL"

    # TPROXY —Ç–æ–ª—å–∫–æ –¥–ª—è —Ç—Ä–∞—Ñ–∏–∫–∞ —Å br-lan –∏ –Ω—É–∂–Ω–æ–π –º–µ—Ç–∫–æ–π
    nft add rule ip "$NFT_TABLE_NAME" prerouting iifname @inbound_interfaces meta mark "$NFT_FWMARK_FINAL" ip protocol tcp tproxy to 127.0.0.1:"$tproxy_port"
    nft add rule ip "$NFT_TABLE_NAME" prerouting iifname @inbound_interfaces meta mark "$NFT_FWMARK_FINAL" ip protocol udp tproxy to 127.0.0.1:"$tproxy_port"

    # --- output ---
    #nft add rule ip "$NFT_TABLE_NAME" output mark "$proxy_fwmark_hex" return
    #nft add rule ip "$NFT_TABLE_NAME" output oifname "lo" return
    #nft add rule ip "$NFT_TABLE_NAME" output ip daddr @private_ips_output return
    #nft add rule ip "$NFT_TABLE_NAME" output ip daddr @fake_ips ip protocol tcp meta mark set "$NFT_FWMARK_FINAL"
    #nft add rule ip "$NFT_TABLE_NAME" output ip daddr @fake_ips ip protocol udp meta mark set "$NFT_FWMARK_FINAL"
    #nft add rule ip "$NFT_TABLE_NAME" output ip protocol tcp meta mark set "$NFT_FWMARK_FINAL"
    #nft add rule ip "$NFT_TABLE_NAME" output ip protocol udp meta mark set "$NFT_FWMARK_FINAL"

    cleanup_fwmark
    if ! ip rule list | grep -q "fwmark 0x1 lookup 100"; then
        ip rule add fwmark "$NFT_FWMARK_FINAL" table 100
    fi

    if ! ip route show table 100 | grep -Eq "local (default|0\.0\.0\.0/0) dev lo"; then
        ip route add local 0.0.0.0/0 dev lo table 100
    fi

    log 1 "TPROXY: port=$tproxy_port, fwmark=$NFT_FWMARK_FINAL fwmark_proxy=$NFT_FWMARK_PROXY table=100"
}

nft_table_remove() {
    cleanup_fwmark
    nft flush table ip "$NFT_TABLE_NAME" 2>/dev/null || true
    nft delete table ip "$NFT_TABLE_NAME" 2>/dev/null || true
    ip route flush table 100 2>/dev/null || true

    log 2 "TPROXY Clash rules and routing were removed" "‚öôÔ∏è"
}

# Thx Podkop, feels so annoyed already by shell scripting
save_dnsmasq_config() {
    local key="$1"
    local backup_key="$2"
    value=$(uci get "$key" 2>/dev/null)

    if [ -z "$value" ]; then
        uci set "$backup_key"="unset"
    else
        uci set "$backup_key"="$value"
    fi
}

dnsmasq_add() {
    local dns_listen_port update_dns_server_at_load
    config_get dns_listen_port proxy dns_listen_port
    config_get_bool update_dns_server_at_load settings update_dns_server_at_load

    if [ "$update_dns_server_at_load" -eq 1 ]; then

        uci -q delete dhcp.@dnsmasq[0].justclash_server
        for server in $(uci get dhcp.@dnsmasq[0].server 2>/dev/null); do
            if [ "$server" = "127.0.0.1#${dns_listen_port}" ]; then
                log 1 "Dnsmasq save config error: server=127.0.0.1 is already configured. Skip editing DHCP"
                return 1
            else
                uci add_list dhcp.@dnsmasq[0].justclash_server="$server"
            fi
        done

        save_dnsmasq_config "dhcp.@dnsmasq[0].noresolv" "dhcp.@dnsmasq[0].justclash_noresolv"
        save_dnsmasq_config "dhcp.@dnsmasq[0].cachesize" "dhcp.@dnsmasq[0].justclash_cachesize"

        uci add_list dhcp.@dnsmasq[0].server="127.0.0.1#$dns_listen_port"
        uci set dhcp.@dnsmasq[0].cachesize="0"
        uci set dhcp.@dnsmasq[0].noresolv="1"

        uci commit dhcp
        log 2 "DNS configuration has been updated with new settings." "üåê"
        /etc/init.d/dnsmasq restart > /dev/null 2>&1
        log 2 "dnsmasq service has been restarted to apply DNS changes." "üîÑ"
    else
        log 2 "DNS configuration remains unchanged; update skipped as per configuration rules." "üõ†Ô∏è"
    fi

}

dnsmasq_remove() {
    local dns_listen_port
    config_get dns_listen_port proxy dns_listen_port
    local update_dns_server_at_load
    config_get_bool update_dns_server_at_load settings update_dns_server_at_load

    local bak_cachesize
    local bak_noresolv
    local server

    if [ "$update_dns_server_at_load" -eq 1 ]; then
        bak_cachesize=$(uci get dhcp.@dnsmasq[0].justclash_cachesize 2>/dev/null)
        if [ -z "$bak_cachesize" ]; then
            log 1 "dnsmasq revert: cachesize is unset"
        else
            uci set dhcp.@dnsmasq[0].cachesize="$bak_cachesize"
        fi

        bak_noresolv=$(uci get dhcp.@dnsmasq[0].justclash_noresolv 2>/dev/null)
        if [ "$bak_noresolv" = "unset" ]; then
            log 1 "dnsmasq revert: noresolv is unset"
            uci -q delete dhcp.@dnsmasq[0].noresolv
        else
            uci set dhcp.@dnsmasq[0].noresolv="$bak_noresolv"
        fi

        server=$(uci get dhcp.@dnsmasq[0].server 2>/dev/null)
        if [ "$server" = "127.0.0.1#${dns_listen_port}" ]; then
            uci -q delete dhcp.@dnsmasq[0].server 2>/dev/null
            for server in $(uci get dhcp.@dnsmasq[0].justclash_server 2>/dev/null); do
                uci add_list dhcp.@dnsmasq[0].server="$server"
            done
            uci delete dhcp.@dnsmasq[0].justclash_server 2>/dev/null
        fi

        uci commit dhcp
        log 2 "DNS configuration has been restored." "üåê"
        /etc/init.d/dnsmasq restart > /dev/null 2>&1
        log 2 "dnsmasq service has been restarted to apply DNS changes." "üîÑ"
    else
        log 2 "DNS configuration remains unchanged; update skipped as per configuration rules." "üõ†Ô∏è"
    fi
 }

check_for_conflicts() {
    local installed_pkgs found_patterns pkg pattern

    # For $CONFLICTED_PACKAGES only. We don't need "" to make shell split string
    # shellcheck disable=SC2086
    installed_pkgs=$(is_package_installed $CONFLICTED_PACKAGES)
    if [ -n "$installed_pkgs" ]; then
        for pkg in $installed_pkgs; do
            log 1 "Conflict detected: package '$pkg' is installed." "‚ö†Ô∏è"
            log 1 "This package may interfere with the current service setup." "‚ö†Ô∏è"
            log 1 "Please consider uninstalling or reconfiguring the package before proceeding." "‚ö†Ô∏è"
        done
        panic "Conflicting packages detected. Operation aborted for safety."
    fi

    # For $CONFLICTED_PATTERNS_DHCP_CONFIG only. We don't need "" to make shell split string
    # shellcheck disable=SC2086
    found_patterns=$(is_pattern_in_file "$CONFLICTED_PATTERNS_FILEPATH" "$CONFLICTED_PATTERNS_DHCP_CONFIG")
    if [ -n "$found_patterns" ]; then
        for pattern in $found_patterns; do
            log 1 "Conflict detected: pattern '$pattern' found in /etc/config/dhcp." "‚ö†Ô∏è"
            log 1 "This pattern may indicate a configuration clash with the current service." "‚ö†Ô∏è"
            log 1 "Please review and edit your DHCP configuration to resolve this issue." "‚ö†Ô∏è"
        done
        panic "Conflicting DHCP configuration patterns detected. Operation aborted for safety."
    fi
}

check_for_conflicts_warn() {
    local external_nameservers
    external_nameservers=$(
        awk '$1 == "nameserver" && $2 != "127.0.0.1" && $2 != "0.0.0.0" { print; found=1 } END { exit !found }' "$RESOLVCONF_FILEPATH"
    )
    local resolvconf_res=$?

    if [ "$resolvconf_res" -eq 0 ]; then
        log 1 "Warning: External DNS servers are listed in /etc/resolv.conf:" "‚ö†Ô∏è"
        log 1 "Found: $external_nameservers" "‚ö†Ô∏è"
        log 1 "This may bypass local DNS rules and cause unexpected query results." "‚ö†Ô∏è"
        log 1 "If you intend to use a local DNS service, these entries should be removed." "‚ö†Ô∏è"
    fi

    if [ -f "$ZAPRETINITD_FILEPATH" ]; then
        log 1 "Warning: Zapret service detected by path $ZAPRETINITD_FILEPATH:" "‚ö†Ô∏è"
        log 1 "This service can cause unexpected results if configured incorrectly." "‚ö†Ô∏è"
    fi
}

info_device() {
    local res
    res=$($CORE_PATH_INFOBIN info_device)
    echo "$res"
}

info_openwrt() {
    local res
    res=$($CORE_PATH_INFOBIN info_openwrt)
    echo "$res"
}

info_mihomo() {
    local res
    res=$($CORE_PATH_INFOBIN info_core)
    echo "$res"
}

info_package() {
    local res
    res=$($CORE_PATH_INFOBIN info_package)
    echo "$res"
}

info_luci() {
    local res
    res=$($CORE_PATH_INFOBIN info_luci)
    echo "$res"
}

info_conns_console() {
    local res
    res=$($CORE_PATH_INFOBIN info_conns_console)
    echo "$res"
}

systemlogs() {
    local res
    local lines=${1:-40}
    res=$($CORE_PATH_INFOBIN systemlogs "$lines")
    echo "$res"
}

generate_json_array_from_named_section() {
    local section_name="$1"
    local list_name="$2"
    local result=""
    local first=1

    # shellcheck disable=SC2317
    _append_value() {
        local val="$1"
        val=$(printf '%s' "$val" | sed 's/"/\\"/g')
        if [ "$first" -eq 1 ]; then
            result="\"$val\""
            first=0
        else
            result="${result}, \"$val\""
        fi
    }

    config_list_foreach "$section_name" "$list_name" _append_value

    if [ -z "$result" ]; then
        echo "[]"
    else
        echo "[$result]"
    fi
}

ucibool_to_yaml_bool () {
    case "$1" in
        1|yes|on|true) echo "true" ;;
        *) echo "false" ;;
    esac
}

core_generate_yaml() {
    local log_level tproxy_port unified_delay
    local tcp_concurrent external_controller_port global_client_fingerprint
    local keep_alive_idle keep_alive_interval profile_store_selected profile_store_fake_ip
    local core_ntp_enabled core_ntp_interval core_ntp_server core_ntp_port  core_ntp_write_system
    local dns_listen_port use_hosts use_system_hosts fake_ip_range

    local default_nameserver direct_nameserver proxy_server_nameserver nameserver ignore_fake_ip_domains ignore_to_sniff_domains

    # Support for manual config files
    # If detected - no settings from config file will be applied
    # DANGEROUS!
    #if [ -f OVERRIDE_YAML_CONFIG_PATH ]; then
    #    log 1 "A dangerous state detected: override configuration file found at \"$OVERRIDE_YAML_CONFIG_PATH\". \
    #    This file will be used as the active configuration, but correct operation is not guaranteed. \
    #    This may lead to unexpected behavior, service instability, or security vulnerabilities. \
    #    Please verify the contents of the override configuration file and ensure it is intended for use before proceeding. \
    #    If this was not expected, investigate the origin of the override file and consider restoring the default configuration."
    #    cp "$OVERRIDE_YAML_CONFIG_PATH" "$OUTPUT_YAML_CONFIG_PATH"
    #    return 0
    #fi

    config_get log_level proxy log_level
    config_get tproxy_port proxy tproxy_port
    config_get_bool unified_delay proxy unified_delay
    unified_delay=$(ucibool_to_yaml_bool "$unified_delay")
    config_get_bool tcp_concurrent proxy tcp_concurrent
    tcp_concurrent=$(ucibool_to_yaml_bool "$tcp_concurrent")
    config_get external_controller_port proxy external_controller_port
    config_get global_client_fingerprint proxy global_client_fingerprint
    config_get keep_alive_idle proxy keep_alive_idle
    config_get keep_alive_interval proxy keep_alive_interval
    config_get_bool profile_store_selected proxy profile_store_selected
    profile_store_selected=$(ucibool_to_yaml_bool "$profile_store_selected")
    config_get_bool profile_store_fake_ip proxy profile_store_fake_ip
    profile_store_fake_ip=$(ucibool_to_yaml_bool "$profile_store_fake_ip")
    config_get_bool core_ntp_enabled proxy core_ntp_enabled
    core_ntp_enabled=$(ucibool_to_yaml_bool "$core_ntp_enabled")
    config_get core_ntp_server proxy core_ntp_server
    config_get core_ntp_port proxy core_ntp_port
    config_get core_ntp_interval proxy core_ntp_interval
    config_get_bool core_ntp_write_system proxy core_ntp_write_system
    core_ntp_write_system=$(ucibool_to_yaml_bool "$core_ntp_write_system")
    config_get dns_listen_port proxy dns_listen_port
    config_get_bool use_hosts proxy use_hosts
    use_hosts=$(ucibool_to_yaml_bool "$use_hosts")
    config_get_bool use_system_hosts proxy use_system_hosts
    use_system_hosts=$(ucibool_to_yaml_bool "$use_system_hosts")
    config_get fake_ip_range proxy fake_ip_range
    default_nameserver=$(generate_json_array_from_named_section proxy default_nameserver)
    direct_nameserver=$(generate_json_array_from_named_section proxy direct_nameserver)
    proxy_server_nameserver=$(generate_json_array_from_named_section proxy proxy_server_nameserver)
    nameserver=$(generate_json_array_from_named_section proxy nameserver)
    ignore_fake_ip_domains=$(generate_json_array_from_named_section proxy ignore_fake_ip_domains)
    ignore_to_sniff_domains=$(generate_json_array_from_named_section proxy ignore_to_sniff_domains)

    cat <<EOF > "$OUTPUT_YAML_CONFIG_PATH"
mode: rule
ipv6: false
log-level: $log_level
tproxy-port: $tproxy_port
unified-delay: $unified_delay
tcp-concurrent: $tcp_concurrent
external-controller: 0.0.0.0:$external_controller_port
routing-mark: $NFT_FWMARK_PROXY
global-client-fingerprint: $global_client_fingerprint
global-ua: Mozilla/5.0 (X11; Linux x86_64; rv:125.0) Gecko/20100101 Firefox/125.0
find-process-mode: off
geodata-mode: false

keep-alive-idle: $keep_alive_idle
keep-alive-interval: $keep_alive_interval

profile:
  store-selected: $profile_store_selected
  store-fake-ip: $profile_store_fake_ip
  tracing: false

ntp:
  enable: $core_ntp_enabled
  write-to-system: $core_ntp_write_system
  server: $core_ntp_server
  port: $core_ntp_port
  interval: $core_ntp_interval

dns:
  enable: true
  listen: 127.0.0.1:$dns_listen_port
  ipv6: false
  use-hosts: $use_hosts
  use-system-hosts: $use_system_hosts
  enhanced-mode: fake-ip
  fake-ip-range: $fake_ip_range
  default-nameserver: $default_nameserver
  nameserver: $nameserver
  proxy-server-nameserver: $proxy_server_nameserver
  direct-nameserver: $direct_nameserver
  respect-rules: true
  fake-ip-filter-mode: blacklist
  fake-ip-filter: $ignore_fake_ip_domains

sniffer:
  enable: true
  parse-pure-ip: true
  sniff:
    HTTP:
      ports: [80, 8080-8880]
      override-destination: true
    TLS:
      ports: [443, 8443]
    QUIC:
      ports: [443, 8443]
  skip-domain: $ignore_to_sniff_domains

EOF

    local rules proxies proxy_groups rule_providers
    config_get rules compiled rules
    config_get proxies compiled proxies
    config_get proxy_groups compiled proxy_groups
    config_get rule_providers compiled rule_providers

    cat <<EOF >> "$OUTPUT_YAML_CONFIG_PATH"
proxies: $proxies
proxy-groups: $proxy_groups
rule-providers: $rule_providers
rules: $rules

EOF

    return 0;
}

core_prepare_workdir() {
    log 2 "Preparing workdir $CORE_WORKDIR_PATH" "üìÅ"

    if [ -d "$CORE_WORKDIR_PATH" ]; then
        [ -f "$OUTPUT_YAML_CONFIG_PATH" ] && rm -f "$OUTPUT_YAML_CONFIG_PATH"
    else
        mkdir -p "$CORE_WORKDIR_PATH"
    fi
}

# TODO: Remove impossible archs
detect_arch() {
    local arch_raw
    arch_raw=$(uname -m)

    case "$arch_raw" in
        x86_64) echo "amd64";;
        aarch64) echo "arm64" ;;
        armv5*) echo "armv5" ;;
        armv6*) echo "armv6" ;;
        armv7*) echo "armv7" ;;
        mips*) echo "mips" ;;
        i[3-6]86) echo "i386" ;;
        *) echo "amd64" ;;
    esac
}

get_latest_version() {
    if [ -z "$1" ] || [ -z "$2" ]; then
        log 1 "Usage: get_latest_version <check_url> <link type[effective/noneffective]>"
        return 1
    fi
    local check_url="$1"
    local link_type="$2"
    local latest_url latest_ver
    if [ "$link_type" = "effective" ]; then
        latest_url="${check_url}"
    else
        latest_url=$(curl --progress-bar -L -o /dev/null -w '%{url_effective}' "$check_url") || {
            log 0 "Failed to get effective URL for download" "‚ùå"
            return 1
        }
    fi
    latest_ver=$(curl --progress-bar -L "$latest_url/version.txt" | tr -d '\r\n') || {
        log 0 "Failed to get latest version" "‚ùå"
        return 1
    }
    echo "$latest_ver"
}

core_download() {
    local arch version file_name base_url param_version download_url
    param_version="$2"
    download_url="$1"

    if [ -z "$1" ] || [ -z "$2" ]; then
        log 1 "Usage: core_download <download_url> <version>"
        return 1
    fi

    arch=$(detect_arch)
    mkdir -p "$CORE_WORKDIR_PATH"

    file_name="mihomo-linux-${arch}-${param_version}.gz"
    base_url="${download_url}/${file_name}"

    log 2 "Downloading mihomo binary" "üì•"
    curl --progress-bar -L -o "${CORE_WORKDIR_PATH}/mihomo.gz" "$base_url" || {
        log 0 "Failed to download file." "‚ùå"
        return 1
    }

    log 2 "Extracting to $CORE_PATH" "‚¨áÔ∏è"
    gunzip -c "${CORE_WORKDIR_PATH}/mihomo.gz" > "$CORE_PATH" || {
        log 0 "Failed to extract file." "‚ùå"
        return 1
    }

    log 2 "Mihomo installed at $CORE_PATH" "üöÄ"

    if ! chmod +x "$CORE_PATH"; then
        log 0 "Failed to set executable permissions: $CORE_PATH" "‚ùå"
    fi

    log 2 "Cleaning up temporary files" "üßπ"
    if ! rm -f "${CORE_WORKDIR_PATH}/mihomo.gz"; then
        log 0 "Failed to clean up temporary file: ${CORE_WORKDIR_PATH}/mihomo.gz" "‚ùå"
    fi
}

core_remove() {
    if [ ! -x "$CORE_PATH" ]; then
        log 0 "Mihomo is not installed." "‚ùå"
        return 1
    else
        if rm -f "$CORE_PATH"; then
            log 2 "Mihomo is removed." "‚úÖ"
            return 0
        else
            log 0 "Failed to remove Mihomo binary: $CORE_PATH" "‚ùå"
            return 1
        fi
    fi
}

core_update() {
    local cur_ver latest_ver tmp mihomo_update_channel mihomo_cron_update_telegram_notify
    local check_url check_url_type download_url
    config_get mihomo_update_channel settings mihomo_update_channel
    config_get_bool mihomo_cron_update_telegram_notify settings mihomo_cron_update_telegram_notify

    log 2 "Checking for Mihomo updates..." "üîÑ"

    cur_ver=$(info_mihomo)
    if [ -z "$cur_ver" ]; then
        log 0 "Update process can't be finished." "‚ùå"
        return 1
    fi

    if [ "$mihomo_update_channel" = "alpha" ]; then
        check_url="$CORE_ALPHA_RELEASE_URL_PARTIAL"
        check_url_type="effective"
    else
        check_url="$CORE_RELEASE_URL_PARTIAL"
        check_url_type="noneffective"

    fi

    tmp=$(get_latest_version "$check_url" "$check_url_type")

    if [ "$?" -eq 1 ]; then
        log 0 "Update process can't be finished." "‚ùå"
        return 1
    fi

    #TODO: Fix incorrect output handle (github isnt returning empty body)
    latest_ver=$(echo "$tmp" | sed -n 1p)

    if [ "$mihomo_update_channel" = "alpha" ]; then
        download_url=$CORE_ALPHA_RELEASE_URL_PARTIAL
    else
        download_url=$CORE_RELEASE_URL_PARTIAL_NO_TAG/$latest_ver
    fi

    if [ -z "$latest_ver" ]; then
       log 0 "Error happened when trying to receive latest version data."
       log 0 "It may be due to a GitHub API rate limit or the release may not exist. Please check manually."
       log 0 "Failed to download core"
       return 1
    fi

    if [ "$cur_ver" = "$NO_DATA_STRING" ] || [ -z "$cur_ver" ]; then
        log 1 "Mihomo is not installed. Installing version $latest_ver." "‚ö†Ô∏è"
        core_download "$download_url" "$latest_ver"
        if [ $? -eq 1 ]; then
            log 0 "Update process can't be finished." "‚ùå"
            if [ "$mihomo_cron_update_telegram_notify" -eq 1 ]; then
                send_telegram "Mihomo core binary was missing. Install try for version $latest_ver failed."
            fi
            return 1
        fi
        if [ "$mihomo_cron_update_telegram_notify" -eq 1 ]; then
            send_telegram "Mihomo core binary was missing. Installed $latest_ver"
        fi
        return 0
    fi

    log 2 "Current Mihomo version: $cur_ver"
    log 2 "Latest Mihomo version: $latest_ver"

    if [ "$cur_ver" != "$latest_ver" ]; then
        log 2 "Removing current mihomo binary..." "‚ö†Ô∏è"
        core_remove
        if [ $? -eq 1 ]; then
            log 0 "Update process can't be finished." "‚ùå"
            return 1
        fi
        log 2 "Updating Mihomo to version $latest_ver" "‚¨ÜÔ∏è"
        core_download "$download_url" "$latest_ver"
        if [ $? -eq 1 ]; then
            log 0 "Update process can't be finished." "‚ùå"
            if [ "$mihomo_cron_update_telegram_notify" -eq 1 ]; then
                send_telegram "Mihomo core binary was updated. Install try for version: $cur_ver -> $latest_ver failed."
            fi
            return 1
        fi
        if [ "$mihomo_cron_update_telegram_notify" -eq 1 ]; then
            send_telegram "Mihomo core binary was updated. Version: $cur_ver -> $latest_ver"
        fi
    else
        if [ "$mihomo_cron_update_telegram_notify" -eq 1 ]; then
            send_telegram "Mihomo core binary is already up-to-date."
        fi
        log 2 "Mihomo is already up-to-date." "‚úÖ"
    fi

    return 0
}

send_telegram() {
    if [ -z "$1" ]; then
        log 1 "Usage: send_telegram <message>"
        return 1
    fi

    local message="$1"
    local token chat_id

    config_get token settings telegram_bot_token
    config_get chat_id settings telegram_chat_id

    if [ -z "$token" ] || [ -z "$chat_id" ]; then
        log 1 "Telegram: bot token or chat ID is not configured" "‚ö†Ô∏è"
        return 1
    fi

    response=$(curl -s -w "\n%{http_code}" -X POST "https://api.telegram.org/bot${token}/sendMessage" \
        -d chat_id="$chat_id" \
        -d text="$message" \
        -d parse_mode="HTML" \
        -d disable_notification=true)

    local curl_exit=$?
    http_code=$(echo "$response" | tail -n1)

    if [ "$curl_exit" -ne 0 ]; then
        log 0 "Telegram: network error, curl exited with code $curl_exit" "‚ùå"
        return 1
    fi

    if [ "$http_code" != "200" ]; then
        log 0 "Telegram: failed to send message (HTTP $http_code)" "‚ùå"
        return 1
    fi

    return 0
}

cron_make_if_missing() {
    if [ ! -f "/etc/crontabs/root" ]; then
        touch "/etc/crontabs/root"
    fi
}

core_update_cron_check() {
    cron_make_if_missing
    if grep -q "/usr/bin/justclash core_update" /etc/crontabs/root; then
        return 0
    else
        return 1
    fi
}

core_update_cron_add() {
    cron_make_if_missing
    local mihomo_cron_update_string

    if [ -z "$mihomo_cron_update_string" ]; then
        log 0 "Cron schedule string is empty! Cron job not added." "‚ùå"
        return 1
    fi

    if core_update_cron_check > /dev/null; then
        log 1 "Core autoupdate cron job already exists." "‚ÑπÔ∏è"
        return 0
    fi

    config_get mihomo_cron_update_string settings mihomo_cron_update_string
    echo "$mihomo_cron_update_string /usr/bin/justclash core_update" >> /etc/crontabs/root
    if /etc/init.d/cron enabled; then
        /etc/init.d/cron restart
        log 2 "Cron job added and service restarted" "‚úÖ"
    else
        log 2 "Cron job added (service not enabled)" "‚ÑπÔ∏è"
    fi
    log 2 "Core autoupdate cron job added." "‚úÖ"
}

core_update_cron_remove() {
    cron_make_if_missing
    if core_update_cron_check > /dev/null; then
        sed -i '\|/usr/bin/justclash core_update|d' /etc/crontabs/root
        if /etc/init.d/cron enabled; then
            /etc/init.d/cron restart
            log 2 "Cron job added and service restarted" "‚úÖ"
        else
            log 2 "Cron job added (service not enabled)" "‚ÑπÔ∏è"
        fi
        log 2 "Core autoupdate cron job removed." "üóëÔ∏è"
    else
        log 2 "Core autoupdate cron job not found." "‚ÑπÔ∏è"
    fi
}

core_autorestart_cron_check() {
    cron_make_if_missing
    if grep -q "${INITD_PATH} reload" /etc/crontabs/root; then
        return 0
    else
        return 1
    fi
}

core_autorestart_cron_add() {
    cron_make_if_missing
    local mihomo_cron_autorestart_string

     if [ -z "$mihomo_cron_autorestart_string" ]; then
        log 0 "Cron schedule string is empty! Cron job not added." "‚ùå"
        return 1
    fi

    if core_autorestart_cron_check > /dev/null; then
        log 1 "Core autoupdate cron job already exists." "‚ÑπÔ∏è"
        return 0
    fi

    config_get mihomo_cron_autorestart_string settings mihomo_cron_autorestart_string
    echo "$mihomo_cron_autorestart_string ${INITD_PATH} reload" >> /etc/crontabs/root
    if /etc/init.d/cron enabled; then
        /etc/init.d/cron restart
        log 2 "Cron job added and service restarted" "‚úÖ"
    else
        log 2 "Cron job added (service not enabled)" "‚ÑπÔ∏è"
    fi
    log 2 "Core autoupdate cron job added." "‚úÖ"
}

core_autorestart_cron_remove() {
    cron_make_if_missing
    if core_autorestart_cron_check > /dev/null; then
        sed -i "/${INITD_PATH} reload/d" /etc/crontabs/root
        if /etc/init.d/cron enabled; then
            /etc/init.d/cron restart
            log 2 "Cron job added and service restarted" "‚úÖ"
        else
            log 2 "Cron job added (service not enabled)" "‚ÑπÔ∏è"
        fi
        log 2 "Core autoupdate cron job removed." "üóëÔ∏è"
    else
        log 2 "Core autoupdate cron job not found." "‚ÑπÔ∏è"
    fi
}

diag_nft() {
    clog 2 "Checking for 'nft' command..."
    if ! command -v nft >/dev/null 2>&1; then
        clog 0 "The 'nft' command is not available. Please install nftables to continue."
        return 1
    fi

    clog 2 "Verifying existence of NFTables table '$NFT_TABLE_NAME'..."
    if ! nft list table ip "$NFT_TABLE_NAME" >/dev/null 2>&1; then
        clog 0 "Table '$NFT_TABLE_NAME' not found. Please create the required NFTables table."
        return 1
    fi

    clog 2 "Displaying current NFTables configuration:"
    nft list table ip "$NFT_TABLE_NAME"

    clog 2 "NFTables check completed successfully."

    return 0
}

diag_route() {
    clog 2 "Verifying existence of route rule..."
    if ! ip rule list | grep -q "fwmark 0x1 lookup 100"; then
        clog 0 "Route rule 'ip rule add fwmark ""$NFT_FWMARK_FINAL"" table 100' is missing!"
    fi
    ip rule list

    if ! ip route show table 100 | grep -Eq "local (default|0\.0\.0\.0/0) dev lo"; then
         clog 0 "Route table 100 is incorrect!"
    fi
    ip route show table 100
}

diag_proxy_resolver() {
    if [ -z "$1" ]; then
        log 1 "Usage: diag_proxy_resolver <domain>"
        return 1
    fi
    local target="$1"
    local dns_listen_port
    config_get dns_listen_port proxy dns_listen_port

    clog 2 "Testing Fake IP DNS resolution..."

    local ip_output
    ip_output=$(nslookup "$target" 127.0.0.1:"$dns_listen_port" 2>/dev/null)
    local exit_code=$?

    local ips
    ips=$(echo "$ip_output" | awk '/^Address: / {print $2}')

    if [ "$exit_code" -ne 0 ] || [ -z "$ips" ]; then
        clog 0 "Fake IP DNS query failed"
        return 1
    else
        echo "$ips"
        clog 2 "Fake IP DNS query successful"
        return 0
    fi
}

diag_external_resolver() {
    if [ -z "$1" ] || [ -z "$2" ]; then
        log 1 "Usage: diag_external_resolver <domain> <dnsresolver>"
        return 1
    fi
    local target="$1"
    local resolver="$2"
    local ip_output exit_code

    clog 2 "Testing DNS resolution..."

    ip_output=$(nslookup "$target" "$resolver" 2>/dev/null)
    exit_code=$?

    ips=$(echo "$ip_output" | awk '/^Address: / {print $2}')

    if [ "$exit_code" -ne 0 ] || [ -z "$ips" ]; then
        clog 0 "External DNS query failed"
        return 1
    else
        clog 2 "$ips"
        clog 2 "External DNS query successful"
        return 0
    fi
}

diag_icmp() {
    local target="${1}"
    local count="${2}"
    if [ -z "$target" ] || [ -z "$count" ]; then
        clog 1 "Usage: diag_icmp <target> <count>"
        return 1
    fi
    local timeout=2
    local ping_output

    ping_output=$(ping -c "$count" -W "$timeout" "$target" 2>&1)
    local exit_code=$?

    if [ "$exit_code" -eq 0 ]; then
        clog 2 "Ping to ${target} is successful"
        clog 2 "$ping_output"
    else
        clog 0 "Ping to ${target} is failed"
        clog 0 "$ping_output"
    fi
}

diag_report() {
    local running autoload pkg_manager
    running=$(service justclash status)
    service justclash enabled
    if [ "$?" -eq 0 ]; then
        echo "yes"
    else
        echo "no"
    fi
    if command -v apk >/dev/null 2>&1; then
        pkg_manager="APK"
    else
        pkg_manager="OPKG"
    fi

cat <<EOF
----------------------------
JustClash diagnostic report:
----------------------------

-> Basic:
Device:  $(info_device)
OpenWRT: $(info_openwrt)
Service: $(info_package)
LuCi:    $(info_luci)
Mihomo:  $(info_mihomo)
Pkg:     $pkg_manager

-> Status:
Active:  $running
Load:  $autoload

-> NFT Tables:
$(diag_nft)

-> Routes:
$(diag_route)

-> ICMP $DIAG_IP_CHECK_PING_YANDEX :
$(diag_icmp "$DIAG_IP_CHECK_PING_YANDEX" 2)

-> ICMP $DIAG_IP_CHECK_PING_GOOGLE :
$(diag_icmp "$DIAG_IP_CHECK_PING_GOOGLE" 2)

-> DNS resolve $DIAG_RESOLVE_URL_YANDEX with proxy:
$(diag_proxy_resolver "$DIAG_IP_CHECK_PING_YANDEX")

-> DNS resolve $DIAG_RESOLVE_URL_YANDEX with $DIAG_IP_CHECK_PING_YANDEX:
$(diag_external_resolver "$DIAG_RESOLVE_URL_YANDEX" "$DIAG_IP_CHECK_PING_YANDEX")

-> DNS resolve $DIAG_RESOLVE_URL_YANDEX with $DIAG_IP_CHECK_PING_GOOGLE:
$(diag_external_resolver "$DIAG_RESOLVE_URL_YANDEX" "$DIAG_IP_CHECK_PING_GOOGLE")

-> Zapret:
$(if [ -f "$ZAPRETINITD_FILEPATH" ]; then echo "Zapret detected."; else echo "No zapret installed."; fi)

-> DHCP config:
$(uci show dhcp)

-> /etc/resolv.conf:
$(cat /etc/resolv.conf)

-> Service config:
$(uci show justclash.settings)

-> Service proxy config:
$(uci show justclash.proxy)

EOF

}

config_show() {
    uci export justclash
}

config_reset() {
    if [ ! -f "$DEFAULT_CONFIG_PATH" ]; then
        clog 0 "Default config file is missing. Can't use restore functionality"
        return 1
    fi

    clog 2 "Restoring justclash settings..."

    rm -f /etc/config/justclash.bak

    if [ ! -f /etc/config/justclash ]; then
        clog 0 "Current config file not found, nothing to backup"
    else
        if ! mv /etc/config/justclash /etc/config/justclash.bak; then
            clog 0 "Failed to backup config file"
            return 1
        fi
    fi

    if ! cp "$DEFAULT_CONFIG_PATH" /etc/config/justclash; then
        clog 0 "Failed to restore default config"
        return 1
    fi

    clog 2 "Default settings will be applied at next service restart..."
    return 0
}

help() {
    cat << EOF
Usage: justclash <command> [args]

Service Management:
  start|run               Start the JustClash service.
  stop                    Stop the JustClash service.
  reload|restart          Restart the service.
  config_show             Show configuration in console
  config_reset            Reset configuration

Mihomo management Commands:
  core_update                     Check current version and update Mihomo if a newer version is available
  core_remove                     Remove the currently installed Mihomo binary

  core_update_cron_check          Check if a scheduled Mihomo core auto-update task exists
  core_update_cron_add            Add a scheduled task to periodically check and update Mihomo core
  core_update_cron_remove         Remove the scheduled Mihomo core auto-update task

  core_autorestart_cron_check     Check if a scheduled Mihomo auto-restart task exists
  core_autorestart_cron_add       Add a scheduled task to automatically restart Mihomo periodically
  core_autorestart_cron_remove    Remove the scheduled Mihomo auto-restart task

Information Commands:
  info_device             Show device model.
  info_openwrt            Show OpenWrt version.
  info_core               Show Mihomo core version.
  info_package            Show JustClash package version.
  info_luci               Show JustClash LuCI app version.
  info_conns_console      Show Mihomo connections.

Diagnostics:
  diag_nft                Run nftables diagnostic.
  diag_route              Run route tables diagnostic.
  diag_icmp               Run internet check with ICMP.
  diag_proxy_resolver     Run Internal DNS diagnostic.
  diag_external_resolver  Run Default DNS diagnostic.

Logs:
  logs|systemlogs [N]     Show last N lines of system logs (default 40).

Help:
  help|?|command          Show this help message.

EOF
}

case "$1" in
    start|run)
        start
        ;;
    stop)
        stop
        ;;
    reload|restart)
        restart
        ;;
    config_show)
        config_show
        ;;
    config_reset)
        config_reset
        ;;
    core_update)
        core_update
        ;;
    core_remove)
        core_remove
        ;;
    core_update_cron_check)
        core_update_cron_check
        ;;
    core_update_cron_add)
        core_update_cron_add
        ;;
    core_update_cron_remove)
        core_update_cron_remove
        ;;
    core_autorestart_cron_check)
        core_autorestart_cron_check
        ;;
    core_autorestart_cron_add)
        core_autorestart_cron_add
        ;;
    core_autorestart_cron_remove)
        core_autorestart_cron_remove
        ;;
    logs|systemlogs)
        case "$2" in
            *[!0-9]* | '')
                systemlogs
                ;;
            *)
                systemlogs "$2"
                ;;
        esac
        ;;
    info_device)
        info_device
        ;;
    info_openwrt)
        info_openwrt
        ;;
    info_core|info_mihomo)
        info_mihomo
        ;;
    info_package)
        info_package
        ;;
    info_luci)
        info_luci
        ;;
    info_conns_console)
        info_conns_console
        ;;
    diag_nft)
        diag_nft
        ;;
    diag_route)
        diag_route
        ;;
    diag_report)
        diag_report
        ;;
    diag_proxy_resolver)
        diag_proxy_resolver "$2"
        ;;
    diag_external_resolver)
        diag_external_resolver "$2" "$3"
        ;;
    diag_icmp)
        diag_icmp "$2" "${3:-3}"
        ;;
    help|?|command)
        help
        ;;
    *)
        clog 2 "Unknown command: $1"
        clog 2 "Type 'justclash help' for a list of available commands."
        exit 1
        ;;
esac
