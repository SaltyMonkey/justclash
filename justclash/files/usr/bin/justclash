#!/bin/ash
# Ash isn't supported properly in spellcheck static analyzer
# Using debian based version (kind of similar)
# shellcheck shell=dash

# --------------------------------------------
# Main justclash service part
# Directly using uci config calls every load
# Avoid adding simple commands for perfomance
# --------------------------------------------

VERSION="__COMPILED_VERSION_VARIABLE__"
# shellcheck disable=SC1091
[ -r /lib/functions.sh ] && . /lib/functions.sh
# shellcheck disable=SC1091
[ -r /lib/config/uci.sh ] && . /lib/config/uci.sh
. /usr/lib/justclash/logging.sh
. /usr/lib/justclash/migration.sh
. /usr/lib/justclash/compat_fixes.sh
. /usr/lib/justclash/uri_parsers.sh
. /usr/lib/justclash/helpers.sh

# Variable for standalone or procd start
PROCD_MODE=0

PROGNAME="justclash"

# setup procd variable: $JUSTCLASH_ENV passed from init.d start
# shellcheck disable=SC2154
if [ "$JUSTCLASH_ENV" = "procd" ]; then
    PROCD_MODE=1
else
    PROCD_MODE=0
fi

config_load "$PROGNAME"

CORE_RELEASE_CHECK_URL="https://api.github.com/repos/MetaCubeX/mihomo/releases/latest"
CORE_RELEASE_DOWNLOAD_URL="https://github.com/MetaCubeX/mihomo/releases/download"
INBUILD_RULESETS_FILES_DOWNLOAD_URL="https://raw.githubusercontent.com/SaltyMonkey/mrs-parsed-data/refs/heads/main"

NO_DATA_STRING="N/A"

CORE_BIN_NAME="mihomo"

# Path to Mihomo core
CORE_PATH="/usr/bin/${CORE_BIN_NAME}"
INITD_PATH="/etc/init.d/${PROGNAME}"
# workdir path (in RAM)
CORE_WORKDIR_PATH="/tmp/${PROGNAME}/"
# Mihomo using directory 'rules' by default in workdir
# if nothing selected in path fields for rules
CORE_WORKDIR_RULES_PATH="${CORE_WORKDIR_PATH}rules"
CORE_WORKDIR_UCI_HASH_PATH="${CORE_WORKDIR_PATH}uci.hash"
OUTPUT_YAML_CONFIG_PATH="${CORE_WORKDIR_PATH}config.yaml"

ETC_DIR="/etc/${PROGNAME}/"
RULESETS_BLOCKS_FILENAME="block.rulesets.txt"
RULESETS_FILENAME="rulesets.txt"
DEFAULT_SYMLINKDIR_RULESETS="${ETC_DIR}${PROGNAME}_rules"
RULESETS_BLOCKS_FILE="${ETC_DIR}${RULESETS_BLOCKS_FILENAME}"
RULESETS_FILE="${ETC_DIR}${RULESETS_FILENAME}"

DASHBOARD_PATH="${ETC_DIR}zashboard"
DASHBOARD_NAME="dashboard"
DASHBOARD_DEFAULT_URL="https://github.com/Zephyruso/zashboard/releases/latest/download/dist-no-fonts.zip"

ETC_CONFIG_DIR="/etc/config/"
DEFAULT_CONFIG_PATH="${ETC_DIR}default.config"
CONFIG_PATH="${ETC_CONFIG_DIR}${PROGNAME}"
CONFIG_BAK_PATH="${ETC_CONFIG_DIR}${PROGNAME}.bak"

DEFAULT_RULESET_PROXY="DIRECT"
DEFAULT_PROXY="DIRECT"
DEFAULT_HEALTHCHECK_INTERVAL=360
DEFAULT_PROVIDERUPDATE_INTERVAL=7200
DEFAULT_HEALTHCHECK_TIMEOUT=5000
DEFAULT_RULESET_INTERVAL="86500"
DEFAULT_HEALTHCHECK_URL="http://www.gstatic.com/generate_204"
DEFAULT_HEALTHCHECK_RESULT=204
DEFAULT_MAX_FAILED_TIMES=5

DEFAULT_INPUT_INTERFACE="br-lan"

DEFAULT_TLS_PORT=443
DEFAULT_SECONDARY_TLS_PORT=8443
DEFAULT_HTTP_PORT=80
DEFAULT_SECONDARY_HTTP_PORT_RANGE=8080
DEFAULT_SECONDARY_HTTP_PORT_RANGE_END=8880
DEFAULT_SOCKS_PORT=1080
DEFAULT_DOT_PORT=853
DEFAULT_NTP_PORT=123

CORE_RESTART_MAX_RETRIES=3

DIAG_RESOLVE_URL_YANDEX="ya.ru"
DIAG_IP_CHECK_PING_YANDEX="77.88.8.8"
DIAG_IP_CHECK_PING_GOOGLE="8.8.8.8"

NF_TABLE_NAME="${PROGNAME}_tproxy"
NF_TABLE_FWMARK_FINAL=0x1
NF_TABLE_FWMARK_PROXY=0xFF
NF_ROUTE_TABLE=100

# List of NTP server IP addresses:
# 194.190.168.1   — ntp1.stratum2.ru (Russian NTP server)
# 195.208.185.17  — ntp2.stratum2.ru (Russian NTP server)
# 193.232.128.6   — ntp3.stratum2.ru (Russian NTP server)
# 216.239.35.0    — time.google.com (Google NTP)
NTP_IPS="194.190.168.1 195.208.185.17 193.232.128.6 216.239.35.0"

CONFLICTED_PATTERNS_DHCP_CONFIG="podkop_server podkop_noresolv podkop_cachesize doh_backup_noresolv doh_backup_server doh_server"
CONFLICTED_PATTERNS_FILEPATH="/etc/config/dhcp"
RESOLVCONF_FILEPATH="/etc/resolv.conf"
ZAPRETINITD_FILEPATH="/etc/init.d/zapret"
BYEDPI_FILEPATH="/etc/init.d/byedpi"
YOUTUBEUNBLOCK_FILEPATH="/etc/init.d/youtubeUnblock"

ucibool_to_yesno() {
    case "$1" in
        1) echo "Yes" ;;
        0) echo "No" ;;
        *) echo "$1" ;;
    esac
}

panic() {
    log 0 "$1" '💥'
    stop
    exit 1
}

is_pattern_in_file() {
    local file="$1"

    if [ ! -r "$file" ]; then
        log 1 "File $file can't be opened!"
        return 1
    fi
    local found_patterns=""
    for pattern in "$@"; do
        if grep -qE "$pattern" "$file"; then
            found_patterns="${found_patterns:+$found_patterns }$pattern"
        fi
    done
    if [ -n "$found_patterns" ]; then
        echo "$found_patterns"
        return 0
    else
        return 1
    fi
}

ntp_force_sync() {
    local ntpd_start
    config_get_bool ntpd_start settings ntpd_start
    if [ -z "$NTP_IPS" ]; then
        log 0 "No NTP servers configured" "⚠️"
        return 1
    fi

    if [ "$ntpd_start" -eq 1 ]; then
        NTP_ARGS=""
        for ip in $NTP_IPS; do
            NTP_ARGS="$NTP_ARGS -p $ip"
        done
        # shellcheck disable=SC2086
        /usr/sbin/ntpd -q $NTP_ARGS
    fi

    sleep 2
}

core_validate_yaml() {
    local test_output app_exit_code grep_test_exit_code grep_error_exit_code
    test_output="$("$CORE_PATH" -t -f "$OUTPUT_YAML_CONFIG_PATH" 2>&1)"
    app_exit_code=$?
    echo "$test_output" | grep -qiF "test failed"
    grep_test_exit_code=$?
    echo "$test_output" | grep -qiF "error"
    grep_error_exit_code=$?
    if [ "$grep_test_exit_code" -eq 0 ] || [ "$app_exit_code" -ne 0 ] || [ "$grep_error_exit_code" -eq 0 ]; then
        log 0 "Yaml configuration incorrect!" "❌"
        log 0 "$test_output" "❌"
        log 0 "Mihomo config validation is failed." "❌"
        return 1
    fi
    return 0
}

start() {
    local skip_environment_checks

    log 2 "Initializing Justclash service..." "⏳"

    check_requirement || return 1

    config_get_bool skip_environment_checks settings skip_environment_checks 0
    if [ "$skip_environment_checks" -eq 1 ]; then

        log 2 "Checking for conflicts" "⏳"
        check_for_conflicts || return 1

        log 2 "Checking for non critical conflicts" "⏳"
        check_for_conflicts_warn

        log 2 "Fixing known compatibility problems" "🐞"
        compat_fixes
    fi

    log 2 "Applying migration if required..." "⏳"
    migration

    log 2 "Synchronizing system time" "🕒"
    ntp_force_sync

    log 2 "Modifying SAFE_PATHS env variable" "📦"
    safe_paths_add "$DASHBOARD_PATH"

    log 2 "Preparing Mihomo working directory" "📦"
    core_prepare_workdir
    if [ $? -eq 1 ]; then
        log 2 "Generating yaml configuration..." "🐱"
        core_generate_yaml

        log 2 "Validating yaml configuration..." "🐱"
        core_validate_yaml || return 1
    fi

    log 2 "Configuring tproxy routing and creating NFTables table" "🔑"
    nf_table_add

    log 2 "Modifying dnsmasq configuration" "🔑"
    dnsmasq_update

    log 2 "Starting Mihomo core" "🐱"
    start_core
}

stop() {
    log 2 "Closing Justclash service..." "⏳"
    log 2 "Removing tproxy routing and NFTables table" "🔑"
    nf_table_remove

    log 2 "Restoring default dnsmasq configuration" "🔑"
    dnsmasq_restore

    log 2 "Stopping core process" "🐱"
    stop_core
}

# WARNING: TRY TO NOT USE FUNC MANUALLY - MUST CLEAR ROUTES AND DNSMASQ
start_core() {
    local attempt=0
    log 2 "Start with configured retries: $CORE_RESTART_MAX_RETRIES" "🐱"

    if [ "$PROCD_MODE" -eq 1 ]; then
        local attempt=0

        while [ "$attempt" -lt "$CORE_RESTART_MAX_RETRIES" ]; do
            "$CORE_PATH" -d "$CORE_WORKDIR_PATH" 2>&1 | sed 's/time="[^"]*"/mihomo/' | logger -t "${PROGNAME}"
            exit_code=$?
            log 1 "Procd mode: mihomo exited with code $exit_code" "❌"

            if [ "$exit_code" -eq 0 ]; then
                break
            fi

            attempt=$((attempt + 1))
            log 0 "Procd mode:  mihomo crashed, attempt $attempt of $CORE_RESTART_MAX_RETRIES" "❌"

            if [ "$attempt" -ge "$CORE_RESTART_MAX_RETRIES" ]; then
                log 0 "Procd mode:  Failed to restart mihomo after $CORE_RESTART_MAX_RETRIES attempts, exiting" "❌"
                exit "$exit_code"
            fi

            sleep 2
        done
    else
        "$CORE_PATH" -d "$CORE_WORKDIR_PATH" 2>&1
        exit_code=$?
        log 1 "Manual mode: mihomo exited with code $exit_code" "❌"
        if [ "$exit_code" -ne 0 ]; then
            log 0 "Manual mode: mihomo crashed, exiting" "❌"
            exit "$exit_code"
        fi
    fi
}

# WARNING: TRY TO NOT USE FUNC MANUALLY - MUST CLEAR ROUTES AND DNSMASQ
stop_core() {
    if pgrep -f "$(basename "$0")" >/dev/null; then
        pids=$(pgrep -f "$(basename "$CORE_PATH")")
        if [ -n "$pids" ]; then
            # DO NOT APPLY "" - STRING MUST BE SPLITTED AUTOMATICALLY
            # shellcheck disable=SC2086
            kill $pids 2>/dev/null
            log 2 "Core process stopped" "🐱"
        else
            log 2 "No matching processes found" "🐱"
        fi
    else
       log 2 "JustClash isn't running" "🐱"
    fi
}

cleanup_fwmark() {
    while ip rule show | grep -qF "fwmark ${NF_TABLE_FWMARK_FINAL} lookup ${NF_ROUTE_TABLE}"; do
        ip rule del fwmark "$NF_TABLE_FWMARK_FINAL" table "$NF_ROUTE_TABLE" 2>/dev/null || true
    done
}

nf_table_add() {
    local nft_apply_changes
    local tproxy_port fake_ip_range tproxy_input_interfaces
    local nft_quic_mode nft_dot_mode nft_dot_quic_mode nft_ntp_mode

    config_get nft_apply_changes settings nft_apply_changes

    if [ "$nft_apply_changes" = "0" ]; then
        return 0
    fi

    config_get tproxy_port proxy tproxy_port
    config_get fake_ip_range proxy fake_ip_range
    config_get tproxy_input_interfaces settings tproxy_input_interfaces "$DEFAULT_INPUT_INTERFACE"
    config_get nft_quic_mode settings nft_quic_mode
    config_get nft_dot_mode settings nft_dot_mode
    config_get nft_dot_quic_mode settings nft_dot_quic_mode
    config_get nft_ntp_mode settings nft_ntp_mode

    [ -z "$tproxy_port" ] && panic "tproxy_port not set"
    [ -z "$fake_ip_range" ] && panic "fake_ip_range not set"

    if nft list table ip "$NF_TABLE_NAME" 2>/dev/null; then
        nft delete table ip "$NF_TABLE_NAME"
    fi

    # Создаём таблицу, цепочку и набор адресов
    nft add table ip "$NF_TABLE_NAME"
    nft add chain ip "$NF_TABLE_NAME" prerouting '{ type filter hook prerouting priority mangle; policy accept; }'
    #nft add chain ip "$NF_TABLE_NAME" output '{ type route hook output priority mangle; policy accept; }'

    nft add set ip "$NF_TABLE_NAME" fake_ips '{ type ipv4_addr; flags interval; }'
    # shellcheck disable=SC2086
    nft add element ip "$NF_TABLE_NAME" fake_ips { $fake_ip_range }

    nft add set ip "$NF_TABLE_NAME" private_ips '{ type ipv4_addr; flags interval; }'
    nft add element ip "$NF_TABLE_NAME" private_ips { \
        0.0.0.0/8, 10.0.0.0/8, 100.64.0.0/10, 127.0.0.0/8, \
        169.254.0.0/16, 172.16.0.0/12, 192.0.0.0/24, 192.0.2.0/24, \
        192.88.99.0/24, 192.168.0.0/16, 198.51.100.0/24, 203.0.113.0/24, \
        224.0.0.0/4, 240.0.0.0/4 }

    nft add set ip "$NF_TABLE_NAME" inbound_interfaces '{ type ifname; }'
    for iface in $tproxy_input_interfaces; do
        nft add element ip "$NF_TABLE_NAME" inbound_interfaces { "\"$iface\"" }
    done

    nft add rule ip "$NF_TABLE_NAME" prerouting iifname @inbound_interfaces mark "$NF_TABLE_FWMARK_PROXY" return

    nft add rule ip "$NF_TABLE_NAME" prerouting iifname @inbound_interfaces ip daddr @private_ips return

    if [ "$nft_quic_mode" = "DROP" ]; then
        # shellcheck disable=SC2248
        nft add rule ip "$NF_TABLE_NAME" prerouting iifname @inbound_interfaces meta l4proto udp udp dport { $DEFAULT_TLS_PORT } drop
    fi
    if [ "$nft_dot_quic_mode" = "DROP" ]; then
        # shellcheck disable=SC2248
        nft add rule ip "$NF_TABLE_NAME" prerouting iifname @inbound_interfaces meta l4proto udp udp dport { $DEFAULT_DOT_PORT } drop
    fi
    if [ "$nft_dot_mode" = "DROP" ]; then
        # shellcheck disable=SC2248
        nft add rule ip "$NF_TABLE_NAME" prerouting iifname @inbound_interfaces meta l4proto tcp tcp dport  { $DEFAULT_DOT_PORT } drop
    fi

    if [ "$nft_ntp_mode" = "DROP" ]; then
        # shellcheck disable=SC2248
        nft add rule ip "$NF_TABLE_NAME" prerouting iifname @inbound_interfaces meta l4proto udp udp dport { $DEFAULT_NTP_PORT } drop
    elif [ "$nft_ntp_mode" = "DIRECT" ]; then
        # shellcheck disable=SC2248
        nft add rule ip "$NF_TABLE_NAME" prerouting iifname @inbound_interfaces meta l4proto udp udp dport { $DEFAULT_NTP_PORT } return
    fi

    nft add rule ip "$NF_TABLE_NAME" prerouting iifname @inbound_interfaces meta l4proto { tcp, udp } meta mark set "$NF_TABLE_FWMARK_FINAL"

    nft add rule ip "$NF_TABLE_NAME" prerouting iifname @inbound_interfaces meta mark "$NF_TABLE_FWMARK_FINAL" meta l4proto { tcp, udp } tproxy to 127.0.0.1:"$tproxy_port"

    # --- output ---
    #nft add rule ip "$NF_TABLE_NAME" output mark "$NF_TABLE_FWMARK_PROXY" return

    #nft add rule ip "$NF_TABLE_NAME" output ip daddr @private_ips return

    #nft add rule ip "$NF_TABLE_NAME" output ip protocol udp udp dport { 67,68 } return

    #nft add rule ip "$NF_TABLE_NAME" output ip daddr 255.255.255.255 return

    #nft add rule ip "$NF_TABLE_NAME" output meta l4proto { tcp, udp } meta mark set "$NF_TABLE_FWMARK_FINAL"

    #nft add rule ip "$NF_TABLE_NAME" output meta mark "$NF_TABLE_FWMARK_FINAL" meta l4proto { tcp, udp } tproxy to 127.0.0.1:"$tproxy_port"

    cleanup_fwmark
    if ! ip rule list | grep -qF "fwmark ${NF_TABLE_FWMARK_FINAL} lookup $NF_ROUTE_TABLE"; then
        ip rule add fwmark "$NF_TABLE_FWMARK_FINAL" table "$NF_ROUTE_TABLE"
    fi

    if ! ip route show table "$NF_ROUTE_TABLE" | grep -Eq "local (default|0\.0\.0\.0/0) dev lo"; then
        ip route add local 0.0.0.0/0 dev lo table "$NF_ROUTE_TABLE"
    fi

    log 1 "Tproxy: port=$tproxy_port, fwmark=$NF_TABLE_FWMARK_FINAL fwmark_proxy=$NF_TABLE_FWMARK_PROXY table=$NF_ROUTE_TABLE" "🛠️"
}

nf_table_remove() {
    cleanup_fwmark
    nft flush table ip "$NF_TABLE_NAME" 2>/dev/null || true
    nft delete table ip "$NF_TABLE_NAME" 2>/dev/null || true
    ip route flush table "$NF_ROUTE_TABLE" 2>/dev/null || true

    log 2 "Tproxy rules and routing were removed" "🛠️"
}

# Thx Podkop, feels so annoyed already by shell scripting
save_dnsmasq_config() {
    local key="$1"
    local backup_key="$2"
    value=$(uci get "$key" 2>/dev/null)

    if [ -z "$value" ]; then
        uci set "$backup_key"="unset"
    else
        uci set "$backup_key"="$value"
    fi
}

dnsmasq_update() {
    local dns_listen_port dnsmasq_apply_changes

    config_get_bool dnsmasq_apply_changes settings dnsmasq_apply_changes

    if [ "$dnsmasq_apply_changes" -eq 1 ]; then
        config_get dns_listen_port proxy dns_listen_port
        uci -q delete dhcp.@dnsmasq[0]."${PROGNAME}"_server
        for server in $(uci -q get dhcp.@dnsmasq[0].server); do
            if [ "$server" = "127.0.0.1#${dns_listen_port}" ]; then
                log 1 "Dnsmasq save config error: server=127.0.0.1 is already configured. Skip editing DHCP"
                return 1
            else
                uci add_list dhcp.@dnsmasq[0]."${PROGNAME}"_server="$server"
            fi
        done

        save_dnsmasq_config "dhcp.@dnsmasq[0].noresolv" "dhcp.@dnsmasq[0].${PROGNAME}_noresolv"
        save_dnsmasq_config "dhcp.@dnsmasq[0].cachesize" "dhcp.@dnsmasq[0].${PROGNAME}_cachesize"

        uci add_list dhcp.@dnsmasq[0].server="127.0.0.1#$dns_listen_port"
        uci set dhcp.@dnsmasq[0].cachesize="0"
        uci set dhcp.@dnsmasq[0].noresolv="1"

        uci commit dhcp
        log 2 "DNS configuration has been updated with new settings." "🌐"
        /etc/init.d/dnsmasq restart > /dev/null 2>&1
        log 2 "dnsmasq service has been restarted to apply DNS changes." "🔄"
    else
        log 2 "DNS configuration remains unchanged; update skipped as per configuration rules." "🛠️"
    fi

}

dnsmasq_restore() {
    local dns_listen_port
    local dnsmasq_apply_changes
    config_get_bool dnsmasq_apply_changes settings dnsmasq_apply_changes

    local bak_cachesize
    local bak_noresolv
    local server

    if [ "$dnsmasq_apply_changes" -eq 1 ]; then
        config_get dns_listen_port proxy dns_listen_port
        bak_cachesize=$(uci -q get dhcp.@dnsmasq[0]."${PROGNAME}"_cachesize)
        if [ -z "$bak_cachesize" ]; then
            log 1 "dnsmasq revert: cachesize is unset"
        else
            uci set dhcp.@dnsmasq[0].cachesize="$bak_cachesize"
        fi

        bak_noresolv=$(uci -q get dhcp.@dnsmasq[0]."${PROGNAME}"_noresolv)
        if [ "$bak_noresolv" = "unset" ]; then
            log 1 "dnsmasq revert: noresolv is unset"
            uci -q delete dhcp.@dnsmasq[0].noresolv
        else
            uci set dhcp.@dnsmasq[0].noresolv="$bak_noresolv"
        fi

        server=$(uci -q get dhcp.@dnsmasq[0].server)
        if [ "$server" = "127.0.0.1#${dns_listen_port}" ]; then
            uci -q delete dhcp.@dnsmasq[0].server
            for server in $(uci -q get dhcp.@dnsmasq[0]."${PROGNAME}"_server); do
                 [ -n "$server" ] && uci add_list dhcp.@dnsmasq[0].server="$server"
            done
            uci -q delete dhcp.@dnsmasq[0]."${PROGNAME}"_server
        fi

        uci commit dhcp
        log 2 "DNS configuration has been restored." "🌐"
        /etc/init.d/dnsmasq restart > /dev/null 2>&1
        log 2 "dnsmasq service has been restarted to apply DNS changes." "🔄"
    else
        log 2 "DNS configuration remains unchanged; update skipped as per configuration rules." "🛠️"
    fi
}

check_requirement() {
    local ret=0

    if [ ! -f "$CORE_PATH" ]; then
        log 0 "Requirement is missing: mihomo core is not installed." "❌"
        ret=1
    fi

    if ! command -v jq >/dev/null 2>&1; then
        log 0 "Requirement is missing: jq is not installed." "❌"
        ret=1
    fi

    if ! command -v nft >/dev/null 2>&1; then
        log 0 "Requirement is missing: nft is not installed." "❌"
        ret=1
    fi

    if ! command -v curl >/dev/null 2>&1; then
        log 0 "Requirement is missing: curl is not installed." "❌"
        ret=1
    fi

    if ! command -v md5sum >/dev/null 2>&1; then
        log 0 "Requirement is missing: coreutils-base64 is not installed." "❌"
        ret=1
    fi
    return "$ret"
}

check_for_conflicts() {
    local found_patterns pattern ret

    # For $CONFLICTED_PATTERNS_DHCP_CONFIG only. We don't need "" to make shell split string
    # shellcheck disable=SC2086
    found_patterns=$(is_pattern_in_file "$CONFLICTED_PATTERNS_FILEPATH" "$CONFLICTED_PATTERNS_DHCP_CONFIG")
    if [ -n "$found_patterns" ]; then
        for pattern in $found_patterns; do
            log 1 "Conflict detected: pattern '$pattern' found in /etc/config/dhcp." "⚠️"
            log 1 "This pattern may indicate a configuration clash with the current service." "⚠️"
            log 1 "Please review and edit your DHCP configuration to resolve this issue." "⚠️"
        done
        log 0 "Conflicting DHCP configuration patterns detected."
        ret=1
    else
        ret=0
    fi

    return "$ret"
}

check_for_conflicts_warn() {
    local external_nameservers
    external_nameservers=$(
        awk '$1 == "nameserver" && $2 != "127.0.0.1" && $2 != "0.0.0.0" { print; found=1 } END { exit !found }' "$RESOLVCONF_FILEPATH"
    )
    local resolvconf_res=$?

    if [ "$resolvconf_res" -eq 0 ]; then
        log 1 "Warning: External DNS servers are listed in /etc/resolv.conf:" "⚠️"
        log 1 "Found: $external_nameservers" "⚠️"
        log 1 "This may bypass local DNS rules and cause unexpected query results." "⚠️"
        log 1 "If you intend to use a local DNS service, these entries should be removed." "⚠️"
    fi

    if [ -f "$ZAPRETINITD_FILEPATH" ]; then
        log 1 "Warning: Zapret service detected by path $ZAPRETINITD_FILEPATH:" "⚠️"
        log 1 "This service can cause unexpected results if configured incorrectly." "⚠️"
    fi

    if [ -f "$BYEDPI_FILEPATH" ]; then
        log 1 "Warning: ByeDPI service detected by path $BYEDPI_FILEPATH:" "⚠️"
        log 1 "This service can cause unexpected results if configured incorrectly." "⚠️"
    fi

}

info_device() {
   get_hw_model || echo "$NO_DATA_STRING"
}

info_openwrt() {
   get_os_version_full || echo "$NO_DATA_STRING"
}

info_openwrt_version() {
   get_os_version || echo "$NO_DATA_STRING"
}

info_mihomo() {
    if [ ! -x "$CORE_PATH" ]; then
        echo "$NO_DATA_STRING"
    else
        "$CORE_PATH" -v 2>/dev/null | head -n1 | awk '{ print $3 }'
    fi
}

info_package() {
    echo "$VERSION"
}

systemlogs() {
    local lines=${1:-40}
    logread -e "$PROGNAME" | tail -n "$lines"
    return 0
}

simple_uci_list_to_json_arr() {
    local section_name="$1"
    local list_name="$2"
    local result=""
    local values

    config_get values "$section_name" "$list_name"

    [ -z "$values" ] && {
        echo "[]"
        return
    }

    for val in $values; do
        [ -n "$val" ] && {
            val=$(printf '%s' "$val" | sed 's/"/\\"/g')
            if [ -n "$result" ]; then
                result="${result}, \"$val\""
            else
                result="\"$val\""
            fi
        }
    done

    [ -z "$result" ] && echo "[]" || echo "[$result]"
}

ucibool_to_yaml_bool () {
    case "$1" in
        1|yes|on|true) echo "true" ;;
        *) echo "false" ;;
    esac
}

handle_proxy_section() {
    local ruleset_content="$1"
    local file_rules="$2"
    local file_rulesets="$3"
    local file_proxies="$4"
    local file_rulesets_names="$5"
    local file_proxies_names="$6"
    local proxies=""
    local rules_array=""
    local selectedRuleSets=""
    local list_rulesets_names=""
    local list_suffix_names=""

    # shellcheck disable=SC2317
    _parse_single_proxy() {
        local section="$1"
        local name proxy_link_uri interval mode proxy_link_object use_proxy_for_list_update list val
        local domain_list cidr_list

        config_get name "$section" name
        config_get proxy_link_uri "$section" proxy_link_uri
        config_get interval "$section" list_update_interval
        config_get mode "$section" mode "uri"
        config_get proxy_link_object "$section" proxy_link_object
        config_get_bool use_proxy_for_list_update "$section" use_proxy_for_list_update 0

        [ -z "$name" ] && { log 1 "Skipping proxy without name: $section" "⚠️"; return; }

        local proxy_obj=""
        if [ "$mode" = "object" ]; then
            [ -z "$proxy_link_object" ] && { log 1 "Skipping empty proxy '$name" "⚠️" ; return; }

            proxy_obj=$(echo "$proxy_link_object" | jq -c --arg name "$name" '. + {name: $name}')

            [ -z "$proxy_obj" ] && { log 1 "Failed to process object for '$name'" "⚠️"; return; }
        else
            [ -z "$proxy_link_uri" ] && { log 1  "Skipping empty '$name'" "⚠️"; return; }

            proxy_link_uri=$(echo "$proxy_link_uri" | trim)
            proxy_link_uri=$(json_escape "$proxy_link_uri")
            [ -z "$interval" ] && interval=$DEFAULT_RULESET_INTERVAL

            case "$proxy_link_uri" in
                ss://*)     proxy_obj=$(parse_ss_url "$proxy_link_uri" "$DEFAULT_SOCKS_PORT") ;;
                socks5://*) proxy_obj=$(parse_socks5_url "$proxy_link_uri" "$DEFAULT_SOCKS_PORT") ;;
                socks://*) proxy_obj=$(parse_socks5_url "$proxy_link_uri" "$DEFAULT_SOCKS_PORT") ;;
                trojan://*) proxy_obj=$(parse_trojan_url "$proxy_link_uri" "$DEFAULT_TLS_PORT") ;;
                vless://*)  proxy_obj=$(parse_vless_url "$proxy_link_uri" "$DEFAULT_TLS_PORT") ;;
                mierus://*) proxy_obj=$(parse_mieru_url "$proxy_link_uri" "$DEFAULT_TLS_PORT") ;;
                *) log 1 "Unknown proxy link type: $proxy_link_uri" "⚠️"; return ;;
            esac

            [ -z "$proxy_obj" ] && { log 1 "Failed to parse proxy link: $proxy_link_uri" "⚠️"; return; }

            proxy_obj=$(echo "$proxy_obj" | jq -c --arg name "$name" '. + {name: $name}')
        fi

        proxies="${proxies:+$proxies,}$proxy_obj"

        local added_rulesets="|"
        config_get list "$section" enabled_list
        for ruleset in $list; do
            if echo "$added_rulesets" | grep -qF "|$ruleset|"; then
                log 1 "Skipping duplicated ruleset: $ruleset" "⚠️"
                continue
            fi

            local line r_name yaml behavior format url proxy
            line=$(echo "$ruleset_content" | grep -F "|$ruleset|" | head -n 1)
            if [ -n "$line" ]; then
                local rest
                r_name="${line%%|*}"
                rest="${line#*|}"
                yaml="${rest%%|*}"
                rest="${rest#*|}"
                behavior="${rest%%|*}"
                rest="${rest#*|}"
                format="${rest%%|*}"
                url="${rest#*|}"
                local rule_str=$(printf 'RULE-SET,%s,%s' "$ruleset" "$name")
                rules_array="${rules_array:+$rules_array,}\"$rule_str\""

                [ "$use_proxy_for_list_update" -eq 1 ] && proxy="$name" || proxy=$DEFAULT_PROXY
                selectedRuleSets="${selectedRuleSets}\"$ruleset\":{\"url\":\"$url\",\"behavior\":\"$behavior\",\"format\":\"$format\",\"proxy\":\"$proxy\",\"interval\":$interval,\"type\":\"http\"},"
                added_rulesets="$added_rulesets$ruleset|"

                if [ "$behavior" = "domain" ]; then
                    list_rulesets_names="${list_rulesets_names:+$list_rulesets_names,}\"rule-set:$rng_name\""
                fi
            fi
        done

        config_get domain_list "$section" custom_enabled_domain_list
        for line in $domain_list; do
            local clean_line=$(echo "$line" | trim)
            if [ -n "$clean_line" ]; then
                local rng_name=$(printf "%s" "$clean_line" | md5_str )
                case "$clean_line" in
                    http://*|https://*)
                        [ "$use_proxy_for_list_update" -eq 1 ] && proxy="$name" || proxy=$DEFAULT_PROXY
                        selectedRuleSets="${selectedRuleSets}\"$rng_name\":{\"url\":\"$(json_escape "$clean_line")\",\"behavior\":\"domain\",\"format\":\"mrs\",\"proxy\":\"$proxy\",\"interval\":$interval,\"type\":\"http\"},"
                    ;;
                *)
                    if [ -f "$clean_line" ]; then
                        local escaped_path=$(json_escape "$clean_line")
                        safe_paths_add "$escaped_path"
                        [ "$use_proxy_for_list_update" -eq 1 ] && proxy="$name" || proxy=$DEFAULT_PROXY
                        selectedRuleSets="${selectedRuleSets}\"$rng_name\":{\"path\":\"$escaped_path\",\"behavior\":\"domain\",\"format\":\"mrs\",\"type\":\"file\"},"
                    else
                        log 1 "Incorrect value in custom domain list: $clean_line" "⚠️"
                        continue
                    fi
                    ;;
                esac

                local rule_str=$(printf 'RULE-SET,%s,%s' "$rng_name" "$name")
                rules_array="${rules_array:+$rules_array,}\"$rule_str\""
                list_rulesets_names="${list_rulesets_names:+$list_rulesets_names,}\"rule-set:$ruleset\""
            fi
        done

        config_get cidr_list "$section" custom_enabled_cidr_list
        for line in $cidr_list; do
            local clean_line=$(echo "$line" | trim)
            if [ -n "$clean_line" ]; then
                local rng_name=$(printf "%s" "$clean_line" | md5_str )
                case "$clean_line" in
                    http://*|https://*)
                        [ "$use_proxy_for_list_update" -eq 1 ] && proxy="$name" || proxy=$DEFAULT_PROXY
                        selectedRuleSets="${selectedRuleSets}\"$rng_name\":{\"url\":\"$(json_escape "$clean_line")\",\"behavior\":\"ipcidr\",\"format\":\"mrs\",\"proxy\":\"$proxy\",\"interval\":$interval,\"type\":\"http\"},"
                    ;;
                *)
                    if [ -f "$clean_line" ]; then
                        local escaped_path=$(json_escape "$clean_line")
                        safe_paths_add "$escaped_path"
                        [ "$use_proxy_for_list_update" -eq 1 ] && proxy="$name" || proxy=$DEFAULT_PROXY
                        selectedRuleSets="${selectedRuleSets}\"$rng_name\":{\"path\":\"$escaped_path\",\"behavior\":\"ipcidr\",\"format\":\"mrs\",\"type\":\"file\"},"
                    else
                        log 1 "Incorrect value in custom cidr list: $clean_line" "⚠️"
                        continue
                    fi
                    ;;
                esac

                local rule_str=$(printf 'RULE-SET,%s,%s' "$rng_name" "$name")
                rules_array="${rules_array:+$rules_array,}\"$rule_str\""
            fi
        done

        config_get list "$section" additional_srcip_route
        for val in $list; do
            [ -n "$val" ] && {
                local rule_str=$(printf 'SRC-IP-CIDR,%s,%s' "$val" "$name")
                rules_array="${rules_array:+$rules_array,}\"$rule_str\""
            }
        done
        config_get list "$section" additional_domain_route
        for val in $list; do
            [ -n "$val" ] && {
                local rule_str=$(printf 'DOMAIN-SUFFIX,%s,%s' "$val" "$name")
                rules_array="${rules_array:+$rules_array,}\"$rule_str\""
                list_suffix_names="${list_suffix_names:+$list_suffix_names,}\"+.$val\""

            }
        done
        config_get list "$section" additional_destip_route
        for val in $list; do
            [ -n "$val" ] && {
                local rule_str=$(printf 'IP-CIDR,%s,%s' "$val" "$name")
                rules_array="${rules_array:+$rules_array,}\"$rule_str\""
            }
        done
    }

    config_foreach _parse_single_proxy proxies

    selectedRuleSets="{${selectedRuleSets%,}}"
    proxies="[${proxies:-}]"
    rules_array="[${rules_array:-}]"
    list_rulesets_names="[${list_rulesets_names:-}]"
    list_suffix_names="[${list_suffix_names:-}]"

    echo "$rules_array" > "$file_rules"
    echo "$selectedRuleSets" > "$file_rulesets"
    echo "$proxies" > "$file_proxies"
    echo "$list_rulesets_names" > "$file_rulesets_names"
    echo "$list_suffix_names" > "$file_proxies_names"
}

handle_proxy_group_section() {
    local ruleset_content="$1"
    local file_rules="$2"
    local file_rulesets="$3"
    local file_proxygroups="$4"
    local file_rulesets_names="$5"
    local file_proxies_names="$6"
    local proxy_groups=""
    local rules_array=""
    local proxy_groups_rulesets=""
    local list_rulesets_names=""
    local list_suffix_names=""

    # shellcheck disable=SC2317  # Called via config_foreach
    _parse_proxy_group() {
        local section="$1"
        local name
        local proxies_list providers_list group_type strategy check_url interval check_timeout max_failed_times tolerance lazy
        local filter exclude_filter exclude_type expected_status
        local enabled_list list_update_interval use_proxy_group_for_list_update list val
        local domain_list cidr_list

        config_get name "$section" name
        [ -z "$name" ] && { log 1 "Skip proxy_group without name: $section" "⚠️"; return; }

        config_get proxies_list "$section" proxies
        config_get providers_list "$section" providers
        [ -z "$proxies_list" ] && [ -z "$providers_list" ] && { log 1 "Skip empty proxy_group $name" "⚠️"; return; }

        config_get group_type "$section" group_type
        config_get strategy "$section" strategy
        config_get check_url "$section" check_url
        config_get expected_status "$section" expected_status
        config_get interval "$section" interval
        config_get check_timeout "$section" check_timeout
        config_get max_failed_times "$section" max_failed_times
        config_get lazy "$section" lazy
        config_get tolerance "$section" tolerance
        config_get filter "$section" filter
        config_get exclude_filter "$section" exclude_filter
        config_get exclude_type "$section" exclude_type
        config_get enabled_list "$section" enabled_list
        config_get list_update_interval "$section" list_update_interval
        config_get_bool use_proxy_group_for_list_update "$section" use_proxy_group_for_list_update 0

        [ -z "$max_failed_times" ] && max_failed_times=$DEFAULT_MAX_FAILED_TIMES
        [ -z "$interval" ] && interval=$DEFAULT_HEALTHCHECK_INTERVAL
        [ -z "$check_timeout" ] && check_timeout=$DEFAULT_HEALTHCHECK_TIMEOUT
        [ -z "$list_update_interval" ] && list_update_interval=$DEFAULT_RULESET_INTERVAL
        [ -z "$expected_status" ] && expected_status=$DEFAULT_HEALTHCHECK_RESULT

        local escaped_proxies escaped_providers
        [ -n "$proxies_list" ] && escaped_proxies=$(echo "$proxies_list" | trim | list_to_json_array)
        [ -n "$providers_list" ] && escaped_providers=$(echo "$providers_list" | trim | list_to_json_array)

        local group_json="{\"name\":\"$(json_escape "$name")\",\
                        \"type\":\"$(json_escape "$group_type")\",\
                        \"url\":\"$(json_escape "$check_url")\",\
                        \"expected-status\":$expected_status,\
                        \"interval\":$interval,\
                        \"timeout\":$check_timeout,\
                        \"max-failed-times\":$max_failed_times,\
                        \"lazy\":$(ucibool_to_yaml_bool "$lazy")"

        [ "$group_type" = "url-test" ] && group_json="$group_json,\"tolerance\":\"$tolerance\""
        [ "$group_type" = "load-balance" ] && group_json="$group_json,\"strategy\":\"$(json_escape "$strategy")\""

        [ -n "$escaped_proxies" ] && group_json="$group_json,\"proxies\":[$escaped_proxies]"
        [ -n "$escaped_providers" ] && group_json="$group_json,\"use\":[$escaped_providers]"
        [ -n "$filter" ] && group_json="$group_json,\"filter\":\"$(json_escape "$filter")\""
        [ -n "$exclude_filter" ] && group_json="$group_json,\"exclude-filter\":\"$(json_escape "$exclude_filter")\""
        [ -n "$exclude_type" ] && group_json="$group_json,\"exclude-type\":\"$(json_escape "$exclude_type")\""
        group_json="$group_json}"

        proxy_groups="${proxy_groups:+$proxy_groups,}$group_json"

        local added_rulesets="|"
        for ruleset in $enabled_list; do
            if echo "$added_rulesets" | grep -qF "|$ruleset|"; then
                log 1 "Skipping duplicated ruleset: $ruleset" "⚠️"
                continue
            fi

            local line r_name yaml behavior format url proxy
            line=$(echo "$ruleset_content" | grep -F "|$ruleset|" | head -n 1)
            if [ -n "$line" ]; then
                local rest
                r_name="${line%%|*}"
                rest="${line#*|}"
                yaml="${rest%%|*}"
                rest="${rest#*|}"
                behavior="${rest%%|*}"
                rest="${rest#*|}"
                format="${rest%%|*}"
                url="${rest#*|}"
                # shellcheck disable=SC2249
                case "$r_name" in \#*) continue ;; esac

                local rule_str=$(printf 'RULE-SET,%s,%s' "$ruleset" "$name")
                rules_array="${rules_array:+$rules_array,}\"$rule_str\""

                [ "$use_proxy_group_for_list_update" -eq 1 ] && proxy="$name" || proxy=$DEFAULT_PROXY
                proxy_groups_rulesets="${proxy_groups_rulesets}\"$ruleset\":{\"url\":\"$(json_escape "$url")\",\"behavior\":\"$(json_escape "$behavior")\",\"format\":\"$(json_escape "$format")\",\"proxy\":\"$(json_escape "$proxy")\",\"interval\":$list_update_interval,\"type\":\"http\"},"
                added_rulesets="$added_rulesets$ruleset|"

                if [ "$behavior" = "domain" ]; then
                    list_rulesets_names="${list_rulesets_names:+$list_rulesets_names,}\"rule-set:$ruleset\""
                fi
            fi
        done

        config_get domain_list "$section" custom_enabled_domain_list
        for line in $domain_list; do
            local clean_line=$(echo "$line" | trim)
            if [ -n "$clean_line" ]; then
                local rng_name=$(printf "%s" "$clean_line" | md5_str )
                case "$clean_line" in
                    http://*|https://*)
                        [ "$use_proxy_for_list_update" -eq 1 ] && proxy="$name" || proxy=$DEFAULT_PROXY
                        proxy_groups_rulesets="${proxy_groups_rulesets}\"$rng_name\":{\"url\":\"$(json_escape "$clean_line")\",\"behavior\":\"domain\",\"format\":\"mrs\",\"proxy\":\"$proxy\",\"interval\":$list_update_interval,\"type\":\"http\"},"
                    ;;
                *)
                    if [ -f "$clean_line" ]; then
                        local escaped_path=$(json_escape "$clean_line")
                        safe_paths_add "$escaped_path"
                        [ "$use_proxy_for_list_update" -eq 1 ] && proxy="$name" || proxy=$DEFAULT_PROXY
                        proxy_groups_rulesets="${proxy_groups_rulesets}\"$rng_name\":{\"path\":\"$escaped_path\",\"behavior\":\"domain\",\"format\":\"mrs\",\"type\":\"file\"},"
                    else
                        log 1 "Incorrect value in custom domain list: $clean_line" "⚠️"
                        continue
                    fi
                    ;;
                esac

                local rule_str=$(printf 'RULE-SET,%s,%s' "$rng_name" "$name")
                rules_array="${rules_array:+$rules_array,}\"$rule_str\""
                list_rulesets_names="${list_rulesets_names:+$list_rulesets_names,}\"rule-set:$ruleset\""
            fi
        done

        config_get cidr_list "$section" custom_enabled_cidr_list
        for line in $cidr_list; do
            local clean_line=$(echo "$line" | trim)
            if [ -n "$clean_line" ]; then
                local rng_name=$(printf "%s" "$clean_line" | md5_str )
                case "$clean_line" in
                    http://*|https://*)
                        [ "$use_proxy_for_list_update" -eq 1 ] && proxy="$name" || proxy=$DEFAULT_PROXY
                        proxy_groups_rulesets="${proxy_groups_rulesets}\"$rng_name\":{\"url\":\"$(json_escape "$clean_line")\",\"behavior\":\"ipcidr\",\"format\":\"mrs\",\"proxy\":\"$proxy\",\"interval\":$list_update_interval,\"type\":\"http\"},"
                    ;;
                *)
                    if [ -f "$clean_line" ]; then
                        local escaped_path=$(json_escape "$clean_line")
                        safe_paths_add "$escaped_path"
                        [ "$use_proxy_for_list_update" -eq 1 ] && proxy="$name" || proxy=$DEFAULT_PROXY
                        proxy_groups_rulesets="${proxy_groups_rulesets}\"$rng_name\":{\"path\":\"$escaped_path\",\"behavior\":\"ipcidr\",\"format\":\"mrs\",\"type\":\"file\"},"
                    else
                        log 1 "Incorrect value in custom cidr list: $clean_line" "⚠️"
                        continue
                    fi
                    ;;
                esac

                local rule_str=$(printf 'RULE-SET,%s,%s' "$rng_name" "$name")
                rules_array="${rules_array:+$rules_array,}\"$rule_str\""
            fi
        done

        config_get list "$section" additional_srcip_route
        for val in $list; do
            [ -n "$val" ] && {
                local rule_str=$(printf 'SRC-IP-CIDR,%s,%s' "$val" "$name")
                rules_array="${rules_array:+$rules_array,}\"$rule_str\""
            }
        done

        config_get list "$section" additional_domain_route
        for val in $list; do
            [ -n "$val" ] && {
                local rule_str=$(printf 'DOMAIN-SUFFIX,%s,%s' "$val" "$name")
                rules_array="${rules_array:+$rules_array,}\"$rule_str\""
                list_suffix_names="${list_suffix_names:+$list_suffix_names,}\"+.$val\""
            }
        done

        config_get list "$section" additional_destip_route
        for val in $list; do
            [ -n "$val" ] && {
                local rule_str=$(printf 'IP-CIDR,%s,%s' "$val" "$name")
                rules_array="${rules_array:+$rules_array,}\"$rule_str\""
            }
        done
    }

    config_foreach _parse_proxy_group proxy_group

    proxy_groups_rulesets="{${proxy_groups_rulesets%,}}"


    proxy_groups="[${proxy_groups:-}]"
    rules="[${rules_array:-}]"
    list_rulesets_names="[${list_rulesets_names:-}]"
    list_suffix_names="[${list_suffix_names:-}]"

    echo "$rules" > "$file_rules"
    echo "$proxy_groups_rulesets" > "$file_rulesets"
    echo "$proxy_groups" > "$file_proxygroups"
    echo "$list_rulesets_names" > "$file_rulesets_names"
    echo "$list_suffix_names" > "$file_proxies_names"
}

handle_proxy_provider_section() {
    local result=""

    # shellcheck disable=SC2317
    # shellcheck disable=SC2329
    accumulate_proxy_provider() {
        local section="$1"
        local name url subscription_hwid_support interval proxy filter exclude_filter exclude_type
        local health_check health_check_url health_check_interval health_check_timeout health_check_expected_status health_check_lazy

        config_get name "$section" name
        config_get url "$section" subscription
        config_get interval "$section" update_interval
        config_get filter "$section" filter
        config_get exclude_filter "$section" exclude_filter
        config_get exclude_type "$section" exclude_type
        config_get proxy "$section" proxy

        { [ -z "$name" ] || [ -z "$url" ]; } && {
            log 1 "Skipping proxy_provider without name or subscription" "⚠️"
            return
        }

        [ -z "$interval" ] && interval=$DEFAULT_PROVIDERUPDATE_INTERVAL
        [ -z "$proxy" ] && proxy=$DEFAULT_PROXY

        local entry="\"type\":\"http\",\"url\":\"$(json_escape "$url")\",\"interval\":$interval,\"proxy\":$proxy"
        [ -n "$filter" ] && entry="$entry,\"filter\":\"$(json_escape "$filter")\""
        [ -n "$exclude_filter" ] && entry="$entry,\"exclude-filter\":\"$(json_escape "$exclude_filter")\""
        [ -n "$exclude_type" ] && entry="$entry,\"exclude-type\":\"$(json_escape "$exclude_type")\""

        config_get_bool subscription_hwid_support "$section" subscription_hwid_support 0
        if [ "$subscription_hwid_support" -eq 1 ]; then
            entry="$entry,\"header\":{\
            \"x-hwid\": \"$(hwid_generate)\",\
            \"x-device-os\":\"$(get_os_name)\",\
            \"x-ver-os\":\"$(get_os_version)\",\
            \"x-device-model\":\"$(get_hw_model)\",\
            }"
        fi

        config_get_bool health_check "$section" health_check 0
        if [ "$health_check" -eq 1 ]; then
            config_get health_check_expected_status "$section" health_check_expected_status
            config_get health_check_url "$section" health_check_url
            config_get health_check_interval "$section" health_check_interval
            config_get health_check_timeout "$section" health_check_timeout
            config_get health_check_lazy "$section" health_check_lazy

            [ -z "$health_check_interval" ] && health_check_interval=$DEFAULT_HEALTHCHECK_INTERVAL
            [ -z "$health_check_timeout" ] && health_check_timeout=$DEFAULT_HEALTHCHECK_TIMEOUT
            [ -z "$health_check_url" ] && health_check_url=$DEFAULT_HEALTHCHECK_URL
            [ -z "$health_check_expected_status" ] && health_check_expected_status=$DEFAULT_HEALTHCHECK_RESULT

            entry="$entry,\"health-check\":{\
            \"enable\":true,\
            \"lazy\":$(ucibool_to_yaml_bool "$health_check_lazy"),\
            \"url\":\"$(json_escape "$health_check_url")\",\
            \"expected-status\":$health_check_expected_status,\
            \"interval\":$health_check_interval,\
            \"timeout\":$health_check_timeout\
            }"
        fi

        entry="{$entry}"

        result="$result\"$(json_escape "$name")\":$entry,"
    }

    config_foreach accumulate_proxy_provider proxy_provider

    result="{${result%,}}"

    echo "$result"
}

handle_block_rule_section() {
    local blocklist_content="$1"
    local file_rules="$2"
    local file_rulesets="$3"
    local rules_array=""
    local selected_rule_sets=""

    local enabled_blocklist
    config_get enabled_blocklist block_rules enabled_blocklist
    config_get proxy block_rules proxy

    [ -z "$proxy" ] && proxy=$DEFAULT_PROXY

    local added_blocklists="|"
    local val
    for val in $enabled_blocklist; do
        if echo "$added_blocklists" | grep -qF "|$val|"; then
            log 1 "Skipping duplicated ruleset: $val" "⚠️"
            continue
        fi

        local line name yamlName behavior format url
        line=$(echo "$blocklist_content" | grep -F "|$val|" | head -n 1)
        if [ -n "$line" ]; then
            local rest
            name="${line%%|*}"
            rest="${line#*|}"
            yamlName="${rest%%|*}"
            rest="${rest#*|}"
            behavior="${rest%%|*}"
            rest="${rest#*|}"
            format="${rest%%|*}"
            url="${rest#*|}"
            # shellcheck disable=SC2249
            case "$name" in \#*) continue ;; esac

            local rule_str=$(printf 'RULE-SET,%s,REJECT' "$yamlName")
            rules_array="${rules_array:+$rules_array,}\"$rule_str\""

            selected_rule_sets="${selected_rule_sets}\"$yamlName\":{\"url\":\"$(json_escape "$url")\",\"behavior\":\"$(json_escape "$behavior")\",\"format\":\"$(json_escape "$format")\",\"proxy\":\"$proxy\",\"interval\":$DEFAULT_RULESET_INTERVAL,\"type\":\"http\"},"
            added_blocklists="$added_blocklists$val|"
        else
            log 1 "Blocklist '$val' can't be found in $blocklist_content" "⚠️"
        fi
    done

    local additional_domain_blockroute additional_destip_blockroute

    config_get additional_domain_blockroute block_rules additional_domain_blockroute
    local domain_val
    for domain_val in $additional_domain_blockroute; do
        [ -n "$domain_val" ] && {
            local rule_str=$(printf 'DOMAIN-SUFFIX,%s,REJECT' "$domain_val")
            rules_array="${rules_array:+$rules_array,}\"$rule_str\""
        }
    done

    config_get additional_destip_blockroute block_rules additional_destip_blockroute
    local ip_val
    for ip_val in $additional_destip_blockroute; do
        [ -n "$ip_val" ] && {
            local rule_str=$(printf 'IP-CIDR,%s,REJECT' "$ip_val")
            rules_array="${rules_array:+$rules_array,}\"$rule_str\""
        }
    done

    selected_rule_sets="{${selected_rule_sets%,}}"
    rules="[${rules_array:-}]"

    echo "$rules" > "$file_rules"
    echo "$selected_rule_sets" > "$file_rulesets"
}

handle_direct_rule_section() {
    local ruleset_content="$1"
    local file_rules="$2"
    local file_rulesets="$3"
    local rules_array=""
    local direct_rulesets=""

    local proxy additional_domain_direct additional_domain_keyword_direct additional_domain_regex_direct
    local additional_srcip_direct additional_destip_direct
    local list_update_interval enabled_list
    local domain_list cidr_list


    config_get list_update_interval direct_rules list_update_interval
    config_get enabled_list direct_rules enabled_list
    config_get proxy direct_rules proxy

    [ -z "$list_update_interval" ] && list_update_interval=$DEFAULT_RULESET_INTERVAL
    [ -z "$proxy" ] && proxy=$DEFAULT_PROXY

    local added_rulesets="|"
    for ruleset in $enabled_list; do
        if echo "$added_rulesets" | grep -qF "|$ruleset|"; then
            log 1 "Skipping duplicated ruleset: $ruleset" "⚠️"
            continue
        fi

        local line r_name yaml behavior format url proxy
        line=$(echo "$ruleset_content" | grep -F "|$ruleset|" | head -n 1)
        if [ -n "$line" ]; then
            local rest
            r_name="${line%%|*}"
            rest="${line#*|}"
            # shellcheck disable=SC2034
            yaml="${rest%%|*}"
            rest="${rest#*|}"
            behavior="${rest%%|*}"
            rest="${rest#*|}"
            format="${rest%%|*}"
            url="${rest#*|}"
            # shellcheck disable=SC2249
            case "$r_name" in \#*) continue ;; esac

            local rule_str=$(printf 'RULE-SET,%s,%s' "$ruleset" "$DEFAULT_RULESET_PROXY")
            rules_array="${rules_array:+$rules_array,}\"$rule_str\""

            direct_rulesets="${direct_rulesets}\"$ruleset\":{\"url\":\"$(json_escape "$url")\",\"behavior\":\"$(json_escape "$behavior")\",\"format\":\"$(json_escape "$format")\",\"proxy\":\"$proxy\",\"interval\":$list_update_interval,\"type\":\"http\"},"
            added_rulesets="$added_rulesets$ruleset|"
        fi
    done

    config_get domain_list direct_rules custom_enabled_domain_list
    for line in $domain_list; do
        local clean_line=$(echo "$line" | trim)
        if [ -n "$clean_line" ]; then
            local rng_name=$(printf "%s" "$clean_line" | md5_str )
            case "$clean_line" in
                http://*|https://*)
                    direct_rulesets="${direct_rulesets}\"$rng_name\":{\"url\":\"$(json_escape "$clean_line")\",\"behavior\":\"domain\",\"format\":\"mrs\",\"proxy\":\"$proxy\",\"interval\":$list_update_interval,\"type\":\"http\"},"
                ;;
            *)
                if [ -f "$clean_line" ]; then
                    local escaped_path=$(json_escape "$clean_line")
                    safe_paths_add "$escaped_path"
                    direct_rulesets="${direct_rulesets}\"$rng_name\":{\"path\":\"$escaped_path\",\"behavior\":\"domain\",\"format\":\"mrs\",\"type\":\"file\"},"
                else
                    log 1 "Incorrect value in custom domain list: $clean_line" "⚠️"
                    continue
                fi
                ;;
            esac
            local rule_str=$(printf 'RULE-SET,%s,%s' "$rng_name" "$DEFAULT_RULESET_PROXY")
            rules_array="${rules_array:+$rules_array,}\"$rule_str\""
        fi
    done

    config_get cidr_list direct_rules custom_enabled_cidr_list
    for line in $cidr_list; do
        local clean_line=$(echo "$line" | trim)
        if [ -n "$clean_line" ]; then
            local rng_name=$(printf "%s" "$clean_line" | md5_str )
            case "$clean_line" in
                http://*|https://*)
                    direct_rulesets="${direct_rulesets}\"$rng_name\":{\"url\":\"$(json_escape "$clean_line")\",\"behavior\":\"ipcidr\",\"format\":\"mrs\",\"proxy\":\"$proxy\",\"interval\":$list_update_interval,\"type\":\"http\"},"
                ;;
            *)
                if [ -f "$line" ]; then
                    local escaped_path=$(json_escape "$clean_line")
                    safe_paths_add "$escaped_path"
                    direct_rulesets="${direct_rulesets}\"$rng_name\":{\"path\":\"$escaped_path\",\"behavior\":\"ipcidr\",\"format\":\"mrs\",\"type\":\"file\"},"
                else
                    log 1 "Incorrect value in custom cidr list: $clean_line" "⚠️"
                    continue
                fi
                ;;
            esac
            local rule_str=$(printf 'RULE-SET,%s,%s' "$rng_name" "$DEFAULT_RULESET_PROXY")
            rules_array="${rules_array:+$rules_array,}\"$rule_str\""
        fi
    done

    config_get additional_domain_direct direct_rules additional_domain_direct
    local val
    for val in $additional_domain_direct; do
        [ -n "$val" ] && {
            local rule_str=$(printf 'DOMAIN-SUFFIX,%s,DIRECT' "$val")
            rules_array="${rules_array:+$rules_array,}\"$rule_str\""
        }
    done

    config_get additional_domain_keyword_direct direct_rules additional_domain_keyword_direct
    for val in $additional_domain_keyword_direct; do
        [ -n "$val" ] && {
            local rule_str=$(printf 'DOMAIN-KEYWORD,%s,DIRECT' "$val")
            rules_array="${rules_array:+$rules_array,}\"$rule_str\""
        }
    done

    config_get additional_domain_regex_direct direct_rules additional_domain_regex_direct
    for val in $additional_domain_regex_direct; do
        [ -n "$val" ] && {
            local rule_str=$(printf 'DOMAIN-REGEX,%s,DIRECT' "$val")
            rules_array="${rules_array:+$rules_array,}\"$rule_str\""
        }
    done

    config_get additional_srcip_direct direct_rules additional_srcip_direct
    for val in $additional_srcip_direct; do
        [ -n "$val" ] && {
            local rule_str=$(printf 'SRC-IP-CIDR,%s,DIRECT' "$val")
            rules_array="${rules_array:+$rules_array,}\"$rule_str\""
        }
    done

    config_get additional_destip_direct direct_rules additional_destip_direct
    for val in $additional_destip_direct; do
        [ -n "$val" ] && {
            local rule_str=$(printf 'IP-CIDR,%s,DIRECT' "$val")
            rules_array="${rules_array:+$rules_array,}\"$rule_str\""
        }
    done

    direct_rulesets="{${direct_rulesets%,}}"
    rules_array="[${rules_array:-}]"

    echo "$rules_array" > "$file_rules"
    echo "$direct_rulesets" > "$file_rulesets"
}

handle_mixed_port_rules_section() {
    local exit_rule
    local rules rule_str
    config_get exit_rule mixed_port_rules exit_rule

    if [ "$exit_rule" = "BY RULES" ]; then
        rules="[]"
    else
        rule_str=$(printf 'IN-TYPE,SOCKS/HTTP,%s' "${exit_rule:-$DEFAULT_PROXY}")
        rules="[\"${rule_str:-}\"]"
    fi

    echo "$rules"
}

handle_final_rule_section() {
    local exit_rule
    local rules
    config_get exit_rule final_rules exit_rule

    local rule_str=$(printf 'MATCH,%s' "${exit_rule:-$DEFAULT_PROXY}")

    rules="[\"${rule_str:-}\"]"

    echo "$rules"
}

core_generate_yaml() {
    local use_zashboard log_level tproxy_port unified_delay
    local use_mixed_port mixed_port
    local tcp_concurrent external_controller_port global_client_fingerprint
    local keep_alive_idle keep_alive_interval profile_store_selected profile_store_fake_ip
    local core_ntp_enabled core_ntp_interval core_ntp_server core_ntp_port core_ntp_write_system
    local dns_listen_port use_system_hosts fake_ip_filter_mode fake_ip_range dns_cache_max_size
    local etag_support global_ua
    local default_nameserver direct_nameserver proxy_server_nameserver nameserver custom_fake_ip_domains ignore_fake_ip_domains fake_ip_filter_data
    local rules_proxies rules_proxygroups rules_block rule_final rule_mixed rules_direct
    local proxies proxy_groups rule_providers proxy_providers names_suffixes_proxy_groups names_suffixes_proxies names_rulesets_proxy_groups names_rulesets_proxies
    local rulesets_direct rulesets_block rulesets_proxygroup rulesets_proxies
    local tmp_rules_file tmp_rulesets_path tmp_proxygroup_path tmp_proxies_path tmp_names_rulesets_path tmp_names_suffixes_path
    local block_rulesets_content rulesets_content
    local sniffer_enable sniffer_parse_pure_ip sniffer_skip_domain sniffer_skip_src_address sniffer_skip_dst_address sniffer_force_domain

    config_get use_zashboard proxy use_zashboard
    config_get log_level proxy log_level
    config_get tproxy_port proxy tproxy_port
    config_get use_mixed_port proxy use_mixed_port
    config_get mixed_port proxy mixed_port
    config_get_bool unified_delay proxy unified_delay
    unified_delay=$(ucibool_to_yaml_bool "$unified_delay")
    config_get_bool tcp_concurrent proxy tcp_concurrent
    tcp_concurrent=$(ucibool_to_yaml_bool "$tcp_concurrent")
    config_get external_controller_port proxy external_controller_port
    config_get global_client_fingerprint proxy global_client_fingerprint
    config_get keep_alive_idle proxy keep_alive_idle
    config_get keep_alive_interval proxy keep_alive_interval
    config_get global_ua proxy global_ua
    config_get_bool etag_support proxy etag_support
    etag_support=$(ucibool_to_yaml_bool "$etag_support")
    config_get_bool profile_store_selected proxy profile_store_selected
    profile_store_selected=$(ucibool_to_yaml_bool "$profile_store_selected")
    config_get_bool profile_store_fake_ip proxy profile_store_fake_ip
    profile_store_fake_ip=$(ucibool_to_yaml_bool "$profile_store_fake_ip")
    config_get_bool core_ntp_enabled proxy core_ntp_enabled
    core_ntp_enabled=$(ucibool_to_yaml_bool "$core_ntp_enabled")
    config_get core_ntp_server proxy core_ntp_server
    config_get core_ntp_port proxy core_ntp_port
    config_get core_ntp_interval proxy core_ntp_interval
    config_get_bool core_ntp_write_system proxy core_ntp_write_system
    core_ntp_write_system=$(ucibool_to_yaml_bool "$core_ntp_write_system")
    config_get dns_listen_port proxy dns_listen_port
    config_get dns_cache_max_size proxy dns_cache_max_size
    config_get_bool use_hosts proxy use_hosts
    use_hosts=$(ucibool_to_yaml_bool "$use_hosts")
    config_get_bool use_system_hosts proxy use_system_hosts
    use_system_hosts=$(ucibool_to_yaml_bool "$use_system_hosts")
    config_get fake_ip_filter_mode proxy fake_ip_filter_mode
    config_get fake_ip_range proxy fake_ip_range
    config_get_bool sniffer_enable proxy sniffer_enable
    sniffer_enable=$(ucibool_to_yaml_bool "$sniffer_enable")
    config_get_bool sniffer_parse_pure_ip proxy sniffer_parse_pure_ip
    sniffer_parse_pure_ip=$(ucibool_to_yaml_bool "$sniffer_parse_pure_ip")
    default_nameserver=$(simple_uci_list_to_json_arr proxy default_nameserver)
    direct_nameserver=$(simple_uci_list_to_json_arr proxy direct_nameserver)
    proxy_server_nameserver=$(simple_uci_list_to_json_arr proxy proxy_server_nameserver)
    nameserver=$(simple_uci_list_to_json_arr proxy nameserver)
    custom_fake_ip_domains=$(simple_uci_list_to_json_arr proxy custom_fake_ip_domains)
    ignore_fake_ip_domains=$(simple_uci_list_to_json_arr proxy ignore_fake_ip_domains)
    sniffer_force_domain=$(simple_uci_list_to_json_arr proxy sniffer_force_domain)
    sniffer_skip_domain=$(simple_uci_list_to_json_arr proxy sniffer_skip_domain)
    sniffer_skip_src_address=$(simple_uci_list_to_json_arr proxy sniffer_skip_src_address)
    sniffer_skip_dst_address=$(simple_uci_list_to_json_arr proxy sniffer_skip_dst_address)

    rule_mixed=$(handle_mixed_port_rules_section)
    rule_final=$(handle_final_rule_section)
    proxy_providers=$(handle_proxy_provider_section | jq .)

    # optimization: load files one time
    block_rulesets_content=$(cat "$RULESETS_BLOCKS_FILE")
    rulesets_content=$(cat "$RULESETS_FILE")

    tmp_rules_file=$(mktemp "$CORE_WORKDIR_PATH"/tmprulesdirect.XXXXXX)
    tmp_rulesets_path=$(mktemp "$CORE_WORKDIR_PATH"/tmprulesetsdirect.XXXXXX)
    handle_direct_rule_section "$rulesets_content" "$tmp_rules_file" "$tmp_rulesets_path"
    rules_direct=$(cat "$tmp_rules_file")
    rulesets_direct=$(cat "$tmp_rulesets_path")
    rm -f "$tmp_rules_file" "$tmp_rulesets_path"

    tmp_rules_file=$(mktemp "$CORE_WORKDIR_PATH"/tmprules.XXXXXX)
    tmp_rulesets_path=$(mktemp "$CORE_WORKDIR_PATH"/tmprulesets.XXXXXX)
    handle_block_rule_section "$block_rulesets_content" "$tmp_rules_file" "$tmp_rulesets_path"
    rules_block=$(cat "$tmp_rules_file" )
    rulesets_block=$(cat "$tmp_rulesets_path")
    rm -f "$tmp_rules_file" "$tmp_rulesets_path"

    #Creating files in RAM since ASH funcs can't return multiple values, neiter it can return values by reference (so we are going to write result in file)
    tmp_rules_file=$(mktemp "$CORE_WORKDIR_PATH"/tmprules.XXXXXX)
    tmp_rulesets_path=$(mktemp "$CORE_WORKDIR_PATH"/tmprulesets.XXXXXX)
    tmp_proxygroup_path=$(mktemp "$CORE_WORKDIR_PATH"/tmpproxygroups.XXXXXX)
    # Files for strings with names in json arrays (for Fake IP filter)
    tmp_names_rulesets_path=$(mktemp "$CORE_WORKDIR_PATH"/tmpproxygroupsrulesetsnames.XXXXXX)
    tmp_names_suffixes_path=$(mktemp "$CORE_WORKDIR_PATH"/tmpproxygroupssuffixesnames.XXXXXX)
    handle_proxy_group_section "$rulesets_content" "$tmp_rules_file" "$tmp_rulesets_path" "$tmp_proxygroup_path" "$tmp_names_rulesets_path" "$tmp_names_suffixes_path"
    rules_proxygroups=$(cat "$tmp_rules_file" )
    rulesets_proxygroup=$(cat "$tmp_rulesets_path")
    proxy_groups=$(cat "$tmp_proxygroup_path")
    names_rulesets_proxy_groups=$(cat "$tmp_names_rulesets_path")
    names_suffixes_proxy_groups=$(cat "$tmp_names_suffixes_path")
    rm -f "$tmp_rules_file" "$tmp_rulesets_path" "$tmp_proxygroup_path" "$tmp_names_rulesets_path" "$tmp_names_suffixes_path"

    #Creating files in RAM since ASH funcs can't return multiple values, neiter it can return values by reference (so we are going to write result in file)
    tmp_rules_file=$(mktemp "$CORE_WORKDIR_PATH"/tmprules.XXXXXX)
    tmp_rulesets_path=$(mktemp "$CORE_WORKDIR_PATH"/tmprulesets.XXXXXX)
    tmp_proxies_path=$(mktemp "$CORE_WORKDIR_PATH"/tmpproxies.XXXXXX)
    tmp_names_rulesets_path=$(mktemp "$CORE_WORKDIR_PATH"/tmpproxiesrulesetsnames.XXXXXX)
    tmp_names_suffixes_path=$(mktemp "$CORE_WORKDIR_PATH"/tmpproxiessuffixesnames.XXXXXX)
    handle_proxy_section "$rulesets_content" "$tmp_rules_file" "$tmp_rulesets_path" "$tmp_proxies_path" "$tmp_names_rulesets_path" "$tmp_names_suffixes_path"
    rules_proxies=$(cat "$tmp_rules_file")
    rulesets_proxies=$(cat "$tmp_rulesets_path")
    proxies=$(cat "$tmp_proxies_path")
    names_rulesets_proxies=$(cat "$tmp_names_rulesets_path")
    names_suffixes_proxies=$(cat "$tmp_names_suffixes_path")
    rm -f "$tmp_rules_file" "$tmp_rulesets_path" "$tmp_proxies_path" "$tmp_names_rulesets_path" "$tmp_names_suffixes_path"

    if [ "$fake_ip_filter_mode" = "whitelist" ]; then
        fake_ip_filter_data=$(jq -n \
            --arg custom "$custom_fake_ip_domains" \
            --arg nrpg "$names_rulesets_proxy_groups" \
            --arg nspg "$names_suffixes_proxy_groups" \
            --arg nrp "$names_rulesets_proxies" \
            --arg nsp "$names_suffixes_proxies" \
            '($custom | fromjson) + ($nrpg | fromjson) + ($nspg | fromjson) + ($nrp | fromjson) + ($nsp | fromjson)'
        )
    else
        fake_ip_filter_data=$ignore_fake_ip_domains
    fi

    proxies=$(echo "$proxies" | jq .)

    rule_providers=$(
        jq -n \
            --argjson rulesets_direct "$rulesets_direct" \
            --argjson rulesets_block "$rulesets_block" \
            --argjson rulesets_proxies "$rulesets_proxies" \
            --argjson rulesets_proxygroup "$rulesets_proxygroup" \
            'reduce [ $rulesets_direct, $rulesets_block, $rulesets_proxies, $rulesets_proxygroup ][] as $item ({}; . * $item)'
    )

    rules=$(jq -n \
        --arg rule_mixed "$rule_mixed" \
        --arg direct "$rules_direct" \
        --arg block "$rules_block" \
        --arg proxygroups "$rules_proxygroups" \
        --arg proxies "$rules_proxies" \
        --arg final "$rule_final" \
        '($rule_mixed | fromjson) + ($direct | fromjson) + ($block | fromjson) + ($proxygroups | fromjson) + ($proxies | fromjson) + ($final | fromjson) | map(select(length > 0))'
    )

    # Support for mixed port
    # Make sure call for this function handled after 'core_prepare_workdir' since file must be removed
    if [ "$use_mixed_port" -eq 1 ]; then
        cat <<EOF > "$OUTPUT_YAML_CONFIG_PATH"
allow-lan: true
mixed-port: $mixed_port

EOF
    fi

    if [ "$use_zashboard" -eq 1 ]; then
        cat <<EOF > "$OUTPUT_YAML_CONFIG_PATH"
external-ui-name: $DASHBOARD_NAME
external-ui: $DASHBOARD_PATH
external-ui-url: "$DASHBOARD_DEFAULT_URL"
EOF
    fi

    cat <<EOF >> "$OUTPUT_YAML_CONFIG_PATH"
mode: rule
ipv6: false
log-level: $log_level
tproxy-port: $tproxy_port
unified-delay: $unified_delay
tcp-concurrent: $tcp_concurrent
external-controller: 0.0.0.0:$external_controller_port
routing-mark: $NF_TABLE_FWMARK_PROXY
global-client-fingerprint: $global_client_fingerprint
global-ua: $global_ua
find-process-mode: off
geodata-mode: false
etag-support: $etag_support

keep-alive-idle: $keep_alive_idle
keep-alive-interval: $keep_alive_interval

profile:
  store-selected: $profile_store_selected
  store-fake-ip: $profile_store_fake_ip

ntp:
  enable: $core_ntp_enabled
  write-to-system: $core_ntp_write_system
  server: $core_ntp_server
  port: $core_ntp_port
  interval: $core_ntp_interval

dns:
  enable: true
  listen: 127.0.0.1:$dns_listen_port
  ipv6: false
  use-hosts: false
  use-system-hosts: $use_system_hosts
  enhanced-mode: fake-ip
  fake-ip-range: $fake_ip_range
  cache-max-size: $dns_cache_max_size
  default-nameserver: $default_nameserver
  nameserver: $nameserver
  proxy-server-nameserver: $proxy_server_nameserver
  direct-nameserver: $direct_nameserver
  respect-rules: true
  fake-ip-filter-mode: $fake_ip_filter_mode
  fake-ip-filter: $fake_ip_filter_data

sniffer:
  enable: $sniffer_enable
  parse-pure-ip: $sniffer_parse_pure_ip
  sniff:
    HTTP:
      ports: [$DEFAULT_HTTP_PORT, $DEFAULT_SECONDARY_HTTP_PORT_RANGE-$DEFAULT_SECONDARY_HTTP_PORT_RANGE_END]
      override-destination: true
    TLS:
      ports: [$DEFAULT_TLS_PORT, $DEFAULT_SECONDARY_TLS_PORT]
    QUIC:
      ports: [$DEFAULT_TLS_PORT, $DEFAULT_SECONDARY_TLS_PORT]
  skip-domain: $sniffer_skip_domain
  force-domain: $sniffer_force_domain
  skip-src-address: $sniffer_skip_src_address
  skip-dst-address: $sniffer_skip_dst_address

proxies: $proxies
proxy-groups: $proxy_groups
rule-providers: $rule_providers
proxy-providers: $proxy_providers
rules: $rules

EOF

    return 0;
}

rulesets_list_update() {
    local complete_url
    log 2 "Downloading RULE-SETs list file" "📥"
    complete_url=${INBUILD_RULESETS_FILES_DOWNLOAD_URL}/${RULESETS_FILENAME}
    curl --progress-bar -L -o "${CORE_WORKDIR_PATH}/${RULESETS_FILENAME}" "$complete_url" || {
        log 0 "Failed to download RULE-SETs list file." "❌"
        return 1
    }
    rm -f "$RULESETS_FILE"
    mv "${CORE_WORKDIR_PATH}/${RULESETS_FILENAME}" "$RULESETS_FILE"
    log 2 "RULE-SET list file was updated" "✅"

    log 2 "Downloading BLOCK RULE-SETs list file" "📥"
    complete_url=${INBUILD_RULESETS_FILES_DOWNLOAD_URL}/${RULESETS_BLOCKS_FILENAME}
    curl --progress-bar -L -o "${CORE_WORKDIR_PATH}/${RULESETS_BLOCKS_FILENAME}" "$complete_url" || {
        log 0 "Failed to download BLOCK RULE-SETs list file." "❌"
        return 1
    }
    rm -f "$RULESETS_BLOCKS_FILE"
    mv "${CORE_WORKDIR_PATH}/${RULESETS_BLOCKS_FILENAME}" "$RULESETS_BLOCKS_FILE"
    log 2 "BLOCK RULE-SETs list file was updated" "✅"

    return 0
}

core_prepare_workdir() {
    local res=1
    local current_hash=""
    local saved_hash=""
    local mihomo_persistent_temp_files

    log 2 "Preparing workdir $CORE_WORKDIR_PATH" "📁"

    if [ -d "$CORE_WORKDIR_PATH" ]; then
        if [ -f "$OUTPUT_YAML_CONFIG_PATH" ]; then
            current_hash=$(uci show "$PROGNAME" | grep -vE "^${PROGNAME}\.settings." | md5_str )
            saved_hash=$(cat "$CORE_WORKDIR_UCI_HASH_PATH" 2>/dev/null || echo "")
            if [ "$current_hash" != "$saved_hash" ]; then
                log 2 "Outdated $OUTPUT_YAML_CONFIG_PATH was found. Will be recreated." "🐱"
                rm -f "$OUTPUT_YAML_CONFIG_PATH"
                echo "$current_hash" > "$CORE_WORKDIR_UCI_HASH_PATH"
            else
                log 2 "Up-to-date $OUTPUT_YAML_CONFIG_PATH was found. Will not be modified." "🐱"
                res=0
            fi
        fi
    else
        mkdir -p "$CORE_WORKDIR_PATH"
    fi

    config_get mihomo_persistent_temp_files settings mihomo_persistent_temp_files
    if [ "$mihomo_persistent_temp_files" -eq 1 ] && [ ! -L "$CORE_WORKDIR_RULES_PATH" ]; then
        log 2 "Generating symlink $DEFAULT_SYMLINKDIR_RULESETS -> $CORE_WORKDIR_RULES_PATH" "📁"
        rm -rf "$CORE_WORKDIR_RULES_PATH"
        [ ! -d "$DEFAULT_SYMLINKDIR_RULESETS" ] &&  mkdir -p "$DEFAULT_SYMLINKDIR_RULESETS"
        ln -sf "$DEFAULT_SYMLINKDIR_RULESETS" "$CORE_WORKDIR_RULES_PATH"
    elif  [ "$mihomo_persistent_temp_files" -eq 0 ] && [ -L "$CORE_WORKDIR_RULES_PATH" ]; then
        log 2 "Removing old symlink $DEFAULT_SYMLINKDIR_RULESETS -> $CORE_WORKDIR_RULES_PATH" "📁"
        rm -rf "$DEFAULT_SYMLINKDIR_RULESETS"
        rm -rf "$CORE_WORKDIR_RULES_PATH"
    fi

    return "$res"
}

detect_arch() {
    local arch_raw
    arch_raw=$(get_os_arch)

    case "$arch_raw" in
        aarch64_*) echo "arm64" ;;
        mips_*)
            if [ "${arch_raw#*hardfloat}" != "$arch_raw" ]; then
                echo "mips-hardfloat"
            else
                echo "mips-softfloat"
            fi
            ;;
        mipsel_*)
            if [ "${arch_raw#*hardfloat}" != "$arch_raw" ]; then
                echo "mipsle-hardfloat"
            else
                echo "mipsle-softfloat"
            fi
            ;;
        mips64_*) echo "mips64" ;;
        mips64el_*) echo "mips64le" ;;
        x86_64) echo "amd64-v3" ;;
        i386_*) echo "386" ;;
        riscv64_*) echo "riscv64" ;;
        loongarch64_*) echo "loong64-abi2" ;;
        *_neon-vfp*) echo "armv7" ;;
        *_neon* | *_vfp*) echo "armv6" ;;
        arm_*) echo "armv5" ;;
        *) echo "amd64-v3" ;;
    esac
}

get_latest_version() {
    local check_url="$1"
    local download_url latest_ver
    download_url=$(curl -sL "$check_url" | \
        jq -r '.assets[] | select(.name == "version.txt") | .browser_download_url')

    latest_ver=$(curl -sL "$download_url" | tr -d '\r\n' | sed -n 1p) || {
        log 0 "Failed to get latest version" "❌"
        return 1
    }
    echo "$latest_ver"
}

core_download() {
    local arch file_name base_url param_version download_url
    download_url="$1"
    param_version="$2"

    arch=$(detect_arch)
    mkdir -p "$CORE_WORKDIR_PATH"

    file_name="mihomo-linux-${arch}-${param_version}.gz"
    base_url="${download_url}/${param_version}/${file_name}"

    log 2 "Downloading mihomo binary" "📥"
    curl --progress-bar -L -o "${CORE_WORKDIR_PATH}/mihomo.gz" "$base_url" || {
        log 0 "Failed to download file." "❌"
        return 1
    }

    log 2 "Extracting to $CORE_PATH" "⬇️"
    gunzip -c "${CORE_WORKDIR_PATH}/mihomo.gz" > "$CORE_PATH" || {
        log 0 "Failed to extract file." "❌"
        return 1
    }

    log 2 "Mihomo installed at $CORE_PATH" "🚀"

    if ! chmod +x "$CORE_PATH"; then
        log 0 "Failed to set executable permissions: $CORE_PATH" "❌"
    fi

    log 2 "Cleaning up temporary files" "🧹"
    if ! rm -f "${CORE_WORKDIR_PATH}/mihomo.gz"; then
        log 0 "Failed to clean up temporary file: ${CORE_WORKDIR_PATH}/mihomo.gz" "❌"
    fi
}

core_remove() {
    if [ ! -x "$CORE_PATH" ]; then
        log 0 "Mihomo is not installed." "❌"
        return 1
    else
        if rm -f "$CORE_PATH"; then
            log 2 "Mihomo is removed." "✅"
            return 0
        else
            log 0 "Failed to remove Mihomo binary: $CORE_PATH" "❌"
            return 1
        fi
    fi
}

core_update() {
    local cur_ver latest_ver mihomo_cron_update_telegram_notify
    local check_url download_url

    log 2 "Checking for Mihomo updates..." "🔄"

    cur_ver=$(info_mihomo)
    if [ -z "$cur_ver" ]; then
        log 0 "Update process can't be finished." "❌"
        return 1
    fi

    check_url="$CORE_RELEASE_CHECK_URL"
    download_url="$CORE_RELEASE_DOWNLOAD_URL"

    latest_ver=$(get_latest_version "$check_url") || {
        log 0 "Failed to get latest version" "❌"
        return 1
    }

    if [ -z "$latest_ver" ]; then
       log 0 "Error happened when trying to receive latest version data."
       log 0 "It may be due to a GitHub API rate limit or the release may not exist. Please check manually."
       log 0 "Failed to download core"
       return 1
    fi

    config_get_bool mihomo_cron_update_telegram_notify settings mihomo_cron_update_telegram_notify
    if [ "$cur_ver" = "$NO_DATA_STRING" ] || [ -z "$cur_ver" ]; then
        log 1 "Mihomo is not installed. Installing version $latest_ver." "⚠️"
        core_download "$download_url" "$latest_ver"
        if [ $? -eq 1 ]; then
            log 0 "Update process can't be finished." "❌"
            if [ "$mihomo_cron_update_telegram_notify" -eq 1 ]; then
                send_telegram "Mihomo core binary was missing. Install try for version $latest_ver failed."
            fi
            return 1
        fi
        if [ "$mihomo_cron_update_telegram_notify" -eq 1 ]; then
            send_telegram "Mihomo core binary was missing. Installed $latest_ver"
        fi
        return 0
    fi

    log 2 "Current Mihomo version: $cur_ver"
    log 2 "Latest Mihomo version: $latest_ver"

    if [ "$cur_ver" != "$latest_ver" ]; then
        log 2 "Removing current mihomo binary..." "⚠️"
        core_remove
        if [ $? -eq 1 ]; then
            log 0 "Update process can't be finished." "❌"
            return 1
        fi
        log 2 "Updating Mihomo to version $latest_ver" "⬆️"
        core_download "$download_url" "$latest_ver"
        if [ $? -eq 1 ]; then
            log 0 "Update process can't be finished." "❌"
            if [ "$mihomo_cron_update_telegram_notify" -eq 1 ]; then
                send_telegram "Mihomo core binary was updated. Install try for version: $cur_ver -> $latest_ver failed."
            fi
            return 1
        fi
        if [ "$mihomo_cron_update_telegram_notify" -eq 1 ]; then
            send_telegram "Mihomo core binary was updated. Version: $cur_ver -> $latest_ver"
        fi
    else
        if [ "$mihomo_cron_update_telegram_notify" -eq 1 ]; then
            send_telegram "Mihomo core binary is already up-to-date."
        fi
        log 2 "Mihomo is already up-to-date." "✅"
    fi

    return 0
}

send_telegram() {
    local message="$1"
    local token chat_id

    config_get token settings telegram_bot_token
    config_get chat_id settings telegram_chat_id

    if [ -z "$token" ] || [ -z "$chat_id" ]; then
        log 1 "Telegram: bot token or chat ID is not configured" "⚠️"
        return 1
    fi

    response=$(curl -s -w "\n%{http_code}" -X POST "https://api.telegram.org/bot${token}/sendMessage" \
        -d chat_id="$chat_id" \
        -d text="$message" \
        -d parse_mode="HTML" \
        -d disable_notification=true)

    local curl_exit=$?
    http_code=$(echo "$response" | tail -n1)

    if [ "$curl_exit" -ne 0 ]; then
        log 0 "Telegram: network error, curl exited with code $curl_exit" "❌"
        return 1
    fi

    if [ "$http_code" != "200" ]; then
        log 0 "Telegram: failed to send message (HTTP $http_code)" "❌"
        return 1
    fi

    return 0
}

cron_make_if_missing() {
    if [ ! -f "/etc/crontabs/root" ]; then
        touch "/etc/crontabs/root"
    fi
}

core_update_cron_check() {
    cron_make_if_missing
    if grep -qF "/usr/bin/${PROGNAME} core_update" /etc/crontabs/root; then
        return 0
    else
        return 1
    fi
}

core_update_cron_add() {
    cron_make_if_missing
    local mihomo_cron_update_string

    config_get mihomo_cron_update_string settings mihomo_cron_update_string

    if [ -z "$mihomo_cron_update_string" ]; then
        log 0 "Cron schedule string is empty! Cron job not added." "❌"
        return 1
    fi

    if core_update_cron_check > /dev/null; then
        log 1 "Core autoupdate cron job already exists." "ℹ️"
        return 0
    fi

    echo "$mihomo_cron_update_string /usr/bin/${PROGNAME} core_update" >> /etc/crontabs/root
    if /etc/init.d/cron enabled; then
        /etc/init.d/cron restart
        log 2 "Cron job added and service restarted" "✅"
    else
        log 2 "Cron job added (service not enabled)" "ℹ️"
    fi
    log 2 "Core autoupdate cron job added." "✅"
}

core_update_cron_remove() {
    cron_make_if_missing
    if core_update_cron_check > /dev/null; then
        sed -i '\|/usr/bin/justclash core_update|d' /etc/crontabs/root
        if /etc/init.d/cron enabled; then
            /etc/init.d/cron restart
            log 2 "Cron job added and service restarted" "✅"
        else
            log 2 "Cron job added (service not enabled)" "ℹ️"
        fi
        log 2 "Core autoupdate cron job removed." "🗑️"
    else
        log 2 "Core autoupdate cron job not found." "ℹ️"
    fi
}

core_autorestart_cron_check() {
    cron_make_if_missing
    if grep -qF "${INITD_PATH} reload" /etc/crontabs/root; then
        return 0
    else
        return 1
    fi
}

core_autorestart_cron_add() {
    cron_make_if_missing
    local mihomo_cron_autorestart_string

    config_get mihomo_cron_autorestart_string settings mihomo_cron_autorestart_string

    if [ -z "$mihomo_cron_autorestart_string" ]; then
        log 0 "Cron schedule string is empty! Cron job not added." "❌"
        return 1
    fi

    if core_autorestart_cron_check > /dev/null; then
        log 1 "Core autoupdate cron job already exists." "ℹ️"
        return 0
    fi

    echo "$mihomo_cron_autorestart_string ${INITD_PATH} reload" >> /etc/crontabs/root
    if /etc/init.d/cron enabled; then
        /etc/init.d/cron restart
        log 2 "Cron job added and service restarted" "✅"
    else
        log 2 "Cron job added (service not enabled)" "ℹ️"
    fi
}

core_autorestart_cron_remove() {
    cron_make_if_missing
    if core_autorestart_cron_check > /dev/null; then
        sed -i "/${INITD_PATH} reload/d" /etc/crontabs/root
        if /etc/init.d/cron enabled; then
            /etc/init.d/cron restart
            log 2 "Cron job added and service restarted" "✅"
        else
            log 2 "Cron job added (service not enabled)" "ℹ️"
        fi
        log 2 "Core autoupdate cron job removed." "🗑️"
    else
        log 2 "Core autoupdate cron job not found." "ℹ️"
    fi
}

diag_nft() {
    clog 2 "Checking for 'nft' command..."

    clog 2 "Verifying existence of NFTables table '$NF_TABLE_NAME'..."
    if ! nft list table ip "$NF_TABLE_NAME" >/dev/null 2>&1; then
        clog 0 "Table '$NF_TABLE_NAME' not found. Please create the required NFTables table."
        return 1
    fi

    clog 2 "Displaying current NFTables configuration:"
    nft list table ip "$NF_TABLE_NAME"

    clog 2 "NFTables check completed successfully."

    return 0
}

diag_route() {
    clog 2 "Verifying existence of route rule..."
    if ! ip rule list | grep -qF "fwmark ${NF_TABLE_FWMARK_FINAL} lookup $NF_ROUTE_TABLE"; then
        clog 0 "Route rule 'ip rule add fwmark ""$NF_TABLE_FWMARK_FINAL"" table $NF_ROUTE_TABLE' is missing!"
    fi
    ip rule list

    if ! ip route show table "$NF_ROUTE_TABLE" | grep -Eq "local (default|0\.0\.0\.0/0) dev lo"; then
         clog 0 "Route table $NF_ROUTE_TABLE is incorrect!"
    fi
    ip route show table "$NF_ROUTE_TABLE"
}

diag_proxy_resolver() {
    if [ -z "$1" ]; then
        log 1 "Usage: diag_proxy_resolver <domain>"
        return 1
    fi
    local target="$1"
    local dns_listen_port
    config_get dns_listen_port proxy dns_listen_port

    clog 2 "Testing Fake IP DNS resolution..."

    local ip_output
    ip_output=$(nslookup "$target" 127.0.0.1:"$dns_listen_port" 2>/dev/null)
    local exit_code=$?

    local ips
    ips=$(echo "$ip_output" | awk '/^Address: / {print $2}')

    if [ "$exit_code" -ne 0 ] || [ -z "$ips" ]; then
        clog 0 "Fake IP DNS query failed"
        return 1
    else
        echo "$ips"
        clog 2 "Fake IP DNS query successful"
        return 0
    fi
}

diag_external_resolver() {
    if [ -z "$1" ] || [ -z "$2" ]; then
        log 1 "Usage: diag_external_resolver <domain> <dns resolver>"
        return 1
    fi
    local target="$1"
    local resolver="$2"
    local ip_output exit_code

    clog 2 "Testing DNS resolution..."

    ip_output=$(nslookup "$target" "$resolver" 2>/dev/null)
    exit_code=$?

    ips=$(echo "$ip_output" | awk '/^Address: / {print $2}')

    if [ "$exit_code" -ne 0 ] || [ -z "$ips" ]; then
        clog 0 "External DNS query failed"
        return 1
    else
        clog 2 "$ips"
        clog 2 "External DNS query successful"
        return 0
    fi
}

diag_icmp() {
    local target="${1}"
    local count="${2}"
    if [ -z "$target" ] || [ -z "$count" ]; then
        clog 1 "Usage: diag_icmp <target> <count>"
        return 1
    fi
    local timeout=2
    local ping_output

    ping_output=$(ping -c "$count" -W "$timeout" "$target" 2>&1)
    local exit_code=$?

    if [ "$exit_code" -eq 0 ]; then
        clog 2 "Ping to ${target} is successful"
        clog 2 "$ping_output"
    else
        clog 0 "Ping to ${target} is failed"
        clog 0 "$ping_output"
    fi
}

diag_report() {
    local running autoload
    running=$(service "$PROGNAME" status)
    if service "$PROGNAME" enabled; then
        autoload="yes"
    else
        autoload="no"
    fi

cat <<EOF
----------------------------
$PROGNAME diagnostic report:
----------------------------

-> Basic:
Device:  $(info_device)
OpenWRT: $(info_openwrt)
Service: $(info_package)
Mihomo:  $(info_mihomo)

-> Status:
Active:  $running
Load:  $autoload

-> NFT Tables:
$(diag_nft)

-> Routes:
$(diag_route)

-> ICMP $DIAG_IP_CHECK_PING_YANDEX :
$(diag_icmp "$DIAG_IP_CHECK_PING_YANDEX" 2)

-> ICMP $DIAG_IP_CHECK_PING_GOOGLE :
$(diag_icmp "$DIAG_IP_CHECK_PING_GOOGLE" 2)

-> DNS resolve $DIAG_RESOLVE_URL_YANDEX with proxy:
$(diag_proxy_resolver "$DIAG_RESOLVE_URL_YANDEX")

-> DNS resolve $DIAG_RESOLVE_URL_YANDEX with $DIAG_IP_CHECK_PING_YANDEX:
$(diag_external_resolver "$DIAG_RESOLVE_URL_YANDEX" "$DIAG_IP_CHECK_PING_YANDEX")

-> DNS resolve $DIAG_RESOLVE_URL_YANDEX with $DIAG_IP_CHECK_PING_GOOGLE:
$(diag_external_resolver "$DIAG_RESOLVE_URL_YANDEX" "$DIAG_IP_CHECK_PING_GOOGLE")

-> Zapret:
$(if [ -f "$ZAPRETINITD_FILEPATH" ]; then echo "Zapret detected."; else echo "No zapret installed."; fi)

-> ByeDPI:
$(if [ -f "$BYEDPI_FILEPATH" ]; then echo "ByeDPI detected."; else echo "No ByeDPI installed."; fi)

-> YoutubeUnblock:
$(if [ -f "$YOUTUBEUNBLOCK_FILEPATH" ]; then echo "YoutubeUnblock detected."; else echo "No YoutubeUnblock installed."; fi)

-> /etc/resolv.conf:
$(cat /etc/resolv.conf)

-> Network config:
$(uci show network)

-> DHCP config:
$(uci show dhcp)

-> Service config:
$(uci show "$PROGNAME")

EOF

}

config_show() {
    uci export "$PROGNAME"
}

config_reset() {
    if [ ! -f "$DEFAULT_CONFIG_PATH" ]; then
        clog 0 "Default config file is missing. Can't use restore functionality"
        return 1
    fi

    clog 2 "Restoring justclash settings..."

    rm -f "$CONFIG_BAK_PATH"

    if [ ! -f "$CONFIG_PATH" ]; then
        clog 0 "Current config file not found, nothing to backup"
    else
        if ! mv "$CONFIG_PATH" "$CONFIG_BAK_PATH"; then
            clog 0 "Failed to backup config file"
            return 1
        else
            clog  "Old config file can be found at path ${CONFIG_BAK_PATH}"
        fi
    fi

    if ! cp "$DEFAULT_CONFIG_PATH" "$CONFIG_PATH"; then
        clog 0 "Failed to restore default config"
        return 1
    fi

    clog 2 "Default settings will be applied at next service restart..."
    return 0
}

help() {
    cat << EOF
Usage: justclash <command> [args]

Service Management:
  start|run               Start the JustClash service.
  stop                    Stop the JustClash service.
  config_show             Show configuration in console
  config_reset            Reset configuration

Mihomo management Commands:
  core_update                     Check current version and update Mihomo if a newer version is available
  core_remove                     Remove the currently installed Mihomo binary

  core_update_cron_check          Check if a scheduled Mihomo core auto-update task exists
  core_update_cron_add            Add a scheduled task to periodically check and update Mihomo core
  core_update_cron_remove         Remove the scheduled Mihomo core auto-update task

  core_autorestart_cron_check     Check if a scheduled Mihomo auto-restart task exists
  core_autorestart_cron_add       Add a scheduled task to automatically restart Mihomo periodically
  core_autorestart_cron_remove    Remove the scheduled Mihomo auto-restart task

Information Commands:
  info_device             Show device model.
  info_openwrt            Show OpenWrt version.
  info_core               Show Mihomo core version.
  info_package            Show JustClash package version.

Diagnostics:
  diag_report             Run diagnostic
  diag_nft                Run nftables diagnostic.
  diag_route              Run route tables diagnostic.
  diag_icmp               Run internet check with ICMP.
  diag_proxy_resolver     Run Internal DNS diagnostic.
  diag_external_resolver  Run Default DNS diagnostic.

Logs:
  logs|systemlogs [N]     Show last N lines of system logs (default 40).

Help:
  help|?|command          Show this help message.

EOF
}

case "$1" in
    start|run)
        start
        ;;
    stop)
        stop
        ;;
    config_show)
        config_show
        ;;
    config_reset)
        config_reset
        ;;
    core_update)
        core_update
        ;;
    core_remove)
        core_remove
        ;;
    core_update_cron_check)
        core_update_cron_check
        ;;
    core_update_cron_add)
        core_update_cron_add
        ;;
    core_update_cron_remove)
        core_update_cron_remove
        ;;
    core_autorestart_cron_check)
        core_autorestart_cron_check
        ;;
    core_autorestart_cron_add)
        core_autorestart_cron_add
        ;;
    core_autorestart_cron_remove)
        core_autorestart_cron_remove
        ;;
    rulesets_list_update)
        rulesets_list_update
        ;;
    logs|systemlogs)
        case "$2" in
            *[!0-9]* | '')
                systemlogs
                ;;
            *)
                systemlogs "$2"
                ;;
        esac
        ;;
    info_device)
        info_device
        ;;
    info_openwrt)
        info_openwrt
        ;;
    info_core|info_mihomo)
        info_mihomo
        ;;
    info_package)
        info_package
        ;;
    diag_nft)
        diag_nft
        ;;
    diag_route)
        diag_route
        ;;
    diag_report)
        diag_report
        ;;
    diag_proxy_resolver)
        diag_proxy_resolver "$2"
        ;;
    diag_external_resolver)
        diag_external_resolver "$2" "$3"
        ;;
    diag_icmp)
        diag_icmp "$2" "${3:-3}"
        ;;
    help|?|command)
        help
        ;;
    *)
        clog 2 "Unknown command: $1"
        clog 2 "Type 'justclash help' for a list of available commands."
        exit 1
        ;;
esac
