#!/bin/ash
# Ash isn't supported properly in spellcheck static analyzer
# Using debian based version (kind of similar)
# shellcheck shell=dash

# --------------------------------------------
# Main justclash service part
# Directly using uci config calls every load
# Avoid adding simple commands for perfomance
# --------------------------------------------

# shellcheck disable=SC1091
[ -r /lib/functions.sh ] && . /lib/functions.sh
# shellcheck disable=SC1091
[ -r /lib/config/uci.sh ] && . /lib/config/uci.sh

# Variable for standalone or procd start
PROCD_MODE=0

# setup procd variable: $JUSTCLASH_ENV passed from init.d start
# shellcheck disable=SC2154
[ "$JUSTCLASH_ENV" = "procd" ] && PROCD_MODE=1 || PROCD_MODE=0

config_load justclash

CORE_RELEASE_URL_PARTIAL="https://github.com/metacubex/mihomo/releases/latest/download"
CORE_RELEASE_URL_PARTIAL_NO_TAG="https://github.com/metacubex/mihomo/releases/download"
CORE_ALPHA_RELEASE_URL_PARTIAL="https://github.com/metacubex/mihomo/releases/download/Prerelease-Alpha"
RULESETS_FILES_URL_PARTIAL="https://raw.githubusercontent.com/SaltyMonkey/mrs-parsed-data/refs/heads/main"
NO_DATA_STRING="N/A"


CORE_BIN_NAME="mihomo"
# Path to Mihomo core
CORE_PATH="/usr/bin/${CORE_BIN_NAME}"
CORE_PATH_INFOBIN="/usr/bin/justclash_info"
INITD_PATH="/etc/init.d/justclash"
# workdir path (in RAM)
CORE_WORKDIR_PATH="/tmp/justclash/"
# Mihomo using directory 'rules' by default in workdir
# if nothing selected in path fields for rules
CORE_WORKDIR_RULES_PATH="/tmp/justclash/rules"

OUTPUT_YAML_CONFIG_PATH="${CORE_WORKDIR_PATH}config.yaml"
DEFAULT_CONFIG_PATH="/etc/default.justclash.config"
DEFAULT_SYMLINKDIR_RULESETS="/etc/justclash_rules"
RULESETS_FILENAME="rulesets.justclash.txt"
RULESETS_FILE="/etc/${RULESETS_FILENAME}"
RULESETS_BLOCKS_FILENAME="blockrulesets.justclash.txt"
RULESETS_BLOCKS_FILE="/etc/${RULESETS_BLOCKS_FILENAME}"

DEFAULT_RULESET_PROXY="DIRECT"
DEFAULT_PROXY="DIRECT"
DEFAULT_HEALTHCHECK_INTERVAL=360
DEFAULT_PROVIDERUPDATE_INTERVAL=7200
DEFAULT_HEALTHCHECK_TIMEOUT=5000
DEFAULT_RULESET_INTERVAL="86500"
DEFAULT_TLS_PORT="443"
DEFAULT_SOCKS_PORT="1080"
DEFAULT_HEALTHCHECK_URL="http://www.gstatic.com/generate_204"
DEFAULT_HEALTHCHECK_RESULT=204
DEFAULT_INPUT_INTERFACE="br-lan"

CORE_RESTART_MAX_RETRIES=3

DIAG_RESOLVE_URL_YANDEX="ya.ru"
DIAG_IP_CHECK_PING_YANDEX="77.88.8.8"
DIAG_IP_CHECK_PING_GOOGLE="8.8.8.8"

NF_TABLE_NAME="justclash_tproxy"
NF_TABLE_FWMARK_FINAL=1
NF_TABLE_FWMARK_PROXY=255
NF_ROUTE_TABLE=100

# List of NTP server IP addresses:
# 194.190.168.1   ‚Äî ntp1.stratum2.ru (Russian NTP server)
# 195.208.185.17  ‚Äî ntp2.stratum2.ru (Russian NTP server)
# 193.232.128.6   ‚Äî ntp3.stratum2.ru (Russian NTP server)
# 216.239.35.0    ‚Äî time.google.com (Google NTP)
NTP_IPS="194.190.168.1 195.208.185.17 193.232.128.6 216.239.35.0"
# String for nft tables
# Allow traffic on:
# LAN interfaces (lan*)
# bridge interface (br-lan)
#ALLOWED_INTERFACES='{ lan*, br-lan }'
# List of conflicting packages:
# podkop (custom proxy)
# and https-dns-proxy (DNS over HTTPS proxy)
CONFLICTED_PACKAGES="banip mihomo nextdns sing-box podkop https-dns-proxy luci-app-passwall luci-app-passwall2 dns-failsafe-proxy"
CONFLICTED_PATTERNS_DHCP_CONFIG="doh_backup_noresolv doh_backup_server doh_server"
CONFLICTED_PATTERNS_FILEPATH="/etc/config/dhcp"
RESOLVCONF_FILEPATH="/etc/resolv.conf"
ZAPRETINITD_FILEPATH="/etc/init.d/zapret"
BYEDPI_FILEPATH="/etc/init.d/byedpi"
YOUTUBEUNBLOCK_FILEPATH="/etc/init.d/youtubeUnblock"

ucibool_to_yesno() {
    case "$1" in
        1) echo "Yes" ;;
        0) echo "No" ;;
        *) echo "$1" ;;
    esac
}

panic() {
    local message="$1"
    syslog 0 "$message"
    clog 0 "$message"
    stop
    exit 1
}

get_log_level_console() {
    case "$1" in
        0) echo "ERROR" ;;
        1) echo "WARN" ;;
        2) echo "INFO" ;;
        3) echo "DEBUG" ;;
        *) echo "UNKN" ;;
    esac
}

get_log_level_syslog() {
    case "$1" in
        0) echo "user.err" ;;
        1) echo "user.warning" ;;
        2) echo "user.info" ;;
        3) echo "user.debug" ;;
        *) echo "user.debug" ;;
    esac
}

syslog() {
    local level="$1"
    local message="$2"
    local level_syslog=""
    level_syslog=$(get_log_level_syslog "$level")

    logger -p "$level_syslog" -t "justclash" "$message"
}

clog() {
    local level="$1"
    local message="$2"
    local timestamp=""
    local level_str=""

    [ "$PROCD_MODE" -eq 1 ] && return

    timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    level_str=$(get_log_level_console "$level")

    printf "[%s] [%s] %s\n" "$timestamp" "$level_str" "$message"
}

log() {
    local level="$1"
    local message="$2"
    local emoji="${3:-}"

    syslog "$level" "$message"

    [ "$PROCD_MODE" -eq 1 ] && return

    if [ -n "$emoji" ]; then
        clog "$level" "$emoji ${message}"
    else
        clog "$level" "$message"
    fi
}

is_package_installed() {
    local found_pkgs=""
    local pkgcommand=""

    if command -v apk >/dev/null 2>&1; then
        pkgcommand="apk info"
    else
        pkgcommand="opkg list-installed"
    fi

    for pkg in "$@"; do
        if $pkgcommand | grep -qw "$pkg"; then
            found_pkgs="${found_pkgs:+$found_pkgs }$pkg"
        fi
    done

    if [ -n "$found_pkgs" ]; then
        echo "$found_pkgs"
        return 0
    else
        return 1
    fi
}

is_pattern_in_file() {
    if [ -z "$1" ]; then
        log 1 "Usage: is_pattern_in_file <string>"
        return 1
    fi

    local file="$1"

    if [ ! -r "$file" ]; then
        return 1
    fi
    local found_patterns=""
    for pattern in "$@"; do
        if grep -qE "$pattern" "$file"; then
            found_patterns="${found_patterns:+$found_patterns }$pattern"
        fi
    done
    if [ -n "$found_patterns" ]; then
        echo "$found_patterns"
        return 0
    else
        return 1
    fi
}

ntp_force_sync() {
    local ntpd_start
    config_get_bool ntpd_start settings ntpd_start
    if [ -z "$NTP_IPS" ]; then
        log 0 "No NTP servers configured" "‚ö†Ô∏è"
        return 1
    fi

    if ! command -v /usr/sbin/ntpd >/dev/null; then
        log 0 "ntpd not found, time synchronization skipped" "‚ö†Ô∏è"
        return 1
    fi

    if [ "$ntpd_start" -eq 1 ]; then
        NTP_ARGS=""
        for ip in $NTP_IPS; do
            NTP_ARGS="$NTP_ARGS -p $ip"
        done
        # shellcheck disable=SC2086
        /usr/sbin/ntpd -q $NTP_ARGS
    fi

    sleep 2
}


compat_fixes() {
    if ! command -v lsmod >/dev/null 2>&1; then
        log 1 "lsmod is missing. Can't check for kernel modules" "‚ö†Ô∏è"
    else
        if lsmod | grep -qF br_netfilter && [ "$(sysctl -n net.bridge.bridge-nf-call-iptables 2>/dev/null)" = "1" ]; then
            log 1 "br_netfilter is enabled. FriendlyWRT? Fixing module params..." "‚ö†Ô∏è"
            sysctl -w net.bridge.bridge-nf-call-iptables=0
            sysctl -w net.bridge.bridge-nf-call-ip6tables=0
            log 1 "Set net.bridge.bridge-nf-call-iptables=0" "‚ö†Ô∏è"
            log 1 "Set net.bridge.bridge-nf-call-ip6tables=0" "‚ö†Ô∏è"
        else
            log 2 "No compatibility fixes required."
        fi
    fi
}

core_validate_yaml() {
    local test_output app_exit_code grep_test_exit_code grep_error_exit_code
    test_output="$("$CORE_PATH" -t -f "$OUTPUT_YAML_CONFIG_PATH" 2>&1)"
    app_exit_code=$?
    echo "$test_output" | grep -qiF "test failed"
    grep_test_exit_code=$?
    echo "$test_output" | grep -qiF "error"
    grep_error_exit_code=$?
    if [ "$grep_test_exit_code" -eq 0 ] || [ "$app_exit_code" -ne 0 ] || [ "$grep_error_exit_code" -eq 0 ]; then
        log 0 "Yaml configuration incorrect!" "‚ùå"
        log 0 "$test_output" "‚ùå"
        log 0 "Mihomo config validation is failed." "‚ùå"
        return 1
    fi
    return 0
}

start() {
    log 2 "Initializing Justclash service..." "‚è≥"

    if [ ! -f "$CORE_PATH" ]; then
        log 0 "Mihomo core is not installed." "‚ùå"
        return 1
    fi

    log 2 "Checking for conflicts" "üêû"
    check_for_conflicts

    log 2 "Checking for non critical conflicts" "üêû"
    check_for_conflicts_warn

    log 2 "Fixing known compatibility problems" "üîë"
    compat_fixes

    log 2 "Synchronizing system time" "üïí"
    ntp_force_sync

    log 2 "Preparing Mihomo working directory" "üì¶"
    core_prepare_workdir

    log 2 "Generating yaml configuration..." "üì¶"
    core_generate_yaml

    log 2 "Validating yaml configuration..." "üì¶"
    core_validate_yaml
    if [ $? = 1 ]; then
        return 1
    fi

    log 2 "Configuring tproxy routing and creating NFTables table" "üîë"
    nf_table_add

    log 2 "Modifying dnsmasq configuration" "üîë"
    dnsmasq_add

    log 2 "Starting Mihomo core" "üê±"
    start_core
}

stop() {
    log 2 "Closing Justclash service..." "‚è≥"
    log 2 "Removing tproxy routing and NFTables table" "üîë"
    nf_table_remove

    log 2 "Restoring default dnsmasq configuration" "üîë"
    dnsmasq_remove

    log 2 "Stopping core process" "üê±"
    stop_core
}

# WARNING: TRY TO NOT USE FUNC MANUALLY - MUST CLEAR ROUTES AND DNSMASQ
start_core() {
    local attempt=0
    log 2 "Start with configured retries: $CORE_RESTART_MAX_RETRIES" "üê±"

    if [ "$PROCD_MODE" -eq 1 ]; then
        local attempt=0

        while [ "$attempt" -lt "$CORE_RESTART_MAX_RETRIES" ]; do
            "$CORE_PATH" -d "$CORE_WORKDIR_PATH" 2>&1 | sed 's/time="[^"]*"/mihomo/' | logger -t justclash
            exit_code=$?
            log 1 "Procd: mihomo exited with code $exit_code" "‚ùå"

            if [ "$exit_code" -eq 0 ]; then
                break
            fi

            attempt=$((attempt + 1))
            log 0 "Procd:  mihomo crashed, attempt $attempt of $CORE_RESTART_MAX_RETRIES" "‚ùå"

            if [ "$attempt" -ge "$CORE_RESTART_MAX_RETRIES" ]; then
                log 0 "Procd:  Failed to restart mihomo after $CORE_RESTART_MAX_RETRIES attempts, exiting" "‚ùå"
                exit "$exit_code"
            fi

            sleep 5
        done
    else
        "$CORE_PATH" -d "$CORE_WORKDIR_PATH" 2>&1
        exit_code=$?
        log 1 "Manual: mihomo exited with code $exit_code" "‚ùå"
        if [ "$exit_code" -ne 0 ]; then
            log 0 "Manual: mihomo crashed, exiting" "‚ùå"
            exit "$exit_code"
        fi
    fi
}

# WARNING: TRY TO NOT USE FUNC MANUALLY - MUST CLEAR ROUTES AND DNSMASQ
stop_core() {
    if pgrep -f "$(basename "$0")" >/dev/null; then
        pids=$(pgrep -f "$(basename "$CORE_PATH")")
        if [ -n "$pids" ]; then
            # DO NOT APPLY "" - STRING MUST BE SPLITTED AUTOMATICALLY
            # shellcheck disable=SC2086
            kill $pids 2>/dev/null
        fi
        log 2 "Core process stopped" "üê±"
    else
       log 2 "JustClash isn't running" "üê±"
    fi
}

cleanup_fwmark() {
    #todo: change dynamic 0x1
    while ip rule show | grep -qF "fwmark 0x1 lookup $NF_ROUTE_TABLE"; do
        ip rule del fwmark "$NF_TABLE_FWMARK_FINAL" table "$NF_ROUTE_TABLE" 2>/dev/null || true
    done
}

nf_table_add() {
    local nft_apply_changes
    local tproxy_port proxy_fwmark_hex fake_ip_range tproxy_input_interfaces
    local nft_block_quic nft_block_dot nft_block_dot_quic nft_block_ntp
    local tproxy_excluded_ips=""

    config_get nft_apply_changes settings nft_apply_changes
    config_get tproxy_port proxy tproxy_port
    config_get fake_ip_range proxy fake_ip_range
    config_get tproxy_input_interfaces settings tproxy_input_interfaces "$DEFAULT_INPUT_INTERFACE"
    config_get nft_block_quic settings nft_block_quic
    config_get nft_block_dot settings nft_block_dot
    config_get nft_block_dot_quic settings nft_block_dot_quic
    config_get nft_block_ntp settings nft_block_ntp
    config_get tproxy_excluded_ips settings tproxy_excluded_ips ""

    tproxy_excluded_ips=$(echo "$tproxy_excluded_ips" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//' | sed 's/[[:space:]]\+/, /g')

    if [ "$nft_apply_changes" = "0" ]; then
        return 0
    fi

    [ -z "$tproxy_port" ] && panic "tproxy_port not set"
    [ -z "$fake_ip_range" ] && panic "fake_ip_range not set"

    proxy_fwmark_hex=$(printf "0x%02X" "$NF_TABLE_FWMARK_PROXY")

    if nft list table ip "$NF_TABLE_NAME" 2>/dev/null; then
        nft delete table ip "$NF_TABLE_NAME"
    fi

    # –°–æ–∑–¥–∞—ë–º —Ç–∞–±–ª–∏—Ü—É, —Ü–µ–ø–æ—á–∫—É –∏ –Ω–∞–±–æ—Ä –∞–¥—Ä–µ—Å–æ–≤
    nft add table ip "$NF_TABLE_NAME"
    nft add chain ip "$NF_TABLE_NAME" prerouting '{ type filter hook prerouting priority mangle; policy accept; }'
    #nft add chain ip "$NF_TABLE_NAME" output '{ type route hook output priority mangle; policy accept; }'

    nft add set ip "$NF_TABLE_NAME" fake_ips '{ type ipv4_addr; flags interval; }'
    nft add element ip "$NF_TABLE_NAME" fake_ips { $fake_ip_range }

    nft add set ip "$NF_TABLE_NAME" private_ips '{ type ipv4_addr; flags interval; }'
    nft add element ip "$NF_TABLE_NAME" private_ips { \
        0.0.0.0/8, 10.0.0.0/8, 100.64.0.0/10, 127.0.0.0/8, \
        169.254.0.0/16, 172.16.0.0/12, 192.0.0.0/24, 192.0.2.0/24, \
        192.88.99.0/24, 192.168.0.0/16, 198.51.100.0/24, 203.0.113.0/24, \
        224.0.0.0/4, 240.0.0.0/4 }

    nft add set ip "$NF_TABLE_NAME" inbound_interfaces '{ type ifname; }'
    # shellcheck disable=SC2046
    # shellcheck disable=SC2086
    nft add element ip "$NF_TABLE_NAME" inbound_interfaces { $(echo $tproxy_input_interfaces | sed 's/ /", "/g; s/^/"/; s/$/"/') }

    if [ "$nft_block_quic" = "1" ] || [ "$nft_block_dot_quic" = "1" ] || [ "$nft_block_ntp" = 1 ]; then
        local selected_ports=""
        [ "$nft_block_quic" = "1" ] && selected_ports=$selected_ports"443,"
        [ "$nft_block_dot_quic" = "1" ] && selected_ports=$selected_ports"853,"
        [ "$nft_block_ntp" = "1" ] && selected_ports=$selected_ports"123,"
        selected_ports="${selected_ports%,}"

        if [ -n "$selected_ports" ]; then
            nft add rule ip "$NF_TABLE_NAME" prerouting iifname @inbound_interfaces meta l4proto udp udp dport { $selected_ports } drop
        fi
    fi

    if [ "$nft_block_dot" = "1" ]; then
        nft add rule ip "$NF_TABLE_NAME" prerouting iifname @inbound_interfaces meta l4proto tcp tcp dport 853 drop
    fi

    nft add rule ip "$NF_TABLE_NAME" prerouting iifname @inbound_interfaces ip daddr @private_ips return

    # –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø–æ fwmark –¥–ª—è br-lan
    nft add rule ip "$NF_TABLE_NAME" prerouting iifname @inbound_interfaces mark "$proxy_fwmark_hex" return

    if [ -n "$tproxy_excluded_ips" ]; then
        # –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø–æ tproxy_excluded_ips —Å br-lan
        nft add rule ip "$NF_TABLE_NAME" prerouting iifname @inbound_interfaces ip saddr { $tproxy_excluded_ips } meta l4proto { tcp, udp } return
    fi

    # –ú–∞—Ä–∫–∏—Ä—É–µ–º fake IP –¥–ª—è br-lan
    nft add rule ip "$NF_TABLE_NAME" prerouting iifname @inbound_interfaces ip daddr @fake_ips meta l4proto { tcp, udp } meta mark set "$NF_TABLE_FWMARK_FINAL"

    # –ú–∞—Ä–∫–∏—Ä—É–µ–º –æ—Å—Ç–∞–ª—å–Ω–æ–π —Ç—Ä–∞—Ñ–∏–∫ TCP –∏ UDP —Å br-lan
    nft add rule ip "$NF_TABLE_NAME" prerouting iifname @inbound_interfaces meta l4proto { tcp, udp } meta mark set "$NF_TABLE_FWMARK_FINAL"

    # tproxy —Ç–æ–ª—å–∫–æ –¥–ª—è —Ç—Ä–∞—Ñ–∏–∫–∞ —Å br-lan –∏ –Ω—É–∂–Ω–æ–π –º–µ—Ç–∫–æ–π
    nft add rule ip "$NF_TABLE_NAME" prerouting iifname @inbound_interfaces meta mark "$NF_TABLE_FWMARK_FINAL" meta l4proto { tcp, udp } tproxy to 127.0.0.1:"$tproxy_port"

    # --- output ---
    #nft add rule ip "$NF_TABLE_NAME" output mark "$proxy_fwmark_hex" return
    #nft add rule ip "$NF_TABLE_NAME" output oifname "lo" return
    #nft add rule ip "$NF_TABLE_NAME" output ip daddr @private_ips_output return
    #nft add rule ip "$NF_TABLE_NAME" output ip daddr @fake_ips ip protocol tcp meta mark set "$NF_TABLE_FWMARK_FINAL"
    #nft add rule ip "$NF_TABLE_NAME" output ip daddr @fake_ips ip protocol udp meta mark set "$NF_TABLE_FWMARK_FINAL"
    #nft add rule ip "$NF_TABLE_NAME" output ip protocol tcp meta mark set "$NF_TABLE_FWMARK_FINAL"
    #nft add rule ip "$NF_TABLE_NAME" output ip protocol udp meta mark set "$NF_TABLE_FWMARK_FINAL"

    cleanup_fwmark
    #todo: change dynamic 0x1
    if ! ip rule list | grep -qF "fwmark 0x1 lookup $NF_ROUTE_TABLE"; then
        ip rule add fwmark "$NF_TABLE_FWMARK_FINAL" table "$NF_ROUTE_TABLE"
    fi

    if ! ip route show table "$NF_ROUTE_TABLE" | grep -Eq "local (default|0\.0\.0\.0/0) dev lo"; then
        ip route add local 0.0.0.0/0 dev lo table "$NF_ROUTE_TABLE"
    fi

    log 1 "Tproxy: port=$tproxy_port, fwmark=$NF_TABLE_FWMARK_FINAL fwmark_proxy=$NF_TABLE_FWMARK_PROXY table=$NF_ROUTE_TABLE"
}

nf_table_remove() {
    cleanup_fwmark
    nft flush table ip "$NF_TABLE_NAME" 2>/dev/null || true
    nft delete table ip "$NF_TABLE_NAME" 2>/dev/null || true
    ip route flush table "$NF_ROUTE_TABLE" 2>/dev/null || true

    log 2 "Tproxy Clash rules and routing were removed" "‚öôÔ∏è"
}

# Thx Podkop, feels so annoyed already by shell scripting
save_dnsmasq_config() {
    local key="$1"
    local backup_key="$2"
    value=$(uci get "$key" 2>/dev/null)

    if [ -z "$value" ]; then
        uci set "$backup_key"="unset"
    else
        uci set "$backup_key"="$value"
    fi
}

dnsmasq_add() {
    local dns_listen_port dnsmasq_apply_changes
    config_get dns_listen_port proxy dns_listen_port
    config_get_bool dnsmasq_apply_changes settings dnsmasq_apply_changes

    if [ "$dnsmasq_apply_changes" -eq 1 ]; then

        uci -q delete dhcp.@dnsmasq[0].justclash_server
        for server in $(uci get dhcp.@dnsmasq[0].server 2>/dev/null); do
            if [ "$server" = "127.0.0.1#${dns_listen_port}" ]; then
                log 1 "Dnsmasq save config error: server=127.0.0.1 is already configured. Skip editing DHCP"
                return 1
            else
                uci add_list dhcp.@dnsmasq[0].justclash_server="$server"
            fi
        done

        save_dnsmasq_config "dhcp.@dnsmasq[0].noresolv" "dhcp.@dnsmasq[0].justclash_noresolv"
        save_dnsmasq_config "dhcp.@dnsmasq[0].cachesize" "dhcp.@dnsmasq[0].justclash_cachesize"

        uci add_list dhcp.@dnsmasq[0].server="127.0.0.1#$dns_listen_port"
        uci set dhcp.@dnsmasq[0].cachesize="0"
        uci set dhcp.@dnsmasq[0].noresolv="1"

        uci commit dhcp
        log 2 "DNS configuration has been updated with new settings." "üåê"
        /etc/init.d/dnsmasq restart > /dev/null 2>&1
        log 2 "dnsmasq service has been restarted to apply DNS changes." "üîÑ"
    else
        log 2 "DNS configuration remains unchanged; update skipped as per configuration rules." "üõ†Ô∏è"
    fi

}

dnsmasq_remove() {
    local dns_listen_port
    config_get dns_listen_port proxy dns_listen_port
    local dnsmasq_apply_changes
    config_get_bool dnsmasq_apply_changes settings dnsmasq_apply_changes

    local bak_cachesize
    local bak_noresolv
    local server

    if [ "$dnsmasq_apply_changes" -eq 1 ]; then
        bak_cachesize=$(uci get dhcp.@dnsmasq[0].justclash_cachesize 2>/dev/null)
        if [ -z "$bak_cachesize" ]; then
            log 1 "dnsmasq revert: cachesize is unset"
        else
            uci set dhcp.@dnsmasq[0].cachesize="$bak_cachesize"
        fi

        bak_noresolv=$(uci get dhcp.@dnsmasq[0].justclash_noresolv 2>/dev/null)
        if [ "$bak_noresolv" = "unset" ]; then
            log 1 "dnsmasq revert: noresolv is unset"
            uci -q delete dhcp.@dnsmasq[0].noresolv
        else
            uci set dhcp.@dnsmasq[0].noresolv="$bak_noresolv"
        fi

        server=$(uci get dhcp.@dnsmasq[0].server 2>/dev/null)
        if [ "$server" = "127.0.0.1#${dns_listen_port}" ]; then
            uci -q delete dhcp.@dnsmasq[0].server 2>/dev/null
            for server in $(uci get dhcp.@dnsmasq[0].justclash_server 2>/dev/null); do
                uci add_list dhcp.@dnsmasq[0].server="$server"
            done
            uci delete dhcp.@dnsmasq[0].justclash_server 2>/dev/null
        fi

        uci commit dhcp
        log 2 "DNS configuration has been restored." "üåê"
        /etc/init.d/dnsmasq restart > /dev/null 2>&1
        log 2 "dnsmasq service has been restarted to apply DNS changes." "üîÑ"
    else
        log 2 "DNS configuration remains unchanged; update skipped as per configuration rules." "üõ†Ô∏è"
    fi
 }

check_for_conflicts() {
    local installed_pkgs found_patterns pkg pattern

    # For $CONFLICTED_PACKAGES only. We don't need "" to make shell split string
    # shellcheck disable=SC2086
    installed_pkgs=$(is_package_installed $CONFLICTED_PACKAGES)
    if [ -n "$installed_pkgs" ]; then
        for pkg in $installed_pkgs; do
            log 1 "Conflict detected: package '$pkg' is installed." "‚ö†Ô∏è"
            log 1 "This package may interfere with the current service setup." "‚ö†Ô∏è"
            log 1 "Please consider uninstalling or reconfiguring the package before proceeding." "‚ö†Ô∏è"
        done
        panic "Conflicting packages detected. Operation aborted for safety."
    fi

    # For $CONFLICTED_PATTERNS_DHCP_CONFIG only. We don't need "" to make shell split string
    # shellcheck disable=SC2086
    found_patterns=$(is_pattern_in_file "$CONFLICTED_PATTERNS_FILEPATH" "$CONFLICTED_PATTERNS_DHCP_CONFIG")
    if [ -n "$found_patterns" ]; then
        for pattern in $found_patterns; do
            log 1 "Conflict detected: pattern '$pattern' found in /etc/config/dhcp." "‚ö†Ô∏è"
            log 1 "This pattern may indicate a configuration clash with the current service." "‚ö†Ô∏è"
            log 1 "Please review and edit your DHCP configuration to resolve this issue." "‚ö†Ô∏è"
        done
        panic "Conflicting DHCP configuration patterns detected. Operation aborted for safety."
    fi
}

check_for_conflicts_warn() {
    local external_nameservers
    external_nameservers=$(
        awk '$1 == "nameserver" && $2 != "127.0.0.1" && $2 != "0.0.0.0" { print; found=1 } END { exit !found }' "$RESOLVCONF_FILEPATH"
    )
    local resolvconf_res=$?

    if [ "$resolvconf_res" -eq 0 ]; then
        log 1 "Warning: External DNS servers are listed in /etc/resolv.conf:" "‚ö†Ô∏è"
        log 1 "Found: $external_nameservers" "‚ö†Ô∏è"
        log 1 "This may bypass local DNS rules and cause unexpected query results." "‚ö†Ô∏è"
        log 1 "If you intend to use a local DNS service, these entries should be removed." "‚ö†Ô∏è"
    fi

    if [ -f "$ZAPRETINITD_FILEPATH" ]; then
        log 1 "Warning: Zapret service detected by path $ZAPRETINITD_FILEPATH:" "‚ö†Ô∏è"
        log 1 "This service can cause unexpected results if configured incorrectly." "‚ö†Ô∏è"
    fi

    if [ -f "$BYEDPI_FILEPATH" ]; then
        log 1 "Warning: ByeDPI service detected by path $BYEDPI_FILEPATH:" "‚ö†Ô∏è"
        log 1 "This service can cause unexpected results if configured incorrectly." "‚ö†Ô∏è"
    fi

}

info_device() {
    $CORE_PATH_INFOBIN info_device
}

info_openwrt() {
    $CORE_PATH_INFOBIN info_openwrt
}

info_mihomo() {
    $CORE_PATH_INFOBIN info_core
}

info_package() {
    $CORE_PATH_INFOBIN info_package
}

info_luci() {
    $CORE_PATH_INFOBIN info_luci
}

info_conns_console() {
    $CORE_PATH_INFOBIN info_conns_console
}

systemlogs() {
    local res
    local lines=${1:-40}
    res=$($CORE_PATH_INFOBIN systemlogs "$lines")
    echo "$res"
}

simple_uci_list_to_json_arr() {
    local section_name="$1"
    local list_name="$2"
    local result=""
    local values

    config_get values "$section_name" "$list_name"

    [ -z "$values" ] && {
        echo "[]"
        return
    }

    for val in $values; do
        [ -n "$val" ] && {
            val=$(printf '%s' "$val" | sed 's/"/\\"/g')
            if [ -n "$result" ]; then
                result="${result}, \"$val\""
            else
                result="\"$val\""
            fi
        }
    done

    [ -z "$result" ] && echo "[]" || echo "[$result]"
}

ucibool_to_yaml_bool () {
    case "$1" in
        1|yes|on|true) echo "true" ;;
        *) echo "false" ;;
    esac
}

parse_ss_url() {
    local link="${1#ss://}"

    # –£–¥–∞–ª—è–µ–º #, –Ω–æ —Å–æ—Ö—Ä–∞–Ω—è–µ–º query (–¥–ª—è plugin)
    link="${link%%#*}"

    local userinfo hostport method password server port decoded query_part
    #local plugin=""

    # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ query (–ø–æ—Å–ª–µ ?)
    query_part=""
    # shellcheck disable=SC2249
    case "$link" in *\?*) query_part="${link#*\?}"; link="${link%%\?*}"; esac

    if echo "$link" | grep -q '@'; then
        userinfo="${link%@*}"
        hostport="${link#*@}"

        decoded="$(echo "$userinfo" | base64 -d 2>/dev/null)"
        if [ -n "$decoded" ] && echo "$decoded" | grep -q ':'; then
            method="$(url_decode "${decoded%%:*}")"  # –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ
            password="$(url_decode "${decoded#*:}")"  # –î–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ
        else
            method="$(url_decode "${userinfo%%:*}")"
            password="$(url_decode "${userinfo#*:}")"
        fi
    else
        decoded="$(echo "$link" | base64 -d 2>/dev/null)"
        userinfo="${decoded%@*}"
        hostport="${decoded#*@}"
        method="$(url_decode "${userinfo%%:*}")"
        password="$(url_decode "${userinfo#*:}")"
    fi

    server="${hostport%%:*}"
    port="${hostport##*:}"
    [ "$server" = "$port" ] && port=1080  # –î–µ—Ñ–æ–ª—Ç –¥–ª—è SS

    # –ü–∞—Ä—Å–∏–Ω–≥ query (–Ω–∞–ø—Ä–∏–º–µ—Ä, –¥–ª—è plugin)
    local temp_query="$query_part"
    while [ -n "$temp_query" ]; do
        local param="${temp_query%%&*}"
        temp_query="${temp_query#"$param"}"
        [ -n "$temp_query" ] && temp_query="${temp_query#&}"

        local k="${param%%=*}"
        local v="${param#*=}"
        [ -z "$k" ] && continue

        #case "$k" in
        #    plugin) plugin="$(url_decode "$v")" ;;
        #esac
    done

    # JSON
    printf '{"type":"ss","server":"%s","port":%s,"cipher":"%s","password":"%s","udp":true}\n' \
        "$server" "$port" "$method" "$password"
}

url_decode() {
    # shellcheck disable=SC3060
    local data="${1//+/ }"
    echo -n "$data" | sed 's/%/\\x/g' | xargs -0 printf '%b'
}

json_escape() {
    printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g'
}

parse_socks5_url() {
    local link="$1"
    local raw="${link#socks5://}"

    local server="" port="" username="" password=""
    local userinfo="" hostport=""
    local name=""

    if echo "$raw" | grep -q '@'; then
        userinfo="${raw%@*}"
        hostport="${raw#*@}"

        if echo "$userinfo" | grep -q ':'; then
            username="$(url_decode "${userinfo%%:*}")"
            password="$(url_decode "${userinfo#*:}")"
        else
            username="$(url_decode "$userinfo")"
        fi
    else
        hostport="$raw"
    fi

    # host:port
    server="$(url_decode "${hostport%%:*}")"
    port="${hostport##*:}"

    [ -z "$port" ] && port="$DEFAULT_SOCKS_PORT"

    name="socks5_${server}_${port}"

    # –°–æ–±–∏—Ä–∞–µ–º JSON
    local json="{\"type\":\"socks5\",\"name\":\"$name\",\"server\":\"$server\",\"port\":$port"
    [ -n "$username" ] && json="$json,\"username\":\"$username\""
    [ -n "$password" ] && json="$json,\"password\":\"$password\""
    json="$json,\"udp\":true}"

    echo "$json"
}

parse_trojan_url() {
    local url="$1"
    local raw="${url#trojan://}"
    raw="${raw%%#*}"

    local userinfo="${raw%@*}"
    local hostport="${raw#*@}"
    local password="$(printf '%b' "$(echo "$userinfo" | sed 's/%\(..\)/\\x\1/g')")"

    local host="${hostport%%\?*}"
    local server="${host%%:*}"
    local port="${host##*:}"
    [ "$server" = "$port" ] && port="$DEFAULT_TLS_PORT"

    local query_part=""
    # shellcheck disable=SC2249
    case "$hostport" in *\?*) query_part="${hostport#*\?}" ;; esac

    local sni="" insecure=0 net="tcp" fp="" alpn="" ws_path="" ws_host="" grpc_service=""
    local ss_enabled="" ss_method="" ss_password=""

    local temp_query="$query_part"
    while [ -n "$temp_query" ]; do
        local param="${temp_query%%&*}"
        temp_query="${temp_query#"$param"}"
        [ -n "$temp_query" ] && temp_query="${temp_query#&}"

        local k="${param%%=*}"
        local v="${param#*=}"
        [ -z "$k" ] && continue

        # shellcheck disable=SC2249
        case "$k" in
            sni|peer) sni="$(url_decode "$v")" ;;
            insecure|allowInsecure) [ "$v" = "1" ] && insecure=1 ;;
            type) net="$v" ;;
            fp|client-fingerprint) fp="$v" ;;
            alpn) alpn="$v" ;;
            path)
                if [ -n "$v" ]; then
                    ws_path="$(url_decode "$v")"
                else
                    ws_path="/"
                fi ;;
            host) ws_host="$(url_decode "$v")" ;;
            serviceName) grpc_service="$v" ;;
            ss) ss_enabled="$v" ;;
            ss-method) ss_method="$v" ;;
            ss-password) ss_password="$v" ;;
        esac
    done

    local json="{\"type\":\"trojan\",\"server\":\"$server\",\"port\":$port,\"password\":\"$password\",\"udp\":true"

    [ -n "$sni" ] && json="$json,\"sni\":\"$sni\""
    [ "$insecure" = "1" ] && json="$json,\"skip-cert-verify\":true"
    json="$json,\"network\":\"$net\""

    [ -n "$fp" ] && json="$json,\"client-fingerprint\":\"$fp\""
    [ -n "$alpn" ] && json="$json,\"alpn\":[\"$(echo "$alpn" | tr ',' '","')\"]"

    if [ "$net" = "ws" ]; then
        json="$json,\"ws-opts\":{\"path\":\"$ws_path\""
        [ -n "$ws_host" ] && json="$json,\"headers\":{\"Host\":\"$ws_host\"}"
        json="$json}"
    fi

    if [ "$net" = "grpc" ]; then
        json="$json,\"grpc-opts\":{\"grpc-service-name\":\"$grpc_service\"}"
    fi

    if [ -n "$ss_enabled" ] && [ -n "$ss_method" ] && [ -n "$ss_password" ]; then
        json="$json,\"ss-opts\":{\"enabled\":true,\"method\":\"$ss_method\",\"password\":\"$ss_password\"}"
    fi

    json="$json}"
    echo "$json"
}

parse_vless_url() {
    local link="$1"
    local raw="${link#vless://}"
    raw="${raw%%#*}"

    local uuid="${raw%%@*}"
    local hostport="${raw#*@}"
    local host="${hostport%%\?*}"
    local server="${host%%:*}"
    local port="${host##*:}"
    [ "$server" = "$port" ] && port=443

    local query_part=""
    # shellcheck disable=SC2249
    case "$hostport" in *\?*) query_part="${hostport#*\?}" ;; esac

    local net="tcp" sec="" sni="" fp="" alpn="" flow=""
    local pbk="" sid="" spx="" sn=""

    local temp_query="$query_part"
    while [ -n "$temp_query" ]; do
        local param="${temp_query%%&*}"
        temp_query="${temp_query#"$param"}"
        [ -n "$temp_query" ] && temp_query="${temp_query#&}"

        local k="${param%%=*}"
        local v="${param#*=}"
        [ -z "$k" ] && continue

        # shellcheck disable=SC2249
        case "$k" in
            type) net="$v" ;;
            security) sec="$v" ;;
            sni|host) sni="$(url_decode "$v")" ;;
            fp) fp="$v" ;;
            alpn) alpn="$v" ;;
            flow) flow="$v" ;;
            pbk) pbk="$v" ;;
            sid) sid="$v" ;;
            spx|path)
                if [ -n "$v" ]; then
                    spx="$(url_decode "$v")"
                else
                    spx="/"
                fi ;;
            serviceName) sn="$v" ;;
        esac
    done

    local json="{\"type\":\"vless\",\"uuid\":\"$uuid\",\"server\":\"$server\",\"port\":$port,\"encryption\":\"none\",\"network\":\"$net\",\"udp\":true"

    if [ "$sec" = "tls" ] || [ "$sec" = "reality" ]; then
        json="$json,\"tls\":true"
        [ -n "$sni" ] && json="$json,\"servername\":\"$sni\""
        [ -n "$fp" ] && json="$json,\"client-fingerprint\":\"$fp\""
        [ -n "$alpn" ] && json="$json,\"alpn\":[\"$(echo "$alpn" | tr ',' '","')\"]"
    fi

    if [ "$sec" = "reality" ]; then
        local ro=""
        [ -n "$pbk" ] && ro="$ro\"public-key\":\"$pbk\""
        [ -n "$sid" ] && ro="${ro:+$ro,}\"short-id\":\"$sid\""
        [ -n "$spx" ] && ro="${ro:+$ro,}\"spider-x\":\"$spx\""
        json="$json,\"reality-opts\":{$ro}"
    fi

    if [ "$net" = "tcp" ] && [ -n "$flow" ]; then
        json="$json,\"flow\":\"$flow\""
    fi

    if [ "$net" = "ws" ]; then
        local wso="\"path\":\"${spx:-/}\""
        [ -n "$sni" ] && wso="$wso,\"headers\":{\"Host\":\"$sni\"}"
        json="$json,\"ws-opts\":{$wso}"
    fi

    if [ "$net" = "grpc" ] && [ -n "$sn" ]; then
        json="$json,\"grpc-opts\":{\"service-name\":\"$sn\"}"
    fi

    json="$json}"
    echo "$json"
}

handle_proxy_section() {
    local ruleset_content="$1"
    local file_rules="$2"
    local file_rulesets="$3"
    local file_proxies="$4"
    local file_rulesets_names="$5"
    local file_proxies_names="$6"
    local proxies=""
    local rules_array=""
    local selectedRuleSets=""
    local list_rulesets_names=""
    local list_suffix_names=""

    # shellcheck disable=SC2317
    _parse_single_proxy() {
        local section="$1"
        local name proxy_link interval defined_as_custom_object proxy_link_object use_proxy_for_list_update list val
        local domain_list cidr_list

        config_get name "$section" name
        config_get proxy_link "$section" proxy_link
        config_get interval "$section" list_update_interval
        config_get defined_as_custom_object "$section" defined_as_custom_object 0
        config_get proxy_link_object "$section" proxy_link_object
        config_get_bool use_proxy_for_list_update "$section" use_proxy_for_list_update 0

        [ -z "$name" ] && { log 1 "Skipping proxy without name: $section" "‚ö†Ô∏è"; return; }

        local proxy_obj=""
        if [ "$defined_as_custom_object" -eq 1 ]; then
            [ -z "$proxy_link_object" ] && { log 1 "Skipping proxy '$name' without proxy_link_object in manual mode" "‚ö†Ô∏è" ; return; }

            proxy_obj=$(echo "$proxy_link_object" | jq -c --arg name "$name" '. + {name: $name}')

            [ -z "$proxy_obj" ] && { log 1 "Failed to process proxy_link_object for '$name'" "‚ö†Ô∏è"; return; }
        else
            [ -z "$proxy_link" ] && { log 1  "Skipping proxy '$name' without proxy_link" "‚ö†Ô∏è"; return; }

            proxy_link=$(echo "$proxy_link" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
            [ -z "$interval" ] && interval=$DEFAULT_RULESET_INTERVAL

            case "$proxy_link" in
                ss://*)     proxy_obj=$(parse_ss_url "$proxy_link") ;;
                socks5://*) proxy_obj=$(parse_socks5_url "$proxy_link") ;;
                trojan://*) proxy_obj=$(parse_trojan_url "$proxy_link") ;;
                vless://*)  proxy_obj=$(parse_vless_url "$proxy_link") ;;
                *) log 1 "Unknown proxy_link: $proxy_link" "‚ö†Ô∏è"; return ;;
            esac

            [ -z "$proxy_obj" ] && { log 1 "Failed to parse proxy_link: $proxy_link" "‚ö†Ô∏è"; return; }

            proxy_obj=$(echo "$proxy_obj" | sed "s/^{/{\"name\":\"$name\",/")
        fi

        if [ -z "$proxies" ]; then
            proxies="$proxy_obj"
        else
            proxies="$proxies,$proxy_obj"
        fi

        local added_rulesets="|"
        config_get list "$section" enabled_list
        for ruleset in $list; do
            if echo "$added_rulesets" | grep -qF "|$ruleset|"; then
                continue
            fi

            local line r_name yaml behavior format url proxy
            line=$(echo "$ruleset_content" | grep -F "|$ruleset|" | head -n 1)
            if [ -n "$line" ]; then
                r_name=$(echo "$line" | cut -d'|' -f1)
                yaml=$(echo "$line" | cut -d'|' -f2)
                behavior=$(echo "$line" | cut -d'|' -f3)
                format=$(echo "$line" | cut -d'|' -f4)
                url=$(echo "$line" | cut -d'|' -f5)

                local rule_str=$(printf 'RULE-SET,%s,%s' "$ruleset" "$name")
                if [ -n "$rules_array" ]; then
                    rules_array="$rules_array,\"$rule_str\""
                else
                    rules_array="\"$rule_str\""
                fi

                [ "$use_proxy_for_list_update" -eq 1 ] && proxy="$name" || proxy=$DEFAULT_PROXY
                selectedRuleSets="${selectedRuleSets}\"$ruleset\":{\"url\":\"$url\",\"behavior\":\"$behavior\",\"format\":\"$format\",\"proxy\":\"$proxy\",\"interval\":$interval,\"type\":\"http\"},"
                added_rulesets="$added_rulesets$ruleset|"

                if [ "$behavior" = "domain" ]; then
                    if [ -n "$list_rulesets_names" ]; then
                        list_rulesets_names="$list_rulesets_names,\"rule-set:$ruleset\""
                    else
                        list_rulesets_names="\"rule-set:$ruleset\""
                    fi
                fi
            fi
        done

        config_get domain_list "$section" custom_enabled_domain_list
        for line in $domain_list; do
            if [ -n "$line" ]; then
                local rng_name=$(printf "%s" "$line" | md5sum | awk '{print $1}')
                case "$line" in
                    http://*|https://*)
                        [ "$use_proxy_for_list_update" -eq 1 ] && proxy="$name" || proxy=$DEFAULT_PROXY
                        selectedRuleSets="${selectedRuleSets}\"$rng_name\":{\"url\":\"$(json_escape "$line")\",\"behavior\":\"domain\",\"format\":\"mrs\",\"proxy\":\"$proxy\",\"interval\":$interval,\"type\":\"http\"},"
                    ;;
                *)
                    if [ -f "$line" ]; then
                        [ "$use_proxy_for_list_update" -eq 1 ] && proxy="$name" || proxy=$DEFAULT_PROXY
                        selectedRuleSets="${selectedRuleSets}\"$rng_name\":{\"path\":\"$(json_escape "$line")\",\"behavior\":\"domain\",\"format\":\"mrs\",\"proxy\":\"$proxy\",\"type\":\"file\"},"
                    else
                        continue
                    fi
                    ;;
                esac

                local rule_str=$(printf 'RULE-SET,%s,%s' "$rng_name" "$name")
                if [ -n "$rules_array" ]; then
                    rules_array="$rules_array,\"$rule_str\""
                else
                    rules_array="\"$rule_str\""
                fi
                if [ -n "$list_rulesets_names" ]; then
                    list_rulesets_names="$list_rulesets_names,\"rule-set:$rng_name\""
                else
                    list_rulesets_names="\"rule-set:$rng_name\""
                fi
            fi
        done

        config_get cidr_list "$section" custom_enabled_cidr_list
        for line in $cidr_list; do
            if [ -n "$line" ]; then
                local rng_name=$(printf "%s" "$line" | md5sum | awk '{print $1}')
                case "$line" in
                    http://*|https://*)
                        [ "$use_proxy_for_list_update" -eq 1 ] && proxy="$name" || proxy=$DEFAULT_PROXY
                        selectedRuleSets="${selectedRuleSets}\"$rng_name\":{\"url\":\"$(json_escape "$line")\",\"behavior\":\"ipcidr\",\"format\":\"mrs\",\"proxy\":\"$proxy\",\"interval\":$interval,\"type\":\"http\"},"
                    ;;
                *)
                    if [ -f "$line" ]; then
                        [ "$use_proxy_for_list_update" -eq 1 ] && proxy="$name" || proxy=$DEFAULT_PROXY
                        selectedRuleSets="${selectedRuleSets}\"$rng_name\":{\"path\":\"$(json_escape "$line")\",\"behavior\":\"ipcidr\",\"format\":\"mrs\",\"type\":\"file\"},"
                    else
                        continue
                    fi
                    ;;
                esac

                local rule_str=$(printf 'RULE-SET,%s,%s' "$rng_name" "$name")
                if [ -n "$rules_array" ]; then
                    rules_array="$rules_array,\"$rule_str\""
                else
                    rules_array="\"$rule_str\""
                fi
            fi
        done

        config_get list "$section" additional_srcip_route
        for val in $list; do
            [ -n "$val" ] && {
                local rule_str=$(printf 'SRC-IP-CIDR,%s,%s' "$val" "$name")
                if [ -n "$rules_array" ]; then
                    rules_array="$rules_array,\"$rule_str\""
                else
                    rules_array="\"$rule_str\""
                fi
            }
        done
        config_get list "$section" additional_domain_route
        for val in $list; do
            [ -n "$val" ] && {
                local rule_str=$(printf 'DOMAIN-SUFFIX,%s,%s' "$val" "$name")
                if [ -n "$rules_array" ]; then
                    rules_array="$rules_array,\"$rule_str\""
                else
                    rules_array="\"$rule_str\""
                fi
                if [ -n "$list_suffix_names" ]; then
                    list_suffix_names="$list_suffix_names,\"+.$val\""
                else
                    list_suffix_names="\"+.$val\""
                fi
            }
        done
        config_get list "$section" additional_destip_route
        for val in $list; do
            [ -n "$val" ] && {
                local rule_str=$(printf 'IP-CIDR,%s,%s' "$val" "$name")
                if [ -n "$rules_array" ]; then
                    rules_array="$rules_array,\"$rule_str\""
                else
                    rules_array="\"$rule_str\""
                fi
            }
        done
    }

    config_foreach _parse_single_proxy proxies

    selectedRuleSets="{${selectedRuleSets%,}}"

    proxies="[$proxies]"

    if [ -n "$rules_array" ]; then
        rules="[$rules_array]"
    else
        rules="[]"
    fi
    if [ -n "$list_rulesets_names" ]; then
        list_rulesets_names="[$list_rulesets_names]"
    else
        list_rulesets_names="[]"
    fi
    if [ -n "$list_suffix_names" ]; then
        list_suffix_names="[$list_suffix_names]"
    else
        list_suffix_names="[]"
    fi

    echo "$rules" > "$file_rules"
    echo "$selectedRuleSets" > "$file_rulesets"
    echo "$proxies" > "$file_proxies"
    echo "$list_rulesets_names" > "$file_rulesets_names"
    echo "$list_suffix_names" > "$file_proxies_names"
}

handle_proxy_group_section() {
    local ruleset_content="$1"
    local file_rules="$2"
    local file_rulesets="$3"
    local file_proxygroups="$4"
    local file_rulesets_names="$5"
    local file_proxies_names="$6"
    local proxy_groups=""
    local rules_array=""
    local proxy_groups_rulesets=""
    local list_rulesets_names=""
    local list_suffix_names=""

    # shellcheck disable=SC2317  # Called via config_foreach
    _parse_proxy_group() {
        local section="$1"
        local name;
        local proxies_list providers_list group_type strategy check_url interval check_timeout tolerance
        local filter exclude_filter exclude_type expected_status
        local enabled_list list_update_interval use_proxy_group_for_list_update list val
        local domain_list cidr_list

        config_get name "$section" name
        [ -z "$name" ] && { log 1 "Skip proxy_group without name: $section" "‚ö†Ô∏è"; return; }

        config_get proxies_list "$section" proxies
        config_get providers_list "$section" providers
        [ -z "$proxies_list" ] && [ -z "$providers_list" ] && { log 1 "Skip empty proxy_group $name" "‚ö†Ô∏è"; return; }

        config_get group_type "$section" group_type
        config_get strategy "$section" strategy
        config_get check_url "$section" check_url
        config_get expected_status "$section" expected_status
        config_get interval "$section" interval
        config_get check_timeout "$section" check_timeout
        config_get tolerance "$section" tolerance
        config_get filter "$section" filter
        config_get exclude_filter "$section" exclude_filter
        config_get exclude_type "$section" exclude_type
        config_get enabled_list "$section" enabled_list
        config_get list_update_interval "$section" list_update_interval
        config_get_bool use_proxy_group_for_list_update "$section" use_proxy_group_for_list_update 0

        [ -z "$interval" ] && interval=$DEFAULT_HEALTHCHECK_INTERVAL
        [ -z "$check_timeout" ] && check_timeout=$DEFAULT_HEALTHCHECK_TIMEOUT
        [ -z "$list_update_interval" ] && list_update_interval=$DEFAULT_RULESET_INTERVAL
        [ -z "$expected_status" ] && expected_status=$DEFAULT_HEALTHCHECK_RESULT

        local escaped_proxies escaped_providers
        [ -n "$proxies_list" ] && escaped_proxies="\"$(echo "$proxies_list" | sed -e 's/"/\\"/g' -e 's/[[:space:]]\+/","/g')\""
        [ -n "$providers_list" ] && escaped_providers="\"$(echo "$providers_list" | sed -e 's/"/\\"/g' -e 's/[[:space:]]\+/","/g')\""

        local group_json="{\"name\":\"$(json_escape "$name")\",\
                        \"type\":\"$(json_escape "$group_type")\",\
                        \"url\":\"$(json_escape "$check_url")\",\
                        \"expected-status\":$expected_status,\
                        \"interval\":$interval,\
                        \"timeout\":$check_timeout,\
                        \"lazy\":true"

        [ "$group_type" = "url-test" ] && group_json="$group_json,\"tolerance\":\"$($tolerance)\""
        [ "$group_type" = "load-balance" ] && group_json="$group_json,\"strategy\":\"$(json_escape "$strategy")\""

        [ -n "$escaped_proxies" ] && group_json="$group_json,\"proxies\":[$escaped_proxies]"
        [ -n "$escaped_providers" ] && group_json="$group_json,\"use\":[$escaped_providers]"
        [ -n "$filter" ] && group_json="$group_json,\"filter\":\"$(json_escape "$filter")\""
        [ -n "$exclude_filter" ] && group_json="$group_json,\"exclude-filter\":\"$(json_escape "$exclude_filter")\""
        [ -n "$exclude_type" ] && group_json="$group_json,\"exclude-type\":\"$(json_escape "$exclude_type")\""
        group_json="$group_json}"

        if [ -z "$proxy_groups" ]; then
            proxy_groups="$group_json"
        else
            proxy_groups="$proxy_groups,$group_json"
        fi

        local added_rulesets="|"
        for ruleset in $enabled_list; do
            if echo "$added_rulesets" | grep -qF "|$ruleset|"; then
                continue
            fi

            local line r_name yaml behavior format url proxy
            line=$(echo "$ruleset_content" | grep -F "|$ruleset|" | head -n 1)
            if [ -n "$line" ]; then
                r_name=$(echo "$line" | cut -d'|' -f1)
                yaml=$(echo "$line" | cut -d'|' -f2)
                behavior=$(echo "$line" | cut -d'|' -f3)
                format=$(echo "$line" | cut -d'|' -f4)
                url=$(echo "$line" | cut -d'|' -f5)

                # shellcheck disable=SC2249
                case "$r_name" in \#*) continue ;; esac

                local rule_str=$(printf 'RULE-SET,%s,%s' "$ruleset" "$name")
                if [ -n "$rules_array" ]; then
                    rules_array="$rules_array,\"$rule_str\""
                else
                    rules_array="\"$rule_str\""
                fi

                [ "$use_proxy_group_for_list_update" -eq 1 ] && proxy="$name" || proxy=$DEFAULT_PROXY
                proxy_groups_rulesets="${proxy_groups_rulesets}\"$ruleset\":{\"url\":\"$(json_escape "$url")\",\"behavior\":\"$(json_escape "$behavior")\",\"format\":\"$(json_escape "$format")\",\"proxy\":\"$(json_escape "$proxy")\",\"interval\":$list_update_interval,\"type\":\"http\"},"
                added_rulesets="$added_rulesets$ruleset|"

                if [ "$behavior" = "domain" ]; then
                    if [ -n "$list_rulesets_names" ]; then
                        list_rulesets_names="$list_rulesets_names,\"rule-set:$ruleset\""
                    else
                        list_rulesets_names="\"rule-set:$ruleset\""
                    fi
                fi
            fi
        done

        config_get domain_list "$section" custom_enabled_domain_list
        for line in $domain_list; do
            if [ -n "$line" ]; then
                local rng_name=$(printf "%s" "$line" | md5sum | awk '{print $1}')
                case "$line" in
                    http://*|https://*)
                        [ "$use_proxy_for_list_update" -eq 1 ] && proxy="$name" || proxy=$DEFAULT_PROXY
                        proxy_groups_rulesets="${proxy_groups_rulesets}\"$rng_name\":{\"url\":\"$(json_escape "$line")\",\"behavior\":\"domain\",\"format\":\"mrs\",\"proxy\":\"$proxy\",\"interval\":$list_update_interval,\"type\":\"http\"},"
                    ;;
                *)
                    if [ -f "$line" ]; then
                        [ "$use_proxy_for_list_update" -eq 1 ] && proxy="$name" || proxy=$DEFAULT_PROXY
                        proxy_groups_rulesets="${proxy_groups_rulesets}\"$rng_name\":{\"path\":\"$(json_escape "$line")\",\"behavior\":\"domain\",\"format\":\"mrs\",\"proxy\":\"$proxy\",\"type\":\"file\"},"
                    else
                        continue
                    fi
                    ;;
                esac

                local rule_str=$(printf 'RULE-SET,%s,%s' "$rng_name" "$name")
                if [ -n "$rules_array" ]; then
                    rules_array="$rules_array,\"$rule_str\""
                else
                    rules_array="\"$rule_str\""
                fi
                if [ -n "$list_rulesets_names" ]; then
                    list_rulesets_names="$list_rulesets_names,\"rule-set:$rng_name\""
                else
                    list_rulesets_names="\"rule-set:$rng_name\""
                fi
            fi
        done

        config_get cidr_list "$section" custom_enabled_cidr_list
        for line in $cidr_list; do
            if [ -n "$line" ]; then
                local rng_name=$(printf "%s" "$line" | md5sum | awk '{print $1}')
                case "$line" in
                    http://*|https://*)
                        [ "$use_proxy_for_list_update" -eq 1 ] && proxy="$name" || proxy=$DEFAULT_PROXY
                        proxy_groups_rulesets="${proxy_groups_rulesets}\"$rng_name\":{\"url\":\"$(json_escape "$line")\",\"behavior\":\"ipcidr\",\"format\":\"mrs\",\"proxy\":\"$proxy\",\"interval\":$list_update_interval,\"type\":\"http\"},"
                    ;;
                *)
                    if [ -f "$line" ]; then
                        [ "$use_proxy_for_list_update" -eq 1 ] && proxy="$name" || proxy=$DEFAULT_PROXY
                        proxy_groups_rulesets="${proxy_groups_rulesets}\"$rng_name\":{\"path\":\"$(json_escape "$line")\",\"behavior\":\"ipcidr\",\"format\":\"mrs\",\"type\":\"file\"},"
                    else
                        continue
                    fi
                    ;;
                esac

                local rule_str=$(printf 'RULE-SET,%s,%s' "$rng_name" "$name")
                if [ -n "$rules_array" ]; then
                    rules_array="$rules_array,\"$rule_str\""
                else
                    rules_array="\"$rule_str\""
                fi
            fi
        done

        config_get list "$section" additional_srcip_route
        for val in $list; do
            [ -n "$val" ] && {
                local rule_str=$(printf 'SRC-IP-CIDR,%s,%s' "$val" "$name")
                if [ -n "$rules_array" ]; then
                    rules_array="$rules_array,\"$rule_str\""
                else
                    rules_array="\"$rule_str\""
                fi
            }
        done

        config_get list "$section" additional_domain_route
        for val in $list; do
            [ -n "$val" ] && {
                local rule_str=$(printf 'DOMAIN-SUFFIX,%s,%s' "$val" "$name")
                if [ -n "$rules_array" ]; then
                    rules_array="$rules_array,\"$rule_str\""
                else
                    rules_array="\"$rule_str\""
                fi
                if [ -n "$list_suffix_names" ]; then
                    list_suffix_names="$list_suffix_names,\"+.$val\""
                else
                    list_suffix_names="\"+.$val\""
                fi
            }
        done

        config_get list "$section" additional_destip_route
        for val in $list; do
            [ -n "$val" ] && {
                local rule_str=$(printf 'IP-CIDR,%s,%s' "$val" "$name")
                if [ -n "$rules_array" ]; then
                    rules_array="$rules_array,\"$rule_str\""
                else
                    rules_array="\"$rule_str\""
                fi
            }
        done
    }

    config_foreach _parse_proxy_group proxy_group

    if [ -n "$proxy_groups_rulesets" ]; then
        proxy_groups_rulesets="{${proxy_groups_rulesets%,}}"
    else
        proxy_groups_rulesets="{}"
    fi

    if [ -n "$proxy_groups" ]; then
        proxy_groups="[$proxy_groups]"
    else
        proxy_groups="[]"
    fi

    if [ -n "$rules_array" ]; then
        rules="[$rules_array]"
    else
        rules="[]"
    fi
    if [ -n "$list_rulesets_names" ]; then
        list_rulesets_names="[$list_rulesets_names]"
    else
        list_rulesets_names="[]"
    fi
    if [ -n "$list_suffix_names" ]; then
        list_suffix_names="[$list_suffix_names]"
    else
        list_suffix_names="[]"
    fi
    echo "$rules" > "$file_rules"
    echo "$proxy_groups_rulesets" > "$file_rulesets"
    echo "$proxy_groups" > "$file_proxygroups"
    echo "$list_rulesets_names" > "$file_rulesets_names"
    echo "$list_suffix_names" > "$file_proxies_names"
}

handle_proxy_provider_section() {
    local result=""

    # shellcheck disable=SC2317
    # shellcheck disable=SC2329
    accumulate_proxy_provider() {
        local s="$1"
        local name url interval filter exclude_filter exclude_type
        local health_check health_check_url health_check_interval health_check_timeout health_check_expected_status

        config_get name "$s" name
        config_get url "$s" subscription
        config_get interval "$s" update_interval
        config_get filter "$s" filter
        config_get exclude_filter "$s" exclude_filter
        config_get exclude_type "$s" exclude_type
        config_get_bool health_check "$s" health_check 0

        { [ -z "$name" ] || [ -z "$url" ]; } && {
            log 1 "Skipping proxy_provider without name or subscription" "‚ö†Ô∏è"
            return
        }

        [ -z "$interval" ] && interval=$DEFAULT_PROVIDERUPDATE_INTERVAL

        local entry="{\"type\":\"http\",\"url\":\"$(json_escape "$url")\",\"interval\":$interval"
        [ -n "$filter" ] && entry="$entry,\"filter\":\"$(json_escape "$filter")\""
        [ -n "$exclude_filter" ] && entry="$entry,\"exclude-filter\":\"$(json_escape "$exclude_filter")\""
        [ -n "$exclude_type" ] && entry="$entry,\"exclude-type\":\"$(json_escape "$exclude_type")\""

        if [ "$health_check" = "1" ]; then
            config_get health_check_expected_status "$s" health_check_expected_status
            config_get health_check_url "$s" health_check_url
            config_get health_check_interval "$s" health_check_interval
            config_get health_check_timeout "$s" health_check_timeout

            [ -z "$health_check_interval" ] && health_check_interval=$DEFAULT_HEALTHCHECK_INTERVAL
            [ -z "$health_check_timeout" ] && health_check_timeout=$DEFAULT_HEALTHCHECK_TIMEOUT
            [ -z "$health_check_url" ] && health_check_url=$DEFAULT_HEALTHCHECK_URL
            [ -z "$health_check_expected_status" ] && health_check_expected_status=$DEFAULT_HEALTHCHECK_RESULT

            entry="$entry,\"health-check\":{\"enable\":true,\"lazy\":true,\"url\":\"$(json_escape "$health_check_url")\",\"expected-status\":$health_check_expected_status,\"interval\":$health_check_interval,\"timeout\":$health_check_timeout}"
        fi

        entry="$entry}"

        result="$result\"$(json_escape "$name")\":$entry,"
    }

    config_foreach accumulate_proxy_provider proxy_provider

    if [ -n "$result" ]; then
        result="{${result%,}}"
    else
        result="{}"
    fi

    echo "$result"
}

handle_block_rule_section() {
    local blocklist_content="$1"
    local file_rules="$2"
    local file_rulesets="$3"
    local rules_array=""
    local selected_rule_sets=""

    local enabled_blocklist
    config_get enabled_blocklist block_rules enabled_blocklist

    local added_blocklists="|"
    local val
    for val in $enabled_blocklist; do
        if echo "$added_blocklists" | grep -qF "|$val|"; then
            continue
        fi

        local line name yamlName behavior format url matched
        line=$(echo "$ruleset_content" | grep -F "|$ruleset|" | head -n 1)
        if [ -n "$line" ]; then
            name=$(echo "$line" | cut -d'|' -f1)
            yamlName=$(echo "$line" | cut -d'|' -f2)
            behavior=$(echo "$line" | cut -d'|' -f3)
            format=$(echo "$line" | cut -d'|' -f4)
            url=$(echo "$line" | cut -d'|' -f5)

            # shellcheck disable=SC2249
            case "$name" in \#*) continue ;; esac

            matched=1
            local rule_str=$(printf 'RULE-SET,%s,REJECT' "$yamlName")  # –ë–µ–∑ \n
            if [ -n "$rules_array" ]; then
                rules_array="$rules_array,\"$rule_str\""
            else
                rules_array="\"$rule_str\""
            fi

            selected_rule_sets="${selected_rule_sets}\"$yamlName\":{\"url\":\"$(json_escape "$url")\",\"behavior\":\"$(json_escape "$behavior")\",\"format\":\"$(json_escape "$format")\",\"proxy\":\"$(json_escape "$DEFAULT_RULESET_PROXY")\",\"interval\":$DEFAULT_RULESET_INTERVAL,\"type\":\"http\"},"
            added_blocklists="$added_blocklists$val|"
        else
            log 1 "Blocklist '$val' can't be found in $blocklist_content" "‚ö†Ô∏è"
        fi
    done

    if [ -n "$selected_rule_sets" ]; then
        selected_rule_sets="{${selected_rule_sets%,}}"
    else
        selected_rule_sets="{}"
    fi

    local additional_domain_blockroute additional_destip_blockroute
    config_get additional_domain_blockroute block_rules additional_domain_blockroute
    config_get additional_destip_blockroute block_rules additional_destip_blockroute

    local domain_val
    for domain_val in $additional_domain_blockroute; do
        [ -n "$domain_val" ] && {
            local rule_str=$(printf 'DOMAIN-SUFFIX,%s,REJECT' "$domain_val")
            if [ -n "$rules_array" ]; then
                rules_array="$rules_array,\"$rule_str\""
            else
                rules_array="\"$rule_str\""
            fi
        }
    done

    local ip_val
    for ip_val in $additional_destip_blockroute; do
        [ -n "$ip_val" ] && {
            local rule_str=$(printf 'IP-CIDR,%s,REJECT' "$ip_val")
            if [ -n "$rules_array" ]; then
                rules_array="$rules_array,\"$rule_str\""
            else
                rules_array="\"$rule_str\""
            fi
        }
    done

    if [ -n "$rules_array" ]; then
        rules="[$rules_array]"
    else
        rules="[]"
    fi

    echo "$rules" > "$file_rules"
    echo "$selected_rule_sets" > "$file_rulesets"
}

handle_direct_rule_section() {
    local ruleset_content="$1"
    local file_rules="$2"
    local file_rulesets="$3"
    local rules_array=""
    local direct_rulesets=""

    local additional_domain_direct additional_domain_keyword_direct additional_domain_regex_direct
    local additional_srcip_direct additional_destip_direct
    local list_update_interval enabled_list
    local domain_list cidr_list


    config_get list_update_interval direct_rules list_update_interval
    config_get enabled_list direct_rules enabled_list
    [ -z "$list_update_interval" ] && list_update_interval=$DEFAULT_RULESET_INTERVAL

    local added_rulesets="|"
    for ruleset in $enabled_list; do
        if echo "$added_rulesets" | grep -qF "|$ruleset|"; then
            continue
        fi

        local line r_name yaml behavior format url proxy
        line=$(echo "$ruleset_content" | grep -F "|$ruleset|" | head -n 1)
        if [ -n "$line" ]; then
            r_name=$(echo "$line" | cut -d'|' -f1)
            yaml=$(echo "$line" | cut -d'|' -f2)
            behavior=$(echo "$line" | cut -d'|' -f3)
            format=$(echo "$line" | cut -d'|' -f4)
            url=$(echo "$line" | cut -d'|' -f5)

            # shellcheck disable=SC2249
            case "$r_name" in \#*) continue ;; esac

            local rule_str=$(printf 'RULE-SET,%s,%s' "$ruleset" "$DEFAULT_RULESET_PROXY")
            if [ -n "$rules_array" ]; then
                rules_array="$rules_array,\"$rule_str\""
            else
                rules_array="\"$rule_str\""
            fi

            direct_rulesets="${direct_rulesets}\"$ruleset\":{\"url\":\"$(json_escape "$url")\",\"behavior\":\"$(json_escape "$behavior")\",\"format\":\"$(json_escape "$format")\",\"proxy\":\"DIRECT\",\"interval\":$list_update_interval,\"type\":\"http\"},"
            added_rulesets="$added_rulesets$ruleset|"
        fi
    done

    config_get domain_list direct_rules custom_enabled_domain_list
    for line in $domain_list; do
        if [ -n "$line" ]; then
            local rng_name=$(printf "%s" "$line" | md5sum | awk '{print $1}')
            case "$line" in
                http://*|https://*)
                    direct_rulesets="${direct_rulesets}\"$rng_name\":{\"url\":\"$(json_escape "$line")\",\"behavior\":\"domain\",\"format\":\"mrs\",\"proxy\":\"DIRECT\",\"interval\":$list_update_interval,\"type\":\"http\"},"
                ;;
            *)
                if [ -f "$line" ]; then
                    direct_rulesets="${direct_rulesets}\"$rng_name\":{\"path\":\"$(json_escape "$line")\",\"behavior\":\"domain\",\"format\":\"mrs\",\"proxy\":\"DIRECT\",\"type\":\"file\"},"
                else
                    continue
                fi
                ;;
            esac
            local rule_str=$(printf 'RULE-SET,%s,%s' "$rng_name" $DEFAULT_RULESET_PROXY)
            if [ -n "$rules_array" ]; then
                rules_array="$rules_array,\"$rule_str\""
            else
                rules_array="\"$rule_str\""
            fi
        fi
    done

    config_get cidr_list direct_rules custom_enabled_cidr_list
    for line in $cidr_list; do
        if [ -n "$line" ]; then
            local rng_name=$(md5sum "$line")
            case "$line" in
                http://*|https://*)
                    direct_rulesets="${direct_rulesets}\"$rng_name\":{\"url\":\"$(json_escape "$line")\",\"behavior\":\"ipcidr\",\"format\":\"mrs\",\"proxy\":\"$proxy\",\"interval\":$interval,\"type\":\"http\"},"
                ;;
            *)
                if [ -f "$line" ]; then
                    direct_rulesets="${direct_rulesets}\"$rng_name\":{\"path\":\"$(json_escape "$line")\",\"behavior\":\"ipcidr\",\"format\":\"mrs\",\"type\":\"file\"},"
                else
                    continue
                fi
                ;;
            esac
            local rule_str=$(printf 'RULE-SET,%s,%s' "$rng_name" $DEFAULT_RULESET_PROXY)
            if [ -n "$rules_array" ]; then
                rules_array="$rules_array,\"$rule_str\""
            else
                rules_array="\"$rule_str\""
            fi
        fi
    done

    config_get additional_domain_direct direct_rules additional_domain_direct
    config_get additional_domain_keyword_direct direct_rules additional_domain_keyword_direct
    config_get additional_domain_regex_direct direct_rules additional_domain_regex_direct
    config_get additional_srcip_direct direct_rules additional_srcip_direct
    config_get additional_destip_direct direct_rules additional_destip_direct

    local val
    for val in $additional_domain_direct; do
        [ -n "$val" ] && {
            local rule_str=$(printf 'DOMAIN-SUFFIX,%s,DIRECT' "$val")  # –ë–µ–∑ \n
            if [ -n "$rules_array" ]; then
                rules_array="$rules_array,\"$rule_str\""
            else
                rules_array="\"$rule_str\""
            fi
        }
    done

    for val in $additional_domain_keyword_direct; do
        [ -n "$val" ] && {
            local rule_str=$(printf 'DOMAIN-KEYWORD,%s,DIRECT' "$val")
            if [ -n "$rules_array" ]; then
                rules_array="$rules_array,\"$rule_str\""
            else
                rules_array="\"$rule_str\""
            fi
        }
    done

    for val in $additional_domain_regex_direct; do
        [ -n "$val" ] && {
            local rule_str=$(printf 'DOMAIN-REGEX,%s,DIRECT' "$val")
            if [ -n "$rules_array" ]; then
                rules_array="$rules_array,\"$rule_str\""
            else
                rules_array="\"$rule_str\""
            fi
        }
    done

    for val in $additional_srcip_direct; do
        [ -n "$val" ] && {
            local rule_str=$(printf 'SRC-IP-CIDR,%s,DIRECT' "$val")
            if [ -n "$rules_array" ]; then
                rules_array="$rules_array,\"$rule_str\""
            else
                rules_array="\"$rule_str\""
            fi
        }
    done

    for val in $additional_destip_direct; do
        [ -n "$val" ] && {
            local rule_str=$(printf 'IP-CIDR,%s,DIRECT' "$val")
            if [ -n "$rules_array" ]; then
                rules_array="$rules_array,\"$rule_str\""
            else
                rules_array="\"$rule_str\""
            fi
        }
    done

    if [ -n "$direct_rulesets" ]; then
        direct_rulesets="{${direct_rulesets%,}}"
    else
        direct_rulesets="{}"
    fi

    local rules
    if [ -n "$rules_array" ]; then
        rules="[$rules_array]"
    else
        rules="[]"
    fi

    echo "$rules" > "$file_rules"
    echo "$direct_rulesets" > "$file_rulesets"
}

handle_final_rule_section() {
    local dest
    config_get dest final_rules final_destination

    local rule_str=$(printf 'MATCH,%s' "${dest:-$DEFAULT_PROXY}")

    local rules
    if [ -n "$rule_str" ]; then
        rules="[\"$rule_str\"]"
    else
        rules="[]"
    fi

    echo "$rules"
}


core_generate_yaml() {
    local log_level tproxy_port unified_delay
    local tcp_concurrent external_controller_port global_client_fingerprint
    local keep_alive_idle keep_alive_interval profile_store_selected profile_store_fake_ip
    local core_ntp_enabled core_ntp_interval core_ntp_server core_ntp_port core_ntp_write_system
    local dns_listen_port use_hosts use_system_hosts fake_ip_filter_mode fake_ip_range dns_cache_max_size
    local etag_support global_ua #mixed_port
    local default_nameserver direct_nameserver proxy_server_nameserver nameserver custom_fake_ip_domains ignore_fake_ip_domains ignore_to_sniff_domains
    local rules_proxies rules_proxygroups rules_block rule_final rules_direct
    local proxies proxy_groups rule_providers proxy_providers names_suffixes_proxy_groups names_suffixes_proxies names_rulesets_proxy_groups names_rulesets_proxies
    local rulesets_direct rulesets_block rulesets_proxygroup rulesets_proxies
    local tmp_rules_file tmp_rulesets_path tmp_proxygroup_path tmp_proxies_path tmp_names_rulesets_path tmp_names_suffixes_path
    local block_rulesets_content rulesets_content
    local fake_ip_filter_data

    config_get log_level proxy log_level
    config_get tproxy_port proxy tproxy_port
    config_get_bool unified_delay proxy unified_delay
    unified_delay=$(ucibool_to_yaml_bool "$unified_delay")
    config_get_bool tcp_concurrent proxy tcp_concurrent
    tcp_concurrent=$(ucibool_to_yaml_bool "$tcp_concurrent")
    config_get external_controller_port proxy external_controller_port
    config_get global_client_fingerprint proxy global_client_fingerprint
    config_get keep_alive_idle proxy keep_alive_idle
    config_get keep_alive_interval proxy keep_alive_interval
    config_get global_ua proxy global_ua
    config_get_bool etag_support proxy etag_support
    etag_support=$(ucibool_to_yaml_bool "$etag_support")
    config_get_bool profile_store_selected proxy profile_store_selected
    profile_store_selected=$(ucibool_to_yaml_bool "$profile_store_selected")
    config_get_bool profile_store_fake_ip proxy profile_store_fake_ip
    profile_store_fake_ip=$(ucibool_to_yaml_bool "$profile_store_fake_ip")
    config_get_bool core_ntp_enabled proxy core_ntp_enabled
    core_ntp_enabled=$(ucibool_to_yaml_bool "$core_ntp_enabled")
    config_get core_ntp_server proxy core_ntp_server
    config_get core_ntp_port proxy core_ntp_port
    config_get core_ntp_interval proxy core_ntp_interval
    config_get_bool core_ntp_write_system proxy core_ntp_write_system
    core_ntp_write_system=$(ucibool_to_yaml_bool "$core_ntp_write_system")
    config_get dns_listen_port proxy dns_listen_port
    config_get dns_cache_max_size proxy dns_cache_max_size
    config_get_bool use_hosts proxy use_hosts
    use_hosts=$(ucibool_to_yaml_bool "$use_hosts")
    config_get_bool use_system_hosts proxy use_system_hosts
    use_system_hosts=$(ucibool_to_yaml_bool "$use_system_hosts")
    config_get fake_ip_filter_mode proxy fake_ip_filter_mode
    config_get fake_ip_range proxy fake_ip_range
    default_nameserver=$(simple_uci_list_to_json_arr proxy default_nameserver)
    direct_nameserver=$(simple_uci_list_to_json_arr proxy direct_nameserver)
    proxy_server_nameserver=$(simple_uci_list_to_json_arr proxy proxy_server_nameserver)
    nameserver=$(simple_uci_list_to_json_arr proxy nameserver)
    custom_fake_ip_domains=$(simple_uci_list_to_json_arr proxy custom_fake_ip_domains)
    ignore_fake_ip_domains=$(simple_uci_list_to_json_arr proxy ignore_fake_ip_domains)
    ignore_to_sniff_domains=$(simple_uci_list_to_json_arr proxy ignore_to_sniff_domains)

    rule_final=$(handle_final_rule_section)
    proxy_providers=$(handle_proxy_provider_section | jq .)

    # optimization: load files one time
    block_rulesets_content=$(cat "$RULESETS_BLOCKS_FILE")
    rulesets_content=$(cat "$RULESETS_FILE")

    tmp_rules_file=$(mktemp "$CORE_WORKDIR_PATH"/tmprulesdirect.XXXXXX)
    tmp_rulesets_path=$(mktemp "$CORE_WORKDIR_PATH"/tmprulesetsdirect.XXXXXX)
    handle_direct_rule_section "$rulesets_content" "$tmp_rules_file" "$tmp_rulesets_path"
    rules_direct=$(cat "$tmp_rules_file")
    rulesets_direct=$(cat "$tmp_rulesets_path")
    rm -f "$tmp_rules_file" "$tmp_rulesets_path"

    tmp_rules_file=$(mktemp "$CORE_WORKDIR_PATH"/tmprules.XXXXXX)
    tmp_rulesets_path=$(mktemp "$CORE_WORKDIR_PATH"/tmprulesets.XXXXXX)
    handle_block_rule_section "$block_rulesets_content" "$tmp_rules_file" "$tmp_rulesets_path"
    rules_block=$(cat "$tmp_rules_file" )
    rulesets_block=$(cat "$tmp_rulesets_path")
    rm -f "$tmp_rules_file" "$tmp_rulesets_path"

    #Creating files in RAM since ASH funcs can't return multiple values, neiter it can return values by reference (so we are going to write result in file)
    tmp_rules_file=$(mktemp "$CORE_WORKDIR_PATH"/tmprules.XXXXXX)
    tmp_rulesets_path=$(mktemp "$CORE_WORKDIR_PATH"/tmprulesets.XXXXXX)
    tmp_proxygroup_path=$(mktemp "$CORE_WORKDIR_PATH"/tmpproxygroups.XXXXXX)
    # Files for strings with names in json arrays (for Fake IP filter)
    tmp_names_rulesets_path=$(mktemp "$CORE_WORKDIR_PATH"/tmpproxygroupsrulesetsnames.XXXXXX)
    tmp_names_suffixes_path=$(mktemp "$CORE_WORKDIR_PATH"/tmpproxygroupssuffixesnames.XXXXXX)
    handle_proxy_group_section "$rulesets_content" "$tmp_rules_file" "$tmp_rulesets_path" "$tmp_proxygroup_path" "$tmp_names_rulesets_path" "$tmp_names_suffixes_path"
    rules_proxygroups=$(cat "$tmp_rules_file" )
    rulesets_proxygroup=$(cat "$tmp_rulesets_path")
    proxy_groups=$(cat "$tmp_proxygroup_path")
    names_rulesets_proxy_groups=$(cat "$tmp_names_rulesets_path")
    names_suffixes_proxy_groups=$(cat "$tmp_names_suffixes_path")
    rm -f "$tmp_rules_file" "$tmp_rulesets_path" "$tmp_proxygroup_path" "$tmp_names_rulesets_path" "$tmp_names_suffixes_path"

    #Creating files in RAM since ASH funcs can't return multiple values, neiter it can return values by reference (so we are going to write result in file)
    tmp_rules_file=$(mktemp "$CORE_WORKDIR_PATH"/tmprules.XXXXXX)
    tmp_rulesets_path=$(mktemp "$CORE_WORKDIR_PATH"/tmprulesets.XXXXXX)
    tmp_proxies_path=$(mktemp "$CORE_WORKDIR_PATH"/tmpproxies.XXXXXX)
    tmp_names_rulesets_path=$(mktemp "$CORE_WORKDIR_PATH"/tmpproxiesrulesetsnames.XXXXXX)
    tmp_names_suffixes_path=$(mktemp "$CORE_WORKDIR_PATH"/tmpproxiessuffixesnames.XXXXXX)
    handle_proxy_section "$rulesets_content" "$tmp_rules_file" "$tmp_rulesets_path" "$tmp_proxies_path" "$tmp_names_rulesets_path" "$tmp_names_suffixes_path"
    rules_proxies=$(cat "$tmp_rules_file")
    rulesets_proxies=$(cat "$tmp_rulesets_path")
    proxies=$(cat "$tmp_proxies_path")
    names_rulesets_proxies=$(cat "$tmp_names_rulesets_path")
    names_suffixes_proxies=$(cat "$tmp_names_suffixes_path")
    rm -f "$tmp_rules_file" "$tmp_rulesets_path" "$tmp_proxies_path" "$tmp_names_rulesets_path" "$tmp_names_suffixes_path"

    if [ "$fake_ip_filter_mode" = "whitelist" ]; then
        fake_ip_filter_data=$(jq -n \
            --arg custom "$custom_fake_ip_domains" \
            --arg nrpg "$names_rulesets_proxy_groups" \
            --arg nspg "$names_suffixes_proxy_groups" \
            --arg nrp "$names_rulesets_proxies" \
            --arg nsp "$names_suffixes_proxies" \
            '($custom | fromjson) + ($nrpg | fromjson) + ($nspg | fromjson) + ($nrp | fromjson) + ($nsp | fromjson)'
        )
    else
        fake_ip_filter_data=$ignore_fake_ip_domains
    fi

    proxies=$(echo "$proxies" | jq .)

    rule_providers=$(
        jq -n \
            --argjson rulesets_direct "$rulesets_direct" \
            --argjson rulesets_block "$rulesets_block" \
            --argjson rulesets_proxies "$rulesets_proxies" \
            --argjson rulesets_proxygroup "$rulesets_proxygroup" \
            'reduce [ $rulesets_direct, $rulesets_block, $rulesets_proxies, $rulesets_proxygroup ][] as $item ({}; . * $item)'
    )

    rules=$(jq -n \
        --arg direct "$rules_direct" \
        --arg block "$rules_block" \
        --arg proxygroups "$rules_proxygroups" \
        --arg proxies "$rules_proxies" \
        --arg final "$rule_final" \
        '($direct | fromjson) + ($block | fromjson) + ($proxygroups | fromjson) + ($proxies | fromjson) + ($final | fromjson) | map(select(length > 0))'
    )

    cat <<EOF > "$OUTPUT_YAML_CONFIG_PATH"
mode: rule
ipv6: false
log-level: $log_level
tproxy-port: $tproxy_port
unified-delay: $unified_delay
tcp-concurrent: $tcp_concurrent
external-controller: 0.0.0.0:$external_controller_port
routing-mark: $NF_TABLE_FWMARK_PROXY
global-client-fingerprint: $global_client_fingerprint
global-ua: $global_ua
find-process-mode: off
geodata-mode: false
etag-support: $etag_support

keep-alive-idle: $keep_alive_idle
keep-alive-interval: $keep_alive_interval

profile:
  store-selected: $profile_store_selected
  store-fake-ip: $profile_store_fake_ip
  tracing: false

ntp:
  enable: $core_ntp_enabled
  write-to-system: $core_ntp_write_system
  server: $core_ntp_server
  port: $core_ntp_port
  interval: $core_ntp_interval

dns:
  enable: true
  listen: 127.0.0.1:$dns_listen_port
  ipv6: false
  use-hosts: $use_hosts
  use-system-hosts: $use_system_hosts
  enhanced-mode: fake-ip
  fake-ip-range: $fake_ip_range
  cache-max-size: $dns_cache_max_size
  default-nameserver: $default_nameserver
  nameserver: $nameserver
  proxy-server-nameserver: $proxy_server_nameserver
  direct-nameserver: $direct_nameserver
  respect-rules: true
  fake-ip-filter-mode: $fake_ip_filter_mode
  fake-ip-filter: $fake_ip_filter_data

sniffer:
  enable: true
  parse-pure-ip: true
  sniff:
    HTTP:
      ports: [80, 8080-8880]
      override-destination: true
    TLS:
      ports: [443, 8443]
    QUIC:
      ports: [443, 8443]
  skip-domain: $ignore_to_sniff_domains

proxies: $proxies
proxy-groups: $proxy_groups
rule-providers: $rule_providers
proxy-providers: $proxy_providers
rules: $rules

EOF

    return 0;
}

rulesets_list_update() {
    local complete_url
    log 2 "Downloading RULE-SETs list file" "üì•"
    complete_url=${RULESETS_FILES_URL_PARTIAL}/${RULESETS_FILENAME}
    curl --progress-bar -L -o "${CORE_WORKDIR_PATH}/${RULESETS_FILENAME}" "$complete_url" || {
        log 0 "Failed to download RULE-SETs list file." "‚ùå"
        return 1
    }
    rm -f "$RULESETS_FILE"
    mv "${CORE_WORKDIR_PATH}/${RULESETS_FILENAME}" "$RULESETS_FILE"
    log 2 "RULE-SET list file was updated" "‚úÖ"

    log 2 "Downloading BLOCK RULE-SETs list file" "üì•"
    complete_url=${RULESETS_FILES_URL_PARTIAL}/${RULESETS_BLOCKS_FILENAME}
    curl --progress-bar -L -o "${CORE_WORKDIR_PATH}/${RULESETS_BLOCKS_FILENAME}" "$complete_url" || {
        log 0 "Failed to download BLOCK RULE-SETs list file." "‚ùå"
        return 1
    }
    rm -f "$RULESETS_BLOCKS_FILE"
    mv "${CORE_WORKDIR_PATH}/${RULESETS_BLOCKS_FILENAME}" "$RULESETS_BLOCKS_FILE"
    log 2 "BLOCK RULE-SETs list file was updated" "‚úÖ"

    return 0
}

core_prepare_workdir() {
    log 2 "Preparing workdir $CORE_WORKDIR_PATH" "üìÅ"

    if [ -d "$CORE_WORKDIR_PATH" ]; then
        [ -f "$OUTPUT_YAML_CONFIG_PATH" ] && rm -f "$OUTPUT_YAML_CONFIG_PATH"
    else
        mkdir -p "$CORE_WORKDIR_PATH"
    fi

    local mihomo_persistent_temp_files
    config_get mihomo_persistent_temp_files settings mihomo_persistent_temp_files
    if [ "$mihomo_persistent_temp_files" -eq 1 ] && [ ! -L "$CORE_WORKDIR_RULES_PATH" ]; then
        log 2 "Generating symlink $DEFAULT_SYMLINKDIR_RULESETS -> $CORE_WORKDIR_RULES_PATH" "üìÅ"
        rm -rf "$CORE_WORKDIR_RULES_PATH"
        [ ! -d "$DEFAULT_SYMLINKDIR_RULESETS" ] &&  mkdir -p "$DEFAULT_SYMLINKDIR_RULESETS"
        ln -sf "$DEFAULT_SYMLINKDIR_RULESETS" "$CORE_WORKDIR_RULES_PATH"
    elif  [ "$mihomo_persistent_temp_files" -eq 0 ] && [ -L "$CORE_WORKDIR_RULES_PATH" ]; then
        log 2 "Removing old symlink $DEFAULT_SYMLINKDIR_RULESETS -> $CORE_WORKDIR_RULES_PATH" "üìÅ"
        rm -rf "$DEFAULT_SYMLINKDIR_RULESETS"
        rm -rf "$CORE_WORKDIR_RULES_PATH"
    fi
}

# TODO: Remove impossible archs
detect_arch() {
    local arch_raw
    arch_raw=$(uname -m)

    case "$arch_raw" in
        x86_64) echo "amd64-v3";;
        aarch64) echo "arm64" ;;
        armv5*) echo "armv5" ;;
        armv6*) echo "armv6" ;;
        armv7*) echo "armv7" ;;
        mips*) echo "mips" ;;
        i[3-6]86) echo "386" ;;
        *) echo "amd64-v3" ;;
    esac
}

get_latest_version() {
    if [ -z "$1" ] || [ -z "$2" ]; then
        log 1 "Usage: get_latest_version <check_url> <link type[effective/noneffective]>"
        return 1
    fi
    local check_url="$1"
    local link_type="$2"
    local latest_url latest_ver
    if [ "$link_type" = "effective" ]; then
        latest_url="${check_url}"
    else
        latest_url=$(curl --progress-bar -L -o /dev/null -w '%{url_effective}' "$check_url") || {
            log 0 "Failed to get effective URL for download" "‚ùå"
            return 1
        }
    fi
    latest_ver=$(curl --progress-bar -L "$latest_url/version.txt" | tr -d '\r\n') || {
        log 0 "Failed to get latest version" "‚ùå"
        return 1
    }
    echo "$latest_ver"
}

core_download() {
    local arch version file_name base_url param_version download_url
    param_version="$2"
    download_url="$1"

    if [ -z "$1" ] || [ -z "$2" ]; then
        log 1 "Usage: core_download <download_url> <version>"
        return 1
    fi

    arch=$(detect_arch)
    mkdir -p "$CORE_WORKDIR_PATH"

    file_name="mihomo-linux-${arch}-${param_version}.gz"
    base_url="${download_url}/${file_name}"

    log 2 "Downloading mihomo binary" "üì•"
    curl --progress-bar -L -o "${CORE_WORKDIR_PATH}/mihomo.gz" "$base_url" || {
        log 0 "Failed to download file." "‚ùå"
        return 1
    }

    log 2 "Extracting to $CORE_PATH" "‚¨áÔ∏è"
    gunzip -c "${CORE_WORKDIR_PATH}/mihomo.gz" > "$CORE_PATH" || {
        log 0 "Failed to extract file." "‚ùå"
        return 1
    }

    log 2 "Mihomo installed at $CORE_PATH" "üöÄ"

    if ! chmod +x "$CORE_PATH"; then
        log 0 "Failed to set executable permissions: $CORE_PATH" "‚ùå"
    fi

    log 2 "Cleaning up temporary files" "üßπ"
    if ! rm -f "${CORE_WORKDIR_PATH}/mihomo.gz"; then
        log 0 "Failed to clean up temporary file: ${CORE_WORKDIR_PATH}/mihomo.gz" "‚ùå"
    fi
}

core_remove() {
    if [ ! -x "$CORE_PATH" ]; then
        log 0 "Mihomo is not installed." "‚ùå"
        return 1
    else
        if rm -f "$CORE_PATH"; then
            log 2 "Mihomo is removed." "‚úÖ"
            return 0
        else
            log 0 "Failed to remove Mihomo binary: $CORE_PATH" "‚ùå"
            return 1
        fi
    fi
}

core_update() {
    local cur_ver latest_ver tmp mihomo_update_channel mihomo_cron_update_telegram_notify
    local check_url check_url_type download_url
    config_get mihomo_update_channel settings mihomo_update_channel
    config_get_bool mihomo_cron_update_telegram_notify settings mihomo_cron_update_telegram_notify

    log 2 "Checking for Mihomo updates..." "üîÑ"

    cur_ver=$(info_mihomo)
    if [ -z "$cur_ver" ]; then
        log 0 "Update process can't be finished." "‚ùå"
        return 1
    fi

    if [ "$mihomo_update_channel" = "alpha" ]; then
        check_url="$CORE_ALPHA_RELEASE_URL_PARTIAL"
        check_url_type="effective"
    else
        check_url="$CORE_RELEASE_URL_PARTIAL"
        check_url_type="noneffective"

    fi

    tmp=$(get_latest_version "$check_url" "$check_url_type")

    if [ "$?" -eq 1 ]; then
        log 0 "Update process can't be finished." "‚ùå"
        return 1
    fi

    #TODO: Fix incorrect output handle (github isnt returning empty body)
    latest_ver=$(echo "$tmp" | sed -n 1p)

    if [ "$mihomo_update_channel" = "alpha" ]; then
        download_url=$CORE_ALPHA_RELEASE_URL_PARTIAL
    else
        download_url=$CORE_RELEASE_URL_PARTIAL_NO_TAG/$latest_ver
    fi

    if [ -z "$latest_ver" ]; then
       log 0 "Error happened when trying to receive latest version data."
       log 0 "It may be due to a GitHub API rate limit or the release may not exist. Please check manually."
       log 0 "Failed to download core"
       return 1
    fi

    if [ "$cur_ver" = "$NO_DATA_STRING" ] || [ -z "$cur_ver" ]; then
        log 1 "Mihomo is not installed. Installing version $latest_ver." "‚ö†Ô∏è"
        core_download "$download_url" "$latest_ver"
        if [ $? -eq 1 ]; then
            log 0 "Update process can't be finished." "‚ùå"
            if [ "$mihomo_cron_update_telegram_notify" -eq 1 ]; then
                send_telegram "Mihomo core binary was missing. Install try for version $latest_ver failed."
            fi
            return 1
        fi
        if [ "$mihomo_cron_update_telegram_notify" -eq 1 ]; then
            send_telegram "Mihomo core binary was missing. Installed $latest_ver"
        fi
        return 0
    fi

    log 2 "Current Mihomo version: $cur_ver"
    log 2 "Latest Mihomo version: $latest_ver"

    if [ "$cur_ver" != "$latest_ver" ]; then
        log 2 "Removing current mihomo binary..." "‚ö†Ô∏è"
        core_remove
        if [ $? -eq 1 ]; then
            log 0 "Update process can't be finished." "‚ùå"
            return 1
        fi
        log 2 "Updating Mihomo to version $latest_ver" "‚¨ÜÔ∏è"
        core_download "$download_url" "$latest_ver"
        if [ $? -eq 1 ]; then
            log 0 "Update process can't be finished." "‚ùå"
            if [ "$mihomo_cron_update_telegram_notify" -eq 1 ]; then
                send_telegram "Mihomo core binary was updated. Install try for version: $cur_ver -> $latest_ver failed."
            fi
            return 1
        fi
        if [ "$mihomo_cron_update_telegram_notify" -eq 1 ]; then
            send_telegram "Mihomo core binary was updated. Version: $cur_ver -> $latest_ver"
        fi
    else
        if [ "$mihomo_cron_update_telegram_notify" -eq 1 ]; then
            send_telegram "Mihomo core binary is already up-to-date."
        fi
        log 2 "Mihomo is already up-to-date." "‚úÖ"
    fi

    return 0
}

send_telegram() {
    if [ -z "$1" ]; then
        log 1 "Usage: send_telegram <message>"
        return 1
    fi

    local message="$1"
    local token chat_id

    config_get token settings telegram_bot_token
    config_get chat_id settings telegram_chat_id

    if [ -z "$token" ] || [ -z "$chat_id" ]; then
        log 1 "Telegram: bot token or chat ID is not configured" "‚ö†Ô∏è"
        return 1
    fi

    response=$(curl -s -w "\n%{http_code}" -X POST "https://api.telegram.org/bot${token}/sendMessage" \
        -d chat_id="$chat_id" \
        -d text="$message" \
        -d parse_mode="HTML" \
        -d disable_notification=true)

    local curl_exit=$?
    http_code=$(echo "$response" | tail -n1)

    if [ "$curl_exit" -ne 0 ]; then
        log 0 "Telegram: network error, curl exited with code $curl_exit" "‚ùå"
        return 1
    fi

    if [ "$http_code" != "200" ]; then
        log 0 "Telegram: failed to send message (HTTP $http_code)" "‚ùå"
        return 1
    fi

    return 0
}

cron_make_if_missing() {
    if [ ! -f "/etc/crontabs/root" ]; then
        touch "/etc/crontabs/root"
    fi
}

core_update_cron_check() {
    cron_make_if_missing
    if grep -qF "/usr/bin/justclash core_update" /etc/crontabs/root; then
        return 0
    else
        return 1
    fi
}

core_update_cron_add() {
    cron_make_if_missing
    local mihomo_cron_update_string

    if [ -z "$mihomo_cron_update_string" ]; then
        log 0 "Cron schedule string is empty! Cron job not added." "‚ùå"
        return 1
    fi

    if core_update_cron_check > /dev/null; then
        log 1 "Core autoupdate cron job already exists." "‚ÑπÔ∏è"
        return 0
    fi

    config_get mihomo_cron_update_string settings mihomo_cron_update_string
    echo "$mihomo_cron_update_string /usr/bin/justclash core_update" >> /etc/crontabs/root
    if /etc/init.d/cron enabled; then
        /etc/init.d/cron restart
        log 2 "Cron job added and service restarted" "‚úÖ"
    else
        log 2 "Cron job added (service not enabled)" "‚ÑπÔ∏è"
    fi
    log 2 "Core autoupdate cron job added." "‚úÖ"
}

core_update_cron_remove() {
    cron_make_if_missing
    if core_update_cron_check > /dev/null; then
        sed -i '\|/usr/bin/justclash core_update|d' /etc/crontabs/root
        if /etc/init.d/cron enabled; then
            /etc/init.d/cron restart
            log 2 "Cron job added and service restarted" "‚úÖ"
        else
            log 2 "Cron job added (service not enabled)" "‚ÑπÔ∏è"
        fi
        log 2 "Core autoupdate cron job removed." "üóëÔ∏è"
    else
        log 2 "Core autoupdate cron job not found." "‚ÑπÔ∏è"
    fi
}

core_autorestart_cron_check() {
    cron_make_if_missing
    if grep -qF "${INITD_PATH} reload" /etc/crontabs/root; then
        return 0
    else
        return 1
    fi
}

core_autorestart_cron_add() {
    cron_make_if_missing
    local mihomo_cron_autorestart_string

     if [ -z "$mihomo_cron_autorestart_string" ]; then
        log 0 "Cron schedule string is empty! Cron job not added." "‚ùå"
        return 1
    fi

    if core_autorestart_cron_check > /dev/null; then
        log 1 "Core autoupdate cron job already exists." "‚ÑπÔ∏è"
        return 0
    fi

    config_get mihomo_cron_autorestart_string settings mihomo_cron_autorestart_string
    echo "$mihomo_cron_autorestart_string ${INITD_PATH} reload" >> /etc/crontabs/root
    if /etc/init.d/cron enabled; then
        /etc/init.d/cron restart
        log 2 "Cron job added and service restarted" "‚úÖ"
    else
        log 2 "Cron job added (service not enabled)" "‚ÑπÔ∏è"
    fi
    log 2 "Core autoupdate cron job added." "‚úÖ"
}

core_autorestart_cron_remove() {
    cron_make_if_missing
    if core_autorestart_cron_check > /dev/null; then
        sed -i "/${INITD_PATH} reload/d" /etc/crontabs/root
        if /etc/init.d/cron enabled; then
            /etc/init.d/cron restart
            log 2 "Cron job added and service restarted" "‚úÖ"
        else
            log 2 "Cron job added (service not enabled)" "‚ÑπÔ∏è"
        fi
        log 2 "Core autoupdate cron job removed." "üóëÔ∏è"
    else
        log 2 "Core autoupdate cron job not found." "‚ÑπÔ∏è"
    fi
}

diag_nft() {
    clog 2 "Checking for 'nft' command..."
    if ! command -v nft >/dev/null 2>&1; then
        clog 0 "The 'nft' command is not available. Please install nftables to continue."
        return 1
    fi

    clog 2 "Verifying existence of NFTables table '$NF_TABLE_NAME'..."
    if ! nft list table ip "$NF_TABLE_NAME" >/dev/null 2>&1; then
        clog 0 "Table '$NF_TABLE_NAME' not found. Please create the required NFTables table."
        return 1
    fi

    clog 2 "Displaying current NFTables configuration:"
    nft list table ip "$NF_TABLE_NAME"

    clog 2 "NFTables check completed successfully."

    return 0
}

diag_route() {
    clog 2 "Verifying existence of route rule..."
    if ! ip rule list | grep -qF "fwmark 0x1 lookup $NF_ROUTE_TABLE"; then
        clog 0 "Route rule 'ip rule add fwmark ""$NF_TABLE_FWMARK_FINAL"" table $NF_ROUTE_TABLE' is missing!"
    fi
    ip rule list

    if ! ip route show table $NF_ROUTE_TABLE | grep -Eq "local (default|0\.0\.0\.0/0) dev lo"; then
         clog 0 "Route table $NF_ROUTE_TABLE is incorrect!"
    fi
    ip route show table $NF_ROUTE_TABLE
}

diag_proxy_resolver() {
    if [ -z "$1" ]; then
        log 1 "Usage: diag_proxy_resolver <domain>"
        return 1
    fi
    local target="$1"
    local dns_listen_port
    config_get dns_listen_port proxy dns_listen_port

    clog 2 "Testing Fake IP DNS resolution..."

    local ip_output
    ip_output=$(nslookup "$target" 127.0.0.1:"$dns_listen_port" 2>/dev/null)
    local exit_code=$?

    local ips
    ips=$(echo "$ip_output" | awk '/^Address: / {print $2}')

    if [ "$exit_code" -ne 0 ] || [ -z "$ips" ]; then
        clog 0 "Fake IP DNS query failed"
        return 1
    else
        echo "$ips"
        clog 2 "Fake IP DNS query successful"
        return 0
    fi
}

diag_external_resolver() {
    if [ -z "$1" ] || [ -z "$2" ]; then
        log 1 "Usage: diag_external_resolver <domain> <dnsresolver>"
        return 1
    fi
    local target="$1"
    local resolver="$2"
    local ip_output exit_code

    clog 2 "Testing DNS resolution..."

    ip_output=$(nslookup "$target" "$resolver" 2>/dev/null)
    exit_code=$?

    ips=$(echo "$ip_output" | awk '/^Address: / {print $2}')

    if [ "$exit_code" -ne 0 ] || [ -z "$ips" ]; then
        clog 0 "External DNS query failed"
        return 1
    else
        clog 2 "$ips"
        clog 2 "External DNS query successful"
        return 0
    fi
}

diag_icmp() {
    local target="${1}"
    local count="${2}"
    if [ -z "$target" ] || [ -z "$count" ]; then
        clog 1 "Usage: diag_icmp <target> <count>"
        return 1
    fi
    local timeout=2
    local ping_output

    ping_output=$(ping -c "$count" -W "$timeout" "$target" 2>&1)
    local exit_code=$?

    if [ "$exit_code" -eq 0 ]; then
        clog 2 "Ping to ${target} is successful"
        clog 2 "$ping_output"
    else
        clog 0 "Ping to ${target} is failed"
        clog 0 "$ping_output"
    fi
}

diag_report() {
    local running autoload pkg_manager
    running=$(service justclash status)
    service justclash enabled
    if [ "$?" -eq 0 ]; then
        echo "yes"
    else
        echo "no"
    fi
    if command -v apk >/dev/null 2>&1; then
        pkg_manager="APK"
    else
        pkg_manager="OPKG"
    fi

cat <<EOF
----------------------------
JustClash diagnostic report:
----------------------------

-> Basic:
Device:  $(info_device)
OpenWRT: $(info_openwrt)
Service: $(info_package)
LuCi:    $(info_luci)
Mihomo:  $(info_mihomo)
Pkg:     $pkg_manager

-> Status:
Active:  $running
Load:  $autoload

-> NFT Tables:
$(diag_nft)

-> Routes:
$(diag_route)

-> ICMP $DIAG_IP_CHECK_PING_YANDEX :
$(diag_icmp "$DIAG_IP_CHECK_PING_YANDEX" 2)

-> ICMP $DIAG_IP_CHECK_PING_GOOGLE :
$(diag_icmp "$DIAG_IP_CHECK_PING_GOOGLE" 2)

-> DNS resolve $DIAG_RESOLVE_URL_YANDEX with proxy:
$(diag_proxy_resolver "$DIAG_IP_CHECK_PING_YANDEX")

-> DNS resolve $DIAG_RESOLVE_URL_YANDEX with $DIAG_IP_CHECK_PING_YANDEX:
$(diag_external_resolver "$DIAG_RESOLVE_URL_YANDEX" "$DIAG_IP_CHECK_PING_YANDEX")

-> DNS resolve $DIAG_RESOLVE_URL_YANDEX with $DIAG_IP_CHECK_PING_GOOGLE:
$(diag_external_resolver "$DIAG_RESOLVE_URL_YANDEX" "$DIAG_IP_CHECK_PING_GOOGLE")

-> Zapret:
$(if [ -f "$ZAPRETINITD_FILEPATH" ]; then echo "Zapret detected."; else echo "No zapret installed."; fi)

-> ByeDPI:
$(if [ -f "$BYEDPI_FILEPATH" ]; then echo "ByeDPI detected."; else echo "No ByeDPI installed."; fi)

-> YouubeUnblock:
$(if [ -f "$YOUTUBEUNBLOCK_FILEPATH" ]; then echo "YoutubeUnblock detected."; else echo "No YoutubeUnblock installed."; fi)

-> DHCP config:
$(uci show dhcp)

-> /etc/resolv.conf:
$(cat /etc/resolv.conf)

-> Service config:
$(uci show justclash.settings)

-> Service proxy config:
$(uci show justclash.proxy)

EOF

}

config_show() {
    uci export justclash
}

config_reset() {
    if [ ! -f "$DEFAULT_CONFIG_PATH" ]; then
        clog 0 "Default config file is missing. Can't use restore functionality"
        return 1
    fi

    clog 2 "Restoring justclash settings..."

    rm -f /etc/config/justclash.bak

    if [ ! -f /etc/config/justclash ]; then
        clog 0 "Current config file not found, nothing to backup"
    else
        if ! mv /etc/config/justclash /etc/config/justclash.bak; then
            clog 0 "Failed to backup config file"
            return 1
        else
            clog  "Old config file can be found at path /etc/config/justclash.bak"
        fi
    fi

    if ! cp "$DEFAULT_CONFIG_PATH" /etc/config/justclash; then
        clog 0 "Failed to restore default config"
        return 1
    fi

    clog 2 "Default settings will be applied at next service restart..."
    return 0
}

help() {
    cat << EOF
Usage: justclash <command> [args]

Service Management:
  start|run               Start the JustClash service.
  stop                    Stop the JustClash service.
  config_show             Show configuration in console
  config_reset            Reset configuration

Mihomo management Commands:
  core_update                     Check current version and update Mihomo if a newer version is available
  core_remove                     Remove the currently installed Mihomo binary

  core_update_cron_check          Check if a scheduled Mihomo core auto-update task exists
  core_update_cron_add            Add a scheduled task to periodically check and update Mihomo core
  core_update_cron_remove         Remove the scheduled Mihomo core auto-update task

  core_autorestart_cron_check     Check if a scheduled Mihomo auto-restart task exists
  core_autorestart_cron_add       Add a scheduled task to automatically restart Mihomo periodically
  core_autorestart_cron_remove    Remove the scheduled Mihomo auto-restart task

Information Commands:
  info_device             Show device model.
  info_openwrt            Show OpenWrt version.
  info_core               Show Mihomo core version.
  info_package            Show JustClash package version.
  info_luci               Show JustClash LuCI app version.
  info_conns_console      Show Mihomo connections.

Diagnostics:
  diag_nft                Run nftables diagnostic.
  diag_route              Run route tables diagnostic.
  diag_icmp               Run internet check with ICMP.
  diag_proxy_resolver     Run Internal DNS diagnostic.
  diag_external_resolver  Run Default DNS diagnostic.

Logs:
  logs|systemlogs [N]     Show last N lines of system logs (default 40).

Help:
  help|?|command          Show this help message.

EOF
}

case "$1" in
    start|run)
        start
        ;;
    stop)
        stop
        ;;
    config_show)
        config_show
        ;;
    config_reset)
        config_reset
        ;;
    core_update)
        core_update
        ;;
    core_remove)
        core_remove
        ;;
    core_update_cron_check)
        core_update_cron_check
        ;;
    core_update_cron_add)
        core_update_cron_add
        ;;
    core_update_cron_remove)
        core_update_cron_remove
        ;;
    core_autorestart_cron_check)
        core_autorestart_cron_check
        ;;
    core_autorestart_cron_add)
        core_autorestart_cron_add
        ;;
    core_autorestart_cron_remove)
        core_autorestart_cron_remove
        ;;
    rulesets_list_update)
        rulesets_list_update
        ;;
    logs|systemlogs)
        case "$2" in
            *[!0-9]* | '')
                systemlogs
                ;;
            *)
                systemlogs "$2"
                ;;
        esac
        ;;
    info_device)
        info_device
        ;;
    info_openwrt)
        info_openwrt
        ;;
    info_core|info_mihomo)
        info_mihomo
        ;;
    info_package)
        info_package
        ;;
    info_luci)
        info_luci
        ;;
    info_conns_console)
        info_conns_console
        ;;
    diag_nft)
        diag_nft
        ;;
    diag_route)
        diag_route
        ;;
    diag_report)
        diag_report
        ;;
    diag_proxy_resolver)
        diag_proxy_resolver "$2"
        ;;
    diag_external_resolver)
        diag_external_resolver "$2" "$3"
        ;;
    diag_icmp)
        diag_icmp "$2" "${3:-3}"
        ;;
    help|?|command)
        help
        ;;
    *)
        clog 2 "Unknown command: $1"
        clog 2 "Type 'justclash help' for a list of available commands."
        exit 1
        ;;
esac
