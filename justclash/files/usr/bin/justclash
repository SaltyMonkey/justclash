#!/bin/ash
# Ash isn't supported properly in spellcheck static analyzer
# Using debian based version (kind of similar)
# shellcheck shell=dash

# shellcheck disable=SC1091
[ -r /lib/functions.sh ] && . /lib/functions.sh
# shellcheck disable=SC1091
[ -r /lib/config/uci.sh ] && . /lib/config/uci.sh

# Variable for standalone or procd start
PROCD_MODE=0
# service pidfile path
PIDFILE="/var/run/justclash.pid"

# setup procd variable: $JUSTCLASH_ENV passed from init.d start
[ "$JUSTCLASH_ENV" = "procd" ] && PROCD_MODE=1 || PROCD_MODE=0

config_load justclash

CORE_LATEST_RELEASE_URL="https://api.github.com/repos/metacubex/mihomo/releases/latest"
CORE_LATEST_ALPHA_RELEASE_URL="https://api.github.com/repos/MetaCubeX/mihomo/releases/tags/Prerelease-Alpha"
CORE_RELEASE_URL_PARTIAL="https://github.com/metacubex/mihomo/releases/download"
CORE_ALPHA_RELEASE_URL_PARTIAL="https://github.com/metacubex/mihomo/releases/download/Prerelease-Alpha"
NO_DATA_STRING="N/A"


CORE_BIN_NAME="mihomo"
# Path to Mihomo core
CORE_PATH="/usr/bin/mihomo/${CORE_BIN_NAME}"
# workdir path (in RAM)
CORE_WORKDIR_PATH="/tmp/justclash/"
OUTPUT_YAML_CONFIG_PATH="${CORE_WORKDIR_PATH}config.yaml"
TMP_YAML_CONFIG_PATH="${CORE_WORKDIR_PATH}config.build.yaml"
OVERRIDE_YAML_CONFIG_PATH="/usr/bin/mihomo/override.config.yaml"

NFT_TABLE_NAME="justclash_tproxy"

# List of NTP server IP addresses:
# 194.190.168.1   ‚Äî ntp1.stratum2.ru (Russian NTP server)
# 195.208.185.17  ‚Äî ntp2.stratum2.ru (Russian NTP server)
# 193.232.128.6   ‚Äî ntp3.stratum2.ru (Russian NTP server)
# 216.239.35.0    ‚Äî time.google.com (Google NTP)
NTP_IPS="194.190.168.1 195.208.185.17 193.232.128.6 216.239.35.0"
# String for nft tables
# Allow traffic on:
# LAN interfaces (lan*)
# bridge interface (br-lan)
ALLOWED_INTERFACES='{ lan*, br-lan }'
# List of conflicting packages:
# podkop (custom proxy)
# iptables-mod-extra (additional iptables modules)
# and https-dns-proxy (DNS over HTTPS proxy)
CONFLICTED_PACKAGES="podkop iptables-mod-extra https-dns-proxy"
CONFLICTED_PATTERNS_DHCP_CONFIG="doh_backup_noresolv doh_backup_server doh_server"
CONFLICTED_PATTERNS_FILEPATH="/etc/config/dhcp"

ucibool_to_yesno() {
    case "$1" in
        1) echo "Yes" ;;
        0) echo "No" ;;
        *) echo "$1" ;;
    esac
}

panic() {
    local message="$1"
    syslog 0 "$message"
    clog 0 "$message"
    stop
    exit 1
}

get_log_level_name() {
    case "$1" in
        0) echo "ERROR" ;;
        1) echo "WARNING" ;;
        2) echo "INFO" ;;
        3) echo "DEBUG" ;;
        *) echo "UNKNOWN" ;;
    esac
}

get_log_level_syslog() {
    case "$1" in
        0) echo "user.err" ;;
        1) echo "user.warning" ;;
        2) echo "user.info" ;;
        3) echo "user.debug" ;;
        *) echo "user.debug" ;;
    esac
}

syslog() {
    local level="$1"
    local message="$2"
    local level_syslog=""
    level_syslog=$(get_log_level_syslog "$level")

    logger -p "$level_syslog" -t "justclash" "$message"
}

clog() {
    local level="$1"
    local message="$2"
    local timestamp=""
    local level_str=""

    [ $PROCD_MODE -eq 1 ] && return

    timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    level_str=$(get_log_level_name "$level")

    printf "[%s] [%s] %s\n" "$timestamp" "$level_str" "$message"
}

log() {
    local level="$1"
    local message="$2"
    local emoji="${3:-}"

    syslog "$level" "$message"

    [ $PROCD_MODE -eq 1 ] && return

    if [ -n "$emoji" ]; then
        clog "$level" "$emoji ${message}"
    else
        clog "$level" "$message"
    fi
}

is_package_installed() {
    local found_pkgs=""
    local pkgcommand=""

    if command -v apk >/dev/null 2>&1; then
        pkgcommand="apk info"
    else
        pkgcommand="opkg list-installed"
    fi

    for pkg in "$@"; do
        if $pkgcommand | grep -qw "$pkg"; then
            found_pkgs="${found_pkgs:+$found_pkgs }$pkg"
        fi
    done

    if [ -n "$found_pkgs" ]; then
        echo "$found_pkgs"
        return 0
    else
        return 1
    fi
}

is_pattern_in_file() {
    local file="$1"
    shift
    if [ ! -r "$file" ]; then
        return 1
    fi
    local found_patterns=""
    for pattern in "$@"; do
        if grep -qE "$pattern" "$file"; then
            found_patterns="${found_patterns:+$found_patterns }$pattern"
        fi
    done
    if [ -n "$found_patterns" ]; then
        echo "$found_patterns"
        return 0
    else
        return 1
    fi
}

ntp_force_sync() {
    local forcefully_update_ntp_at_load
    config_get_bool forcefully_update_ntp_at_load settings forcefully_update_ntp_at_load
    if [ "$forcefully_update_ntp_at_load" -eq 1 ]; then
        NTP_ARGS=""
        for ip in $NTP_IPS; do
            NTP_ARGS="$NTP_ARGS -p $ip"
        done
        # shellcheck disable=SC2086
        /usr/sbin/ntpd -q $NTP_ARGS
    fi

    sleep 2
}

start() {
    log 2 "Initializing Justclash service..." "‚è≥"

    log 2 "Checking for conflicts" "üêû"
    check_for_conflicts

    log 2 "Synchronizing system time" "üïí"
    ntp_force_sync

    log 2 "Preparing Mihomo working directory" "üì¶"
    core_prepare_workdir

    log 2 "Generating configuration..." "üìÑ"
    core_generate_yaml

    log 2 "Configuring TPROXY routing and creating NFTables table" "üîë"
    nft_table_add

    log 2 "Modifying dnsmasq configuration" "üîë"
    dnsmasq_inject

    # Demonizing
    log 2 "Starting Mihomo core" "üöÄ"
    start_core
}

stop() {
    log 2 "Closing Justclash service..." "‚è≥"
    log 2 "Removing TPROXY routing and NFTables table" "üîë"
    nft_table_remove
    log 2 "Restoring default dnsmasq configuration" "üîë"
    dnsmasq_clean
    log 2 "Stopping core process" "üöÄ"
    stop_core
}

restart() {
    log 2 "Performing complete restart of service" "üîÑ"
    stop
    sleep 1
    start
}

info_device() {
   cat /tmp/sysinfo/model || echo "$NO_DATA_STRING"
}

info_openwrt() {
   grep OPENWRT_RELEASE /etc/os-release | cut -d'"' -f2 || echo "$NO_DATA_STRING"
}

info_mihomo() {
    if [ ! -x "$CORE_PATH" ]; then
        echo "$NO_DATA_STRING"
    else
       "$CORE_PATH" -v 2>/dev/null | awk '{ print $3 }'
    fi
}

info_package() {
    local version

    if command -v apk >/dev/null 2>&1; then
        version=$(apk info justclash 2>/dev/null | grep -oP 'justclash-\K.*')
    else
        version=$(opkg list-installed justclash 2>/dev/null | awk '{print $3}')
    fi

    echo "$version" || echo "$NO_DATA_STRING"
}

info_luci() {
    local version

    if command -v apk >/dev/null 2>&1; then
        version=$(apk info luci-app-justclash 2>/dev/null | grep -oP 'justclash-\K.*')
    else
        version=$(opkg list-installed luci-app-justclash 2>/dev/null | awk '{print $3}')
    fi

    echo "$version" || echo "$NO_DATA_STRING"
}

info_conns_console_api() {
    local external_controller_port
    config_get external_controller_port proxy external_controller_port
    local url="http://127.0.0.1:$external_controller_port/connections"
    local response
    # local AUTH=""
    # [ -n "$API_SECRET" ] && AUTH="-H Authorization: Bearer $API_SECRET"

    # response=$(curl -s $AUTH "$URL")
    response=$(curl -s "$url")

    if [ -f "$PIDFILE" ]; then
    echo "$response" | grep -q '"connections":null' && {
        echo "No connections"
        return 1
    }
    fi

    echo "$response" |
    tr -d '\n' | sed 's/},{/}\n{/g' |
    grep -o '{[^}]*}' |
    while read -r conn; do
        src=$(echo "$conn" | grep -o '"sourceIP":"[^"]*"' | cut -d'"' -f4)
        dst=$(echo "$conn" | grep -o '"destinationIP":"[^"]*"' | cut -d'"' -f4)
        port=$(echo "$conn" | grep -o '"destinationPort":[0-9]*' | cut -d':' -f2)
        host=$(echo "$conn" | grep -o '"host":"[^"]*"' | cut -d'"' -f4)
        chain=$(echo "$conn" | grep -o '"chain":\[[^]]*\]' | sed 's/.*\[\(.*\)\]/\1/' | tr -d '"' | tr ',' '‚Üí')
        up=$(echo "$conn" | grep -o '"upload":[0-9.]*' | cut -d':' -f2)
        down=$(echo "$conn" | grep -o '"download":[0-9.]*' | cut -d':' -f2)

        printf "%-15s %-15s %-5s %-25s %-20s %8s KB %8s KB\n" \
            "$src" "$dst" "$port" "$host" "$chain" "$up" "$down"
    done

    return 0
}

info_conns_console() {
    local pid

    if [ -f "$PIDFILE" ]; then
        pid=$(cat "$PIDFILE")
    fi

    if [ -z "$pid" ]; then
        clog 1 "Process '$CORE_BIN_NAME' is not running"
        return 1
    fi

    clog 2 "PID of process '$CORE_BIN_NAME': $pid"

    if command -v ss >/dev/null; then
        clog 2 "Using ss:"
        ss -tunp | grep "$pid"
    elif command -v netstat >/dev/null; then
        clog 2 "Using netstat:"
        netstat -tunp | grep "$pid"
    elif command -v lsof >/dev/null; then
        clog 2 "Using lsof:"
        lsof -i -n -P | grep "$CORE_BIN_NAME"
    else
        clog 1 "Neither ss, netstat, nor lsof found"
    fi
}

systemlogs() {
    local lines=${1:-40}
    if ! command -v logread >/dev/null 2>&1; then
        clog 0 "logread command not found"
        return 1
    fi
    clog 2 "Last $lines logs from justclash:"
    logread -t justclash | tail -n "$lines"
    return 0
}

diag_nft() {
    clog 2 "Checking for 'nft' command..."
    if ! command -v nft >/dev/null 2>&1; then
        clog 0 "The 'nft' command is not available. Please install nftables to continue."
        return 1
    fi

    clog 2 "Verifying existence of NFTables table '$NFT_TABLE_NAME'..."
    if ! nft list table inet "$NFT_TABLE_NAME" >/dev/null 2>&1; then
        clog 0 "Table '$NFT_TABLE_NAME' not found. Please create the required NFTables table."
        return 1
    fi

    clog 2 "Displaying current NFTables configuration:"
    nft list table inet "$NFT_TABLE_NAME"

    clog 2 "NFTables check completed successfully."

    return 0
}

# WARNING: TRY TO NOT USE FUNC MANUALLY - MUST CLEAR ROUTES AND DNSMASQ
start_core() {
    log 2 "Ensuring Mihomo core was previously stopped gracefully..."
    stop_core

    log 2 "Starting Mihomo core..."
    (
        echo $$ > "$PIDFILE"
        exec "$CORE_PATH" -d "$CORE_WORKDIR_PATH" 2>&1 | logger -t justclash
    ) &
}

# WARNING: TRY TO NOT USE FUNC MANUALLY - MUST CLEAR ROUTES AND DNSMASQ
stop_core() {
    log 2 "Stopping Mihomo core..."
    local pid
    if [ -f "$PIDFILE" ]; then
        pid=$(cat "$PIDFILE")
        log 2 "Stopping core process (PID $pid)"

        kill -TERM "$pid" 2>/dev/null

        local count=0
        while kill -0 "$pid" 2>/dev/null && [ $count -lt 4 ]; do
            sleep 1
            count=$((count+1))
        done

        if kill -0 "$pid" 2>/dev/null; then
            log 1 "Force killing process $pid"
            kill -9 "$pid"
        fi

        rm -f "$PIDFILE"
        log 2 "Core process stopped" "‚úÖ"
    else
        log 1 "PID file not found, using fallback stop method"
        killall "$(basename "$CORE_PATH")"
    fi
}

nft_table_add() {
    local tproxy_port
    local routing_mark
    local hex_mark
    local fake_ip_range
    config_get tproxy_port proxy tproxy_port
    config_get routing_mark proxy routing_mark
    config_get fake_ip_range proxy fake_ip_range "198.18.0.0/16"

    hex_mark=$(printf '0x%x' "$routing_mark")

    [ -z "$tproxy_port" ] && panic "tproxy_port not set"
    [ -z "$routing_mark" ] && panic "routing_mark not set"
    [ -z "$fake_ip_range" ] && panic "fake ip range not set"
    [ -z "$hex_mark" ] && panic "routing_mark(hex) not set"

    # Table cleanup
    nft delete table inet "$NFT_TABLE_NAME" 2>/dev/null || true
    nft add table inet "$NFT_TABLE_NAME"

    # IP routes
    nft add set inet "$NFT_TABLE_NAME" reserved_ips { type ipv4_addr\; flags interval\; elements = { \
        0.0.0.0/8, 10.0.0.0/8, 100.64.0.0/10, 127.0.0.0/8, \
        169.254.0.0/16, 172.16.0.0/12, 192.168.0.0/16, \
        224.0.0.0/4, 240.0.0.0/4 } \; }

    # Set for FAKE IP
    nft add set inet "$NFT_TABLE_NAME" fake_ips { type ipv4_addr\; flags interval\; elements = { $fake_ip_range } \; }

    # Chains
    nft add chain inet "$NFT_TABLE_NAME" mangle '{ type filter hook prerouting priority -150; policy accept; }'
    nft add chain inet "$NFT_TABLE_NAME" prerouting_tproxy '{ type filter hook prerouting priority -100; policy accept; }'
    nft add chain inet "$NFT_TABLE_NAME" output '{ type route hook output priority -150; policy accept; }'

    # ---- MANGLE CHAIN ----
    nft add rule inet "$NFT_TABLE_NAME" mangle iifname "$ALLOWED_INTERFACES" ip daddr @fake_ips meta l4proto { tcp, udp } meta mark set "$hex_mark"
    nft add rule inet "$NFT_TABLE_NAME" mangle ct status dnat return
    nft add rule inet "$NFT_TABLE_NAME" mangle meta mark "$hex_mark" return
    nft add rule inet "$NFT_TABLE_NAME" mangle iifname != "$ALLOWED_INTERFACES" return
    nft add rule inet "$NFT_TABLE_NAME" mangle ip daddr @reserved_ips return
    nft add rule inet "$NFT_TABLE_NAME" mangle meta l4proto { tcp, udp } meta mark set "$hex_mark"

    # ---- TPROXY CHAIN ----
    nft add rule inet "$NFT_TABLE_NAME" prerouting_tproxy meta mark "$hex_mark" meta l4proto { tcp, udp } tproxy to :"$tproxy_port"

    # ---- OUTPUT CHAIN ----
    nft add rule inet "$NFT_TABLE_NAME" output meta mark "$hex_mark" return
    nft add rule inet "$NFT_TABLE_NAME" output ct status dnat return
    nft add rule inet "$NFT_TABLE_NAME" output ip daddr @reserved_ips return
    nft add rule inet "$NFT_TABLE_NAME" output ip daddr @fake_ips meta l4proto { tcp, udp } meta mark set "$hex_mark"
    nft add rule inet "$NFT_TABLE_NAME" output meta l4proto { tcp, udp } meta mark set "$hex_mark"

    # Routing
    ip rule del fwmark "$hex_mark" table 100 2>/dev/null || true
    ip rule add fwmark "$hex_mark" table 100
    ip route replace local 0.0.0.0/0 dev lo table 100

    log 3 "TPROXY: port=$tproxy_port, fwmark=$hex_mark, table=100"
}


nft_table_remove() {
    ip rule del fwmark 0x1 table 100 2>/dev/null || true
    nft flush table inet "$NFT_TABLE_NAME" 2>/dev/null || true
    nft delete table inet "$NFT_TABLE_NAME" 2>/dev/null || true
    ip route flush table 100 2>/dev/null || true

    log 2 "TPROXY Clash rules and routing were removed."
}

# Thx Podkop, feels so annoyed already by shell scripting
save_dnsmasq_config() {
    local key="$1"
    local backup_key="$2"
    value=$(uci get "$key" 2>/dev/null)

    if [ -z "$value" ]; then
        uci set "$backup_key"="unset"
    else
        uci set "$backup_key"="$value"
    fi
}

dnsmasq_inject() {
    local dns_listen_port update_dns_server_at_load
    config_get dns_listen_port proxy dns_listen_port
    config_get_bool update_dns_server_at_load settings update_dns_server_at_load

    if [ "$update_dns_server_at_load" -eq 1 ]; then

        uci -q delete dhcp.@dnsmasq[0].justclash_server
        for server in $(uci get dhcp.@dnsmasq[0].server 2>/dev/null); do
            if [ "$server" = "127.0.0.1#${dns_listen_port}" ]; then
                log 1 "Dnsmasq save config error: server=127.0.0.1 is already configured. Skip editing DHCP"
                return 1
            else
                uci add_list dhcp.@dnsmasq[0].justclash_server="$server"
            fi
        done

        save_dnsmasq_config "dhcp.@dnsmasq[0].noresolv" "dhcp.@dnsmasq[0].justclash_noresolv"
        save_dnsmasq_config "dhcp.@dnsmasq[0].cachesize" "dhcp.@dnsmasq[0].justclash_cachesize"

        uci add_list dhcp.@dnsmasq[0].server="127.0.0.1#$dns_listen_port"
        uci set dhcp.@dnsmasq[0].cachesize="0"
        uci set dhcp.@dnsmasq[0].noresolv="1"

        uci commit dhcp
        log 2 "DNS settings have been changed"
        /etc/init.d/dnsmasq restart > /dev/null 2>&1
	    log 2 "dnsmasq restarted"
    else
        log 2 "DNS settings not changed ‚Äî skipped due to configuration"
    fi

}

dnsmasq_clean() {
    local dns_listen_port
    config_get dns_listen_port proxy dns_listen_port
    local update_dns_server
    config_get_bool update_dns_server settings update_dns_server_at_load

    local bak_cachesize
    local bak_noresolv
    local server

    if [ "$update_dns_server" -eq 1 ]; then
        bak_cachesize=$(uci get dhcp.@dnsmasq[0].justclash_cachesize 2>/dev/null)
        if [ -z "$bak_cachesize" ]; then
            log "dnsmasq revert: cachesize is unset"
        else
            uci set dhcp.@dnsmasq[0].cachesize="$bak_cachesize"
        fi

        bak_noresolv=$(uci get dhcp.@dnsmasq[0].justclash_noresolv 2>/dev/null)
        if [ "$bak_noresolv" = "unset" ]; then
            log "dnsmasq revert: noresolv is unset"
            uci -q delete dhcp.@dnsmasq[0].noresolv
        else
            uci set dhcp.@dnsmasq[0].noresolv="$bak_noresolv"
        fi

        server=$(uci get dhcp.@dnsmasq[0].server 2>/dev/null)
        if [ "$server" = "127.0.0.1#${dns_listen_port}" ]; then
            uci -q delete dhcp.@dnsmasq[0].server 2>/dev/null
            for server in $(uci get dhcp.@dnsmasq[0].justclash_server 2>/dev/null); do
                uci add_list dhcp.@dnsmasq[0].server="$server"
            done
            uci delete dhcp.@dnsmasq[0].justclash_server 2>/dev/null
        fi

        uci commit dhcp
        log 2 "DNS settings have been restored"
        /etc/init.d/dnsmasq restart > /dev/null 2>&1
        log 2 "dnsmasq restarted"
    else
        log 2 "DNS settings not changed ‚Äî skipped due to configuration"
    fi
 }

check_for_conflicts() {
    local installed_pkgs found_patterns pkg pattern

    # For $CONFLICTED_PACKAGES only. We don't need "" to make shell split string
    # shellcheck disable=SC2086
    installed_pkgs=$(is_package_installed $CONFLICTED_PACKAGES)
    if [ -n "$installed_pkgs" ]; then
        for pkg in $installed_pkgs; do
            log 1 "Conflicting package detected: $pkg"
        done
        panic "Conflicting packages detected, aborting."
    fi

    # For $CONFLICTED_PATTERNS_DHCP_CONFIG only. We don't need "" to make shell split string
    # shellcheck disable=SC2086
    found_patterns=$(is_pattern_in_file "$CONFLICTED_PATTERNS_FILEPATH" $CONFLICTED_PATTERNS_DHCP_CONFIG)
    if [ -n "$found_patterns" ]; then
        for pattern in $found_patterns; do
            log 1 "Detected https-dns-proxy pattern '$pattern' in /etc/config/dhcp. Please review and edit the configuration file."
        done
        panic "Conflicting DHCP patterns detected, aborting."
    fi
}

# TODO: Finish dynamic prefix
generate_yaml_array() {
    local section_type="$1"
    local list_name="$2"
    local prefix="${4:-    - }"

    result=""

    _append_line() {
        # shellcheck disable=SC2317
        local val="$1"
        # shellcheck disable=SC2317
        result="${result}${prefix}${val}\n"
    }

    _collect_section() {
        # shellcheck disable=SC2317
        config_list_foreach "$1" "$list_name" _append_line
    }

    config_foreach _collect_section "$section_type"

    # shellcheck disable=SC3036
    echo -e "$result"
}

ucibool_to_yaml_bool () {
    local input="$1"
    [ "$input" -eq 1 ] && echo "true" || echo "false"
}

core_generate_yaml() {
    local log_level tproxy_port unified_delay routing_mark
    local tcp_concurrent external_controller_port global_client_fingerprint
    local keep_alive_idle keep_alive_interval profile_store_selected profile_store_fake_ip
    local core_ntp_enabled core_ntp_interval core_ntp_server core_ntp_port  core_ntp_write_system
    local dns_listen_port use_hosts use_system_hosts fake_ip_range

    local default_nameserver direct_nameserver proxy_server_nameserver nameserver ignore_fake_ip_domains ignore_to_sniff_domains

    # Support for manual config files
    # If detected - no settings from config file will be applied
    # DANGEROUS!
    if [ -f OVERRIDE_YAML_CONFIG_PATH ]; then
        log 1 "A dangerous state detected: override configuration file found at \"$OVERRIDE_YAML_CONFIG_PATH\". \
        This file will be used as the active configuration, but correct operation is not guaranteed. \
        This may lead to unexpected behavior, service instability, or security vulnerabilities. \
        Please verify the contents of the override configuration file and ensure it is intended for use before proceeding. \
        If this was not expected, investigate the origin of the override file and consider restoring the default configuration."
        cp "$OVERRIDE_YAML_CONFIG_PATH" "$TMP_YAML_CONFIG_PATH"
        return 0
    fi

    config_get log_level proxy log_level
    config_get tproxy_port proxy tproxy_port
    config_get_bool unified_delay proxy unified_delay
    unified_delay=$(ucibool_to_yaml_bool "$unified_delay")
    config_get routing_mark proxy routing_mark
    config_get_bool tcp_concurrent proxy tcp_concurrent
    tcp_concurrent=$(ucibool_to_yaml_bool "$tcp_concurrent")
    config_get external_controller_port proxy external_controller_port
    config_get global_client_fingerprint proxy global_client_fingerprint
    config_get keep_alive_idle proxy keep_alive_idle
    config_get keep_alive_interval proxy keep_alive_interval
    config_get_bool profile_store_selected proxy profile_store_selected
    profile_store_selected=$(ucibool_to_yaml_bool "$profile_store_selected")
    config_get_bool profile_store_fake_ip proxy profile_store_fake_ip
    profile_store_fake_ip=$(ucibool_to_yaml_bool "$profile_store_fake_ip")
    config_get_bool core_ntp_enabled proxy core_ntp_enabled
    core_ntp_enabled=$(ucibool_to_yaml_bool "$core_ntp_enabled")
    config_get core_ntp_server proxy core_ntp_server
    config_get core_ntp_port proxy core_ntp_port
    config_get core_ntp_interval proxy core_ntp_interval
    config_get_bool core_ntp_write_system proxy core_ntp_write_system
    core_ntp_write_system=$(ucibool_to_yaml_bool "$core_ntp_write_system")
    config_get dns_listen_port proxy dns_listen_port
    config_get_bool use_hosts proxy use_hosts
    use_hosts=$(ucibool_to_yaml_bool "$use_hosts")
    config_get_bool use_system_hosts proxy use_system_hosts
    use_system_hosts=$(ucibool_to_yaml_bool "$use_system_hosts")
    config_get fake_ip_range proxy fake_ip_range
    default_nameserver=$(generate_yaml_array proxy default_nameserver)
    direct_nameserver=$(generate_yaml_array proxy direct_nameserver)
    proxy_server_nameserver=$(generate_yaml_array proxy proxy_server_nameserver)
    nameserver=$(generate_yaml_array proxy nameserver)
    ignore_fake_ip_domains=$(generate_yaml_array proxy ignore_fake_ip_domains)
    ignore_to_sniff_domains=$(generate_yaml_array proxy ignore_to_sniff_domains)

    cat <<EOF > "$TMP_YAML_CONFIG_PATH"
mode: rule
ipv6: false
log-level: $log_level
tproxy-port: $tproxy_port
unified-delay: $unified_delay
tcp-concurrent: $tcp_concurrent
external-controller: 127.0.0.1:$external_controller_port
routing-mark: $routing_mark
global-client-fingerprint: $global_client_fingerprint
global-ua: Mozilla/5.0 (X11; Linux x86_64; rv:125.0) Gecko/20100101 Firefox/125.0

find-process-mode: off
geodata-mode: false

keep-alive-idle: $keep_alive_idle
keep-alive-interval: $keep_alive_interval

profile:
  store-selected: $profile_store_selected
  store-fake-ip: $profile_store_fake_ip
  tracing: false

ntp:
  enable: $core_ntp_enabled
  write-to-system: $core_ntp_write_system
  server: $core_ntp_server
  port: $core_ntp_port
  interval: $core_ntp_interval

dns:
  enable: true
  listen: 0.0.0.0:$dns_listen_port
  ipv6: false
  use-hosts: $use_hosts
  use-system-hosts: $use_system_hosts
  enhanced-mode: fake-ip
  fake-ip-range: $fake_ip_range
  default-nameserver:
$default_nameserver
  nameserver:
$nameserver
  proxy-server-nameserver:
$proxy_server_nameserver
  direct-nameserver:
$direct_nameserver
  respect-rules: true
  fake-ip-filter-mode: blacklist
  fake-ip-filter:
$ignore_fake_ip_domains

sniffer:
  enable: true
  parse-pure-ip: true
  sniff:
    HTTP:
      ports: [80, 8080-8880]
      override-destination: true
    TLS:
      ports: [443, 8443]
    QUIC:
      ports: [443, 8443]
  skip-domain:
$ignore_to_sniff_domains

EOF

    local rules proxies proxy_groups rule_providers
    config_get rules compiled rules
    config_get proxies compiled proxies
    config_get proxy_groups compiled proxy_groups
    config_get rule_providers compiled rule_providers

    cat <<EOF > "$TMP_YAML_CONFIG_PATH"
proxies:
$proxies

proxy-groups:
$proxy_groups

rule-providers:
$rule_providers

rules:
$rules
EOF

    return 0;
}

core_prepare_workdir() {
    log 1 "Preparing workdir $CORE_WORKDIR_PATH"

    if [ -d "$CORE_WORKDIR_PATH" ]; then
        [ -f "$OUTPUT_YAML_CONFIG_PATH" ] && rm -f "$OUTPUT_YAML_CONFIG_PATH"
        [ -f "$TMP_YAML_CONFIG_PATH" ] && rm -f "$TMP_YAML_CONFIG_PATH"
    else
        mkdir -p "$CORE_WORKDIR_PATH"
    fi
}

# TODO: Remove impossible archs
detect_arch() {
    local arch_raw
    arch_raw=$(uname -m)

    case "$arch_raw" in
        x86_64) echo "amd64";;
        aarch64) echo "arm64" ;;
        armv5*) echo "armv5" ;;
        armv6*) echo "armv6" ;;
        armv7*) echo "armv7" ;;
        mips*) echo "mips" ;;
        #riscv64) echo "riscv64" ;;
        i[3-6]86) echo "i386" ;;
        *)
            log 2 "Unknown or unsupported architecture: $arch_raw" "‚ùå" >&2
            return 1
            ;;
    esac
}

get_latest_version() {
    local check_url="$1"
    local latest_url latest_ver
    latest_url=$(curl -sL -o /dev/null -w '%{url_effective}' "$check_url")
    latest_ver=$(curl -sL "$latest_url/version.txt" | tr -d '\r\n')
    echo "$latest_ver"
}

core_download() {
    local arch version file_name base_url param_version download_url
    param_version="$2"
    download_url="$1"

    log 2 "Downloading Mihomo binary..." "üì•"

    mkdir -p "$CORE_WORKDIR_PATH"

    file_name="mihomo-linux-${arch}-${param_version}.gz"
    base_url="${download_url}/${file_name}"

    log 2 "Downloading mihomo binary" "‚¨áÔ∏è"
    curl -sL -o "${CORE_WORKDIR_PATH}/mihomo.gz" "$base_url" || {
        panic "Failed to download file." "‚ùå"
    }

    log 2 "Extracting to $CORE_PATH" "‚¨áÔ∏è"
    gunzip -c "${CORE_WORKDIR_PATH}/mihomo.gz" > "$CORE_PATH" || {
        panic "Failed to extract file." "‚ùå"
    }

    chmod +x "$CORE_PATH"

    log 2 "Cleaning up temporary files" "üßπ"
    rm -f "${CORE_WORKDIR_PATH}/mihomo.gz"

    log 2 "Mihomo installed at $CORE_PATH" "üöÄ"
}

core_update() {
    local cur_ver latest_ver tmp mihomo_update_channel
    local check_url download_url
    config_get mihomo_update_channel settings mihomo_update_channel

    log 2 "Checking for Mihomo updates..." "üîÑ"

    if [ "$mihomo_update_channel" = "alpha" ]; then
        check_url=$CORE_LATEST_ALPHA_RELEASE_URL
    else
        check_url=$CORE_LATEST_RELEASE_URL
    fi

    cur_ver=$(info_mihomo)
    tmp=$(get_latest_version "$check_url")
    latest_ver=$(echo "$tmp" | sed -n 1p)

    if [ "$mihomo_update_channel" = "alpha" ]; then
        download_url=$CORE_ALPHA_RELEASE_URL_PARTIAL
    else
        download_url=$CORE_RELEASE_URL_PARTIAL/$latest_ver
    fi

    if [ -z "$latest_ver" ]; then
       log 1 "Error happened when trying to receive latest version data."
       log 1 "It may be due to a GitHub API rate limit or the release may not exist. Please check manually."
       panic "Failed to download core"
    fi

    if [ "$cur_ver" = "$NO_DATA_STRING" ] || [ -z "$cur_ver" ]; then
        log 1 "Mihomo is not installed. Installing version $latest_ver." "‚ö†Ô∏è"
        core_download "$download_url" "$latest_ver" || return 1
        send_telegram "Mihomo core binary was missing. Installed $latest_ver"
        return 0
    fi

    log 2 "Current Mihomo version: $cur_ver"
    log 2 "Latest Mihomo version: $latest_ver"

    if [ "$cur_ver" != "$latest_ver" ]; then
        log 2 "Removing current mihomo binary..." "‚ö†Ô∏è"
        core_remove
        log 2 "Updating Mihomo to version $latest_ver" "‚¨ÜÔ∏è"
        core_download "$download_url" "$latest_ver" || return 1
        send_telegram "Mihomo core binary was updated. Version: $cur_ver -> $latest_ver"

    else
        log 2 "Mihomo is already up-to-date." "‚úÖ"
    fi
}

core_remove() {
    if [ ! -x "$CORE_PATH" ]; then
        log 1 "Mihomo is not installed." "‚ö†Ô∏è"
        return 1
    else
        rm -f "$CORE_PATH"
        log 2 "Mihomo is removed." "‚úÖ"
        return 0
    fi
}

send_telegram() {
    local message="$1"
    local token chat_id

    config_get token settings telegram_bot_token
    config_get chat_id settings telegram_chat_id

    if [ -z "$token" ] || [ -z "$chat_id" ]; then
        echo "Telegram: bot token or chat ID is not configured" "‚ö†Ô∏è"
        return 1
    fi

    response=$(curl -s -w "\n%{http_code}" -X POST "https://api.telegram.org/bot${token}/sendMessage" \
        -d chat_id="$chat_id" \
        -d text="$message" \
        -d parse_mode="HTML" \
        -d disable_notification=true)

    local curl_exit=$?
    http_code=$(echo "$response" | tail -n1)

    if [ "$curl_exit" -ne 0 ]; then
        log 1 "Telegram: network error, curl exited with code $curl_exit" "‚ùå"
        return 1
    fi

    if [ "$http_code" != "200" ]; then
        log 1 "Telegram: failed to send message (HTTP $http_code)" "‚ùå"
        return 1
    fi

    return 0
}

cron_make_if_missing() {
    if [ ! -f "/etc/crontabs/root" ]; then
        touch "/etc/crontabs/root"
    fi
}

core_update_cron_check() {
    cron_make_if_missing
    if grep -q "/usr/bin/justclash core_update" /etc/crontabs/root; then
        return 0
    else
        return 1
    fi
}

core_update_cron_add() {
    cron_make_if_missing
    local mihomo_cron_update_string

    if [ -z "$mihomo_cron_update_string" ]; then
        log 1 "Cron schedule string is empty! Cron job not added." "‚ùå"
        return 1
    fi

    if core_update_cron_check > /dev/null; then
        log 1 "Core autoupdate cron job already exists." "‚ÑπÔ∏è"
        return 0
    fi

    config_get mihomo_cron_update_string settings mihomo_cron_update_string
    echo "$mihomo_cron_update_string /usr/bin/justclash core_update" >> /etc/crontabs/root
    if /etc/init.d/cron enabled; then
        /etc/init.d/cron restart
        log 2 "Cron job added and service restarted" "‚úÖ"
    else
        log 2 "Cron job added (service not enabled)" "‚ÑπÔ∏è"
    fi
    log 2 "Core autoupdate cron job added." "‚úÖ"
}

core_update_cron_remove() {
    cron_make_if_missing
    if core_update_cron_check > /dev/null; then
        sed -i '\|/usr/bin/justclash core_update|d' /etc/crontabs/root
        if /etc/init.d/cron enabled; then
            /etc/init.d/cron restart
            log 2 "Cron job added and service restarted" "‚úÖ"
        else
            log 2 "Cron job added (service not enabled)" "‚ÑπÔ∏è"
        fi
        log 2 "Core autoupdate cron job removed." "üóëÔ∏è"
    else
        log 2 "Core autoupdate cron job not found." "‚ÑπÔ∏è"
    fi
}

# -----
core_autorestart_cron_check() {
    cron_make_if_missing
    if grep -q "/usr/bin/justclash reload" /etc/crontabs/root; then
        return 0
    else
        return 1
    fi
}

core_autorestart_cron_add() {
    cron_make_if_missing
    local mihomo_cron_autorestart_string

     if [ -z "$mihomo_cron_autorestart_string" ]; then
        log 1 "Cron schedule string is empty! Cron job not added." "‚ùå"
        return 1
    fi

    if core_autorestart_cron_check > /dev/null; then
        log 1 "Core autoupdate cron job already exists." "‚ÑπÔ∏è"
        return 0
    fi

    config_get mihomo_cron_autorestart_string settings mihomo_cron_autorestart_string
    echo "$mihomo_cron_autorestart_string /usr/bin/justclash reload" >> /etc/crontabs/root
    if /etc/init.d/cron enabled; then
        /etc/init.d/cron restart
        log 2 "Cron job added and service restarted" "‚úÖ"
    else
        log 2 "Cron job added (service not enabled)" "‚ÑπÔ∏è"
    fi
    log 2 "Core autoupdate cron job added." "‚úÖ"
}

core_autorestart_cron_remove() {
    cron_make_if_missing
    if core_autorestart_cron_check > /dev/null; then
        sed -i '\|/usr/bin/justclash reload|d' /etc/crontabs/root
        if /etc/init.d/cron enabled; then
            /etc/init.d/cron restart
            log 2 "Cron job added and service restarted" "‚úÖ"
        else
            log 2 "Cron job added (service not enabled)" "‚ÑπÔ∏è"
        fi
        log 2 "Core autoupdate cron job removed." "üóëÔ∏è"
    else
        log 2 "Core autoupdate cron job not found." "‚ÑπÔ∏è"
    fi
}

diag_fake_ip_resolver() {
    local dns_listen_port
    config_get dns_listen_port proxy dns_listen_port

    clog 2 "Testing Fake IP DNS resolution..."
    if ! nslookup google.com 127.0.0.1:"$dns_listen_port" >/dev/null 2>&1; then
        clog 3 "FakeIP IPv4 DNS query failed" "‚ùå"
    else
        clog 2 "FakeIP IPv4 DNS query successful" "‚úÖ"
    fi
}

diag_default_resolver() {
    clog 2 "Testing DNS resolution..."
    if ! nslookup google.com >/dev/null 2>&1; then
        clog 3 "IPv4 DNS query failed" "‚ùå"
    else
        clog 2 "IPv4 DNS query successful" "‚úÖ"
    fi
}

config_show() {
    uci show justclash
}

config_reset() {
    if [ ! -f "/etc/config/default.justclash" ]; then
        log 2 "Default config file is missing. Can't use restore functionality"
    fi

    log 2 "Restoring justclash settings..."

    rm /etc/config/justclash.bak
    mv /etc/config/justclash /etc/config/justclash.bak
    cp /etc/config/default.justclash /etc/config/justclash
}

help() {
    cat << EOF
Usage: justclash <command> [args]

Service Management:
  start|run               Start the JustClash service.
  stop                    Stop the JustClash service.
  reload|restart          Restart the service.
  config_show             Show configuration in console
  config_reset            Reset configuration

Mihomo management Commands:
  core_update                     Check current version and update Mihomo if a newer version is available
  core_remove                     Remove the currently installed Mihomo binary

  core_update_cron_check          Check if a scheduled Mihomo core auto-update task exists
  core_update_cron_add            Add a scheduled task to periodically check and update Mihomo core
  core_update_cron_remove         Remove the scheduled Mihomo core auto-update task

  core_autorestart_cron_check     Check if a scheduled Mihomo auto-restart task exists
  core_autorestart_cron_add       Add a scheduled task to automatically restart Mihomo periodically
  core_autorestart_cron_remove    Remove the scheduled Mihomo auto-restart task

Information Commands:
  info_device             Show device model.
  info_openwrt            Show OpenWrt version.
  info_core               Show Mihomo core version.
  info_package            Show JustClash package version.
  info_luci               Show JustClash LuCI app version.
  info_conns_console_api  Show Mihomo connections via ext. controller API.
  info_conns_console      Show Mihomo connections.

Diagnostics:
  diag_nft                Run nftables diagnostic.
  diag_fake_ip_resolver   Run Fake IP DNS diagnostic.
  diag_default_resolver   Run Default DNS diagnostic.

Logs:
  logs|systemlogs [N]     Show last N lines of system logs (default 40).

Help:
  help|?|command          Show this help message.

EOF
}

case "$1" in
    start|run)
        start
        ;;
    stop)
        stop
        ;;
    reload|restart)
        restart
        ;;
    config_show)
        config_show
        ;;
    config_reset)
        config_reset
        ;;
    core_update)
        core_update
        ;;
    core_remove)
        core_remove
        ;;
    core_update_cron_check)
        core_update_cron_check
        ;;
    core_update_cron_add)
        core_update_cron_add
        ;;
    core_update_cron_remove)
        core_update_cron_remove
        ;;
    core_autorestart_cron_check)
        core_autorestart_cron_check
        ;;
    core_autorestart_cron_add)
        core_autorestart_cron_add
        ;;
    core_autorestart_cron_remove)
        core_autorestart_cron_remove
        ;;
    logs|systemlogs)
        case "$2" in
            *[!0-9]* | '')
                systemlogs
                ;;
            *)
                systemlogs "$2"
                ;;
        esac
        ;;
    info_device)
        info_device
        ;;
    info_openwrt)
        info_openwrt
        ;;
    info_core)
        info_mihomo
        ;;
    info_package)
        info_package
        ;;
    info_luci)
        info_luci
        ;;
    info_conns_console_api)
        info_conns_console_api
        ;;
    info_conns_console)
        info_conns_console
        ;;
    diag_nft)
        diag_nft
        ;;
    diag_fake_ip_resolver|diag_fake_ip)
        diag_fake_ip_resolver
        ;;
    diag_default_resolver|diag_dns)
        diag_default_resolver
        ;;
    help|?|command)
        help
        ;;
    *)
        clog 2 "Unknown command: $1"
        clog 2 "Type 'justclash help' for a list of available commands."
        exit 1
        ;;
esac